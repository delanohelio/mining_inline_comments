{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NzQ4Mzk0", "number": 9187, "title": "[homeconnect] Initial contribution", "bodyText": "Home Connect Binding\nThe binding integrates the Home Connect system into openHAB. It uses the Home Connect API to connect to household devices (mainly Bosch and Siemens).\nHome Connect homepage: https://www.home-connect.com\nHome Connect developer site: https://developer.home-connect.com\nA snapshot of the binding can be downloaded from the community page Home Connect addon: Looking for beta testers.\nSigned-off-by: Jonas Br\u00fcstel jonas@bruestel.net", "createdAt": "2020-11-30T19:03:01Z", "url": "https://github.com/openhab/openhab-addons/pull/9187", "merged": true, "mergeCommit": {"oid": "a1a990989e2674474e593552e6ee309fd06b0bfc"}, "closed": true, "closedAt": "2021-05-13T12:56:04Z", "author": {"login": "bruestel"}, "timelineItems": {"totalCount": 53, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjdqjvgFqTU0NTY4MjcyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABeWXL4bgFqTY1ODg3MjYyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjgyNzI0", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-545682724", "createdAt": "2020-12-06T08:35:00Z", "commit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwODozNTowMFrOIAHK2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwOTozMjoxOFrOIAHxsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk4ODM3Nw==", "bodyText": "This file is no more pushed in Git.\n@cpmeister will confirm.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536988377", "createdAt": "2020-12-06T08:35:00Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/.classpath", "diffHunk": "@@ -0,0 +1,33 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk4ODM4OQ==", "bodyText": "This file is no more pushed in Git.\n@cpmeister will confirm.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536988389", "createdAt": "2020-12-06T08:35:11Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/.project", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk4ODU5NQ==", "bodyText": "There is a wish to suppress this dependency in OH3.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536988595", "createdAt": "2020-12-06T08:36:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/NOTICE", "diffHunk": "@@ -0,0 +1,90 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab2-addons\n+\n+== Third-party Content\n+\n+okhttp / okhttp-sse\n+* License: Apache License 2.0\n+* Project: https://square.github.io/okhttp/\n+* Source:  https://github.com/square/okhttp\n+\n+okio\n+* License: Apache License 2.0\n+* Project: https://square.github.io/okio/\n+* Source:  https://github.com/square/okio\n+\n+Apache Commons Collections\n+* License: Apache License 2.0\n+* Project: https://commons.apache.org/proper/commons-collections/\n+* Source:  https://gitbox.apache.org/repos/asf?p=commons-collections.git", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5MDA0Mg==", "bodyText": "... until it is disabled manually by the customer  ...", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536990042", "createdAt": "2020-12-06T08:45:35Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,310 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout. | fridgefreezer | ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5MDE1Mg==", "bodyText": "... until it is disabled manually by the customer ...", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536990152", "createdAt": "2020-12-06T08:46:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,310 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the home appliance because of a timeout. | fridgefreezer | ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5MTU5Nw==", "bodyText": "Just for clarity, should the thing be created before doing step 5 ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536991597", "createdAt": "2020-12-06T08:54:47Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,310 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Enter\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5MjEzNQ==", "bodyText": "Looks a little strange to propose something with \"simulator\" especially when the simulator setting is set to false.\nWhy mentioning \"simulator\" here ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536992135", "createdAt": "2020-12-06T08:57:51Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,310 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled by the manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Enter\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.\n+6. Please follow the steps shown to authenticate your binding. You can redo this step every time. For example if you have authentication problems, just start wizard again.  \n+![Screenshot Home Connect wizard page 1](doc/homeconnect_setup_1.png \"Screenshot Home Connect wizard page 1\")  \n+![Screenshot Home Connect wizard page 2](doc/homeconnect_setup_2.png \"Screenshot Home Connect wizard page 2\")  \n+![Screenshot Home Connect wizard page 3](doc/homeconnect_setup_3.png \"Screenshot Home Connect wizard page 3\")  \n+![Screenshot Home Connect wizard page 4](doc/homeconnect_setup_4.png \"Screenshot Home Connect wizard page 4\")  \n+\n+7. That's it! Now you can use autodiscovery to add devices. Your devices should show up if you start a device scan in the openHAB UI.\n+\n+\n+\n+## Examples: File based configuration\n+\n+If you prefer to configure everything via file instead of openHAB UI, here are some examples.\n+\n+### things/homeconnect.things\n+\n+```\n+Bridge homeconnect:api_bridge:simulator_api_bridge \"Home Connect API (Simulator)\" [ clientId=\"1234\", clientSecret=\"1234\", simulator=false] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5MzY3MA==", "bodyText": "Take care, replace spotify.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536993670", "createdAt": "2020-12-06T09:06:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.spotify-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NDg4MA==", "bodyText": "Generally set directly when defining the variable.\nSame comment for all classes.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536994880", "createdAt": "2020-12-06T09:12:44Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5NTA0MA==", "bodyText": "Connect", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536995040", "createdAt": "2020-12-06T09:13:50Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final Queue<Event> eventQueue;\n+\n+    private final Logger logger;\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(EVENT_QUEUE_SIZE));\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Conncet API. This helps to reduce the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk5ODMyMA==", "bodyText": "Why not using the constant you defined in HomeConnectBindingConstants ?\nSame comment for other methods.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r536998320", "createdAt": "2020-12-06T09:32:18Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+        jsonParser = new JsonParser();\n+        communicationQueue = QueueUtils.synchronizedQueue(new CircularFifoQueue<>(COMMUNICATION_QUEUE_SIZE));\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances\");\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(\"/api/homeappliances/\" + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, \"BSH.Common.Setting.AmbientLightEnabled\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjM5Mjkw", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-546639290", "createdAt": "2020-12-07T23:56:42Z", "commit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzo1Njo0MlrOIBAYqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDoyMzo1N1rOIBBDZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyNTgwMg==", "bodyText": "Author is now no more defined here. (but only in sources)", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537925802", "createdAt": "2020-12-07T23:56:42Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"homeconnect\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Home Connect Binding</name>\n+\t<description>This is the binding for Home Connect.</description>\n+\t<author>Jonas Br\u00fcstel</author>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyNzMyNw==", "bodyText": "Please add <context>password</context> to avoid showing this value in UI.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537927327", "createdAt": "2020-12-08T00:00:00Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkyODE3Ng==", "bodyText": "I suggest to add <advanced>true</advanced> to this configuration setting.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537928176", "createdAt": "2020-12-08T00:02:03Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzMDU0MQ==", "bodyText": "Please add <representation-property>haId</representation-property> just before config-description.\nSame in all things types.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537930541", "createdAt": "2020-12-08T00:08:07Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNDc4OA==", "bodyText": "... until it is disabled manually by the customer  ...", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537934788", "createdAt": "2020-12-08T00:19:10Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 489}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNDgyMw==", "bodyText": "... until it is disabled manually by the customer  ...", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537934823", "createdAt": "2020-12-08T00:19:16Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_freezer\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Freezer super mode</label>\n+\t\t<description>This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled by the manually by the customer or by the home appliance because of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 496}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNjc0Mg==", "bodyText": "Just a remark: you are not using Dimmer ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r537936742", "createdAt": "2020-12-08T00:23:57Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,664 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled by the manually by the customer or by the HA because of a timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_freezer\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Freezer super mode</label>\n+\t\t<description>This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled by the manually by the customer or by the home appliance because of\n+\t\t\ta timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"dryer_drying_target\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Drying target</label>\n+\t\t<description>Specifies the desired dryness setting.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_venting_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Venting level</label>\n+\t\t<description>Current venting level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_intensive_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Intensive level</label>\n+\t\t<description>Current venting intensive level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<description>Start hood program.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Functional light state</label>\n+\t\t<description>This setting describes the current functional light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Functional light brightness</label>\n+\t\t<description>This setting describes the brightness state of the functional light.</description>\n+\t\t<state readOnly=\"false\" min=\"10\" max=\"100\" step=\"1\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Ambient light state</label>\n+\t\t<description>This setting describes the current ambient light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 540}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTA1MDgw", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-547505080", "createdAt": "2020-12-08T18:20:03Z", "commit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 104, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxODoyMDowM1rOIBu9jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMDoyNDowN1rOIB0knw==", "hasNextPage": true, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4ODkwOA==", "bodyText": "You can simplufy your class by extending BaseDynamicStateDescriptionProvider like in most of other bindings.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538688908", "createdAt": "2020-12-08T18:20:03Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import java.util.Locale;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic thing values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider implements DynamicStateDescriptionProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY5MTU3Mg==", "bodyText": "\"were sent\" I believe", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538691572", "createdAt": "2020-12-08T18:22:38Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/EventHandler.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+\n+/**\n+ * The {@link EventHandler} is responsible for handling events, which where send via Server-Sent event interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwMzY3Mg==", "bodyText": "Implements ThingHandlerService.\nThis will simplify a lot of your thing handler factory.\nIn your bridge handler add, the method getServices.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538703672", "createdAt": "2020-12-08T18:34:24Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNTIxNw==", "bodyText": "DEBUG level is better", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538705217", "createdAt": "2020-12-08T18:35:47Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwNzA3NQ==", "bodyText": "Add .withRepresentationProperty(HA_ID)", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538707075", "createdAt": "2020-12-08T18:37:35Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ==", "bodyText": "What's the utility of this line ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538709005", "createdAt": "2020-12-08T18:39:37Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw==", "bodyText": "You could use Map<String, Object> properties = Map.of(HA_ID, appliance.getHaId());", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538710047", "createdAt": "2020-12-08T18:40:46Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTEzNQ==", "bodyText": "DEBUG level is sufficient.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538711135", "createdAt": "2020-12-08T18:41:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjIxNQ==", "bodyText": "Rather use removeOlderResults(getTimestampOfLastScan(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712215", "createdAt": "2020-12-08T18:42:57Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        super.stopScan();\n+        removeOlderResults(getTimestampOfLastScan());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMjUyMg==", "bodyText": "Rather use removeOlderResults(new Date().getTime(), bridgeHandler.getThing().getUID()); to remove only things attached to your bridge.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538712522", "createdAt": "2020-12-08T18:43:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMzUxOQ==", "bodyText": "Once you use representation property, you don't need anymore to check if the thing already exists.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538713519", "createdAt": "2020-12-08T18:44:50Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNTQ4NQ==", "bodyText": "Using the ThingHandlerService solution, you don't have anymore to do that.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538715485", "createdAt": "2020-12-08T18:47:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjEwMQ==", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716101", "createdAt": "2020-12-08T18:48:30Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final HomeConnectServlet homeConnectServlet;\n+\n+    @Activate\n+    public HomeConnectHandlerFactory(@Reference OAuthFactory oAuthFactory,\n+            @Reference HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider,\n+            @Reference HomeConnectServlet homeConnectServlet) {\n+        this.oAuthFactory = oAuthFactory;\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        this.homeConnectServlet = homeConnectServlet;\n+\n+        discoveryServiceRegistrations = new HashMap<>();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_API_BRIDGE.equals(thingTypeUID)) {\n+            HomeConnectBridgeHandler bridgeHandler = new HomeConnectBridgeHandler((Bridge) thing, oAuthFactory,\n+                    homeConnectServlet);\n+\n+            // configure discovery service\n+            HomeConnectDiscoveryService discoveryService = new HomeConnectDiscoveryService(bridgeHandler);\n+            discoveryServiceRegistrations.put(bridgeHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));\n+\n+            return bridgeHandler;\n+        } else if (THING_TYPE_DISHWASHER.equals(thingTypeUID)) {\n+            return new HomeConnectDishwasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_OVEN.equals(thingTypeUID)) {\n+            return new HomeConnectOvenHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_WASHER_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectWasherDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_DRYER.equals(thingTypeUID)) {\n+            return new HomeConnectDryerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_FRIDGE_FREEZER.equals(thingTypeUID)) {\n+            return new HomeConnectFridgeFreezerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COFFEE_MAKER.equals(thingTypeUID)) {\n+            return new HomeConnectCoffeeMakerHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_HOOD.equals(thingTypeUID)) {\n+            return new HomeConnectHoodHandler(thing, dynamicStateDescriptionProvider);\n+        } else if (THING_TYPE_COOKTOP.equals(thingTypeUID)) {\n+            return new HomeConnectCooktopHandler(thing, dynamicStateDescriptionProvider);\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    protected void removeHandler(ThingHandler thingHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNjMzMw==", "bodyText": "Can be removed if you use the ThingHandlerService solution.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538716333", "createdAt": "2020-12-08T18:48:52Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/factory/HomeConnectHandlerFactory.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.factory;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SUPPORTED_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_API_BRIDGE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCoffeeMakerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectCooktopHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDishwasherHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectFridgeFreezerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectHoodHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectOvenHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherDryerHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectWasherHandler;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HomeConnectHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.homeconnect\", service = ThingHandlerFactory.class)\n+public class HomeConnectHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegistrations;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyMDEzMg==", "bodyText": "DEBUG or WARN level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538720132", "createdAt": "2020-12-08T18:54:09Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcyOTk0MQ==", "bodyText": "If the purpose of a kind of cache, rather than using something from Apache Commons, you have already one cache class in the openHAB core framework.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538729941", "createdAt": "2020-12-08T19:03:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMTQ2OA==", "bodyText": "A switch/case might be more appropriate.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538731468", "createdAt": "2020-12-08T19:05:45Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMzQ4Ng==", "bodyText": "isThingReadyToHandleCommand() is true, you should not have to do all this stuff.\nGenerally we have a variable bridgeHandler which is set in initialize method.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538733486", "createdAt": "2020-12-08T19:09:05Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDE1MQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734151", "createdAt": "2020-12-08T19:10:05Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDgyNA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734824", "createdAt": "2020-12-08T19:11:08Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNDg4Ng==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538734886", "createdAt": "2020-12-08T19:11:16Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjA2OQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736069", "createdAt": "2020-12-08T19:12:56Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjM4OQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736389", "createdAt": "2020-12-08T19:13:25Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczNjcxNA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538736714", "createdAt": "2020-12-08T19:13:58Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MTkzNg==", "bodyText": "This call will trigger HTTP requests. You should run in a separate thread to be sure that initialize() will return fast.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538741936", "createdAt": "2020-12-08T19:21:47Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MjQ1Mw==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538742453", "createdAt": "2020-12-08T19:22:34Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ==", "bodyText": "DEBUG lovel", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538743371", "createdAt": "2020-12-08T19:24:05Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 545}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744299", "createdAt": "2020-12-08T19:25:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDM4OA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744388", "createdAt": "2020-12-08T19:25:37Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 570}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDc5OA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538744798", "createdAt": "2020-12-08T19:26:20Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 601}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NjE1Nw==", "bodyText": "Use UnDefType.UNDEF rather than UnDefType.NULL.\nUnDefType.NULL is normally not used by bindiongs, it is the init state of any channel before it is first set.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538746157", "createdAt": "2020-12-08T19:28:21Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 631}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ==", "bodyText": "This is generally something done in initialize() / bridgeStatusChanged()", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538750641", "createdAt": "2020-12-08T19:35:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 779}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MjQzMg==", "bodyText": "One time again, once the bridge is ONLINE, you should have a variable that give you the bridge handler.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538752432", "createdAt": "2020-12-08T19:38:11Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 814}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDcyNw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538754727", "createdAt": "2020-12-08T19:41:54Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 866}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTMzMA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755330", "createdAt": "2020-12-08T19:42:49Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 889}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTY1MA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755650", "createdAt": "2020-12-08T19:43:22Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 913}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTcxNg==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755716", "createdAt": "2020-12-08T19:43:30Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 919}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NTgzMg==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538755832", "createdAt": "2020-12-08T19:43:40Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 929}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjAyOA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756028", "createdAt": "2020-12-08T19:44:03Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 946}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjQzOQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756439", "createdAt": "2020-12-08T19:44:36Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 964}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjUwMg==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756502", "createdAt": "2020-12-08T19:44:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 967}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NjY2NA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756664", "createdAt": "2020-12-08T19:45:00Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 980}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njc0NA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756744", "createdAt": "2020-12-08T19:45:06Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 983}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njg3NA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756874", "createdAt": "2020-12-08T19:45:21Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1022}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1Njk1MA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538756950", "createdAt": "2020-12-08T19:45:29Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1025}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzMxNA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757314", "createdAt": "2020-12-08T19:46:06Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1015}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzUzMQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757531", "createdAt": "2020-12-08T19:46:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1031}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzY1NQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757655", "createdAt": "2020-12-08T19:46:39Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1047}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NzczMw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538757733", "createdAt": "2020-12-08T19:46:45Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1050}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODE1Mg==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758152", "createdAt": "2020-12-08T19:47:24Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1095}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODIyNw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758227", "createdAt": "2020-12-08T19:47:31Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1098}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODM0MA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758340", "createdAt": "2020-12-08T19:47:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQxOA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758418", "createdAt": "2020-12-08T19:47:51Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODQ3NQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758475", "createdAt": "2020-12-08T19:48:01Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODU0NQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538758545", "createdAt": "2020-12-08T19:48:06Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjQxOQ==", "bodyText": "Then set this.reinitializationFuture1 to null ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538762419", "createdAt": "2020-12-08T19:54:23Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzAwNw==", "bodyText": "Then set this.reinitializationFuture2 to null ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538763007", "createdAt": "2020-12-08T19:55:14Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+            @Nullable\n+            Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                @Nullable\n+                BridgeHandler bridgeHandler = bridge.getHandler();\n+                if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                    HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+\n+                    try {\n+                        homeConnectBridgeHandler.getOAuthClientService().remove();\n+                        homeConnectBridgeHandler.dispose();\n+                        homeConnectBridgeHandler.initialize();\n+                    } catch (OAuthException e) {\n+                        // client is already closed --> we can ignore it\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.NULL : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.NULL);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.warn(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.NULL);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.NULL);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.NULL;\n+                }\n+            } else {\n+                return UnDefType.NULL;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.NULL;\n+                }\n+            }\n+            return UnDefType.NULL;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected State cachePutIfAbsentAndGet(ChannelUID channelUID, Map<ChannelUID, State> cache,\n+            SupplierWithException<State> supplier)\n+            throws AuthorizationException, ApplianceOfflineException, CommunicationException {\n+\n+        // noinspection SynchronizationOnLocalVariableOrMethodParameter\n+        synchronized (cache) {\n+            State state = cache.get(channelUID);\n+            if (state == null) {\n+                state = supplier.get();\n+                cache.put(channelUID, state);\n+            }\n+            return state;\n+        }\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelTemperature.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+                channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                        .removeStateDescriptions(channel.getUID().getAsString()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        createStateDescription(option, this::convertWasherSpinSpeed)\n+                                .ifPresent(stateDescription -> channelSpinSpeed\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        createStateDescription(option, this::convertWasherTemperature)\n+                                .ifPresent(stateDescription -> channelTemperature\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        createStateDescription(option, this::mapStringType)\n+                                .ifPresent(stateDescription -> channelDryingTarget\n+                                        .ifPresent(channel -> dynamicStateDescriptionProvider.putStateDescriptions(\n+                                                channel.getUID().getAsString(), stateDescription)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private Optional<StateDescription> createStateDescription(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        ArrayList<StateOption> stateOptions = new ArrayList<>();\n+        option.getAllowedValues().forEach(av -> stateOptions.add(new StateOption(av, stateConverter.apply(av))));\n+\n+        @Nullable\n+        StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+        return stateDescription == null ? Optional.empty() : Optional.of(stateDescription);\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {\n+        this.reinitializationFuture2 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && !accessible.get()) {\n+                logger.debug(\"Offline monitor 2: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 2: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    dispose();\n+                    initialize();\n+                } else {\n+                    scheduleOfflineMonitor2();\n+                }\n+            } else {\n+                scheduleOfflineMonitor2();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_2_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor2() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture2;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 1367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NjE4Mw==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766183", "createdAt": "2020-12-08T20:00:09Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2Njk1Ng==", "bodyText": "All the code than can take time should be run in a separate thread to be sure to have a fast run of initialize()", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538766956", "createdAt": "2020-12-08T20:01:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODEyMw==", "bodyText": "This is normally handled by the thing manager when it disposes your handler.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538768123", "createdAt": "2020-12-08T20:03:19Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDMxOA==", "bodyText": "Then set this.reinitializationFuture to null ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538770318", "createdAt": "2020-12-08T20:07:08Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger;\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+        logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);\n+            }\n+\n+            if (isInitialized()) {\n+                // persist new configuration and reinitialize handler\n+                dispose();\n+                updateConfiguration(configuration);\n+                initialize();\n+            } else {\n+                // persist new configuration and notify Thing Manager\n+                updateConfiguration(configuration);\n+                @Nullable\n+                ThingHandlerCallback callback = getCallback();\n+                if (callback != null) {\n+                    callback.configurationUpdated(this.getThing());\n+                } else {\n+                    logger.warn(\n+                            \"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                            this.getClass().getSimpleName());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return api client instance\n+     */\n+    public HomeConnectApiClient getApiClient() {\n+        return apiClient;\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return event source client instance\n+     */\n+    public HomeConnectEventSourceClient getEventSourceClient() {\n+        return eventSourceClient;\n+    }\n+\n+    /**\n+     * Get children of bridge\n+     *\n+     * @return list of child handlers\n+     */\n+    public List<AbstractHomeConnectThingHandler> getThingHandler() {\n+        return getThing().getThings().stream()\n+                .filter(thing -> thing.getHandler() instanceof AbstractHomeConnectThingHandler)\n+                .map(thing -> (AbstractHomeConnectThingHandler) thing.getHandler()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Get {@link ApiBridgeConfiguration}.\n+     *\n+     * @return bridge configuration (clientId, clientSecret, etc.)\n+     */\n+    public ApiBridgeConfiguration getConfiguration() {\n+        return getConfigAs(ApiBridgeConfiguration.class);\n+    }\n+\n+    /**\n+     * Get {@link OAuthClientService} instance.\n+     *\n+     * @return oAuth client service instance\n+     */\n+    public OAuthClientService getOAuthClientService() {\n+        return oAuthClientService;\n+    }\n+\n+    private void cleanup() {\n+        ArrayList<ApiRequest> apiRequestHistory = new ArrayList<>();\n+        apiRequestHistory.addAll(apiClient.getLatestApiRequests());\n+        this.apiRequestHistory = apiRequestHistory;\n+        apiClient.getLatestApiRequests().clear();\n+\n+        ArrayList<Event> eventHistory = new ArrayList<>();\n+        eventHistory.addAll(eventSourceClient.getLatestEvents());\n+        this.eventHistory = eventHistory;\n+        eventSourceClient.getLatestEvents().clear();\n+        eventSourceClient.dispose();\n+\n+        oAuthFactory.ungetOAuthService(oAuthServiceHandleId);\n+        homeConnectServlet.removeBridgeHandler(this);\n+    }\n+\n+    private synchronized void scheduleReinitialize() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null && !reinitializationFuture.isDone()) {\n+            logger.debug(\"Reinitialization is already scheduled. Starting in {} seconds. bridge={}\",\n+                    reinitializationFuture.getDelay(TimeUnit.SECONDS), getThing().getLabel());\n+        } else {\n+            this.reinitializationFuture = scheduler.schedule(() -> {\n+                cleanup();\n+                initialize();\n+            }, HomeConnectBridgeHandler.REINITIALIZATION_DELAY, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private synchronized void stopReinitializer() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjQwNA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772404", "createdAt": "2020-12-08T20:10:37Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MjgxNg==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772816", "createdAt": "2020-12-08T20:11:22Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Mjg5Mw==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538772893", "createdAt": "2020-12-08T20:11:28Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzIxOA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773218", "createdAt": "2020-12-08T20:11:56Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_DRIP_TRAY_FULL,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE));\n+        handlers.put(EVENT_COFFEEMAKER_WATER_TANK_EMPTY,\n+                defaultEventPresentStateEventHandler(CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+\n+        // register coffee maker specific SSE event handlers\n+        handlers.put(EVENT_PROGRAM_PROGRESS, event -> {\n+            if (event.getValue() == null || event.getValueAsInt() == 0) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            } else {\n+                defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE).handle(event);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCoffeeMakerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MzM2Mw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538773363", "createdAt": "2020-12-08T20:12:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+\n+        // specific SSE event handlers\n+        handlers.put(EVENT_ACTIVE_PROGRAM, (event) -> {\n+            defaultActiveProgramEventHandler().handle(event);\n+            if (event.getValue() != null) {\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent((c) -> updateChannel(c.getUID()));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectCooktopHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDI3OA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774278", "createdAt": "2020-12-08T20:13:47Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDMzNg==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774336", "createdAt": "2020-12-08T20:13:53Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDUxMA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774510", "createdAt": "2020-12-08T20:14:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(client -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            client.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            client.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    } else if (command instanceof QuantityType\n+                            && CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        int value = ((QuantityType<?>) command).intValue();\n+                        if (value < 10) {\n+                            value = 10;\n+                        } else if (value > 100) {\n+                            value = 100;\n+                        }\n+                        client.setAmbientLightBrightnessState(getThingHaId(), value);\n+                    } else if (command instanceof StringType\n+                            && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        client.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    } else if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = client.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            client.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = client.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            client.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            client.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                            command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDishwasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDg0OQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538774849", "createdAt": "2020-12-08T20:14:46Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTA0MQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775041", "createdAt": "2020-12-08T20:15:07Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }\n+                    });\n+                }\n+            } else {\n+                logger.debug(\"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                        command, operationState, getThingLabel(), getThingHaId());\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTE4OA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775188", "createdAt": "2020-12-08T20:15:19Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI1NQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775255", "createdAt": "2020-12-08T20:15:26Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTI5Nw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775297", "createdAt": "2020-12-08T20:15:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTM5Nw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775397", "createdAt": "2020-12-08T20:15:42Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ1MA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775450", "createdAt": "2020-12-08T20:15:49Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTQ5Mw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775493", "createdAt": "2020-12-08T20:15:55Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTU2Nw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775567", "createdAt": "2020-12-08T20:16:02Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NTYzNA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538775634", "createdAt": "2020-12-08T20:16:09Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjE3NA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776174", "createdAt": "2020-12-08T20:16:54Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjIyOA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776228", "createdAt": "2020-12-08T20:17:01Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjMyOA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776328", "createdAt": "2020-12-08T20:17:11Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjQxNw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776417", "createdAt": "2020-12-08T20:17:17Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njc1MA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776750", "createdAt": "2020-12-08T20:17:47Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void updateSelectedProgramStateDescription() {\n+        // update hood program actions\n+        if (isBridgeOffline() || !isThingAccessibleViaServerSentEvents()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId()).forEach(availableProgram -> {\n+                    if (PROGRAM_HOOD_AUTOMATIC.equals(availableProgram.getKey())) {\n+                        stateOptions.add(new StateOption(COMMAND_AUTOMATIC, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_DELAYED_SHUT_OFF.equals(availableProgram.getKey())) {\n+                        stateOptions.add(\n+                                new StateOption(COMMAND_DELAYED_SHUT_OFF, mapStringType(availableProgram.getKey())));\n+                    } else if (PROGRAM_HOOD_VENTING.equals(availableProgram.getKey())) {\n+                        try {\n+                            apiClient.get().getProgramOptions(getThingHaId(), PROGRAM_HOOD_VENTING).forEach(option -> {\n+                                if (OPTION_HOOD_VENTING_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream().filter(s -> !STAGE_FAN_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                } else if (OPTION_HOOD_INTENSIVE_LEVEL.equalsIgnoreCase(option.getKey())) {\n+                                    option.getAllowedValues().stream()\n+                                            .filter(s -> !STAGE_INTENSIVE_STAGE_OFF.equalsIgnoreCase(s))\n+                                            .forEach(s -> stateOptions.add(createVentingStateOption(s)));\n+                                }\n+                            });\n+                        } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                            logger.warn(\"Could not fetch hood program options. error={}\", e.getMessage());\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_01));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_02));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_03));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_04));\n+                            stateOptions.add(createVentingStateOption(STAGE_FAN_STAGE_05));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_1));\n+                            stateOptions.add(createVentingStateOption(STAGE_INTENSIVE_STAGE_2));\n+                        }\n+                    }\n+                });\n+                stateOptions.add(new StateOption(COMMAND_STOP, \"Stop\"));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_HOOD_ACTIONS_STATE)\n+                            .ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                                    .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    @Override\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_HOOD_ACTIONS_STATE).ifPresent(channel -> getDynamicStateDescriptionProvider()\n+                .removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectHoodHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Njk4Ng==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538776986", "createdAt": "2020-12-08T20:18:11Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzE1Mg==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777152", "createdAt": "2020-12-08T20:18:30Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NzUwMw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777503", "createdAt": "2020-12-08T20:19:01Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        @Nullable\n+        ScheduledFuture<?> cavityTemperatureFuture = this.cavityTemperatureFuture;\n+        if (cavityTemperatureFuture != null) {\n+            cavityTemperatureFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectOvenHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE)\n+                .ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3Nzc2OA==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538777768", "createdAt": "2020-12-08T20:19:23Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherDryerHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODEwMQ==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778101", "createdAt": "2020-12-08T20:19:50Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODQzMw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778433", "createdAt": "2020-12-08T20:20:12Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HomeConnectWasherHandler [haId: \" + getThingHaId() + \"]\";\n+    }\n+\n+    @Override\n+    protected void resetProgramStateChannels() {\n+        super.resetProgramStateChannels();\n+        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODY4MQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778681", "createdAt": "2020-12-08T20:20:36Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3ODczNQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538778735", "createdAt": "2020-12-08T20:20:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_2_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+                } else {\n+                    logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\", command,\n+                            operationState, getThingHaId());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTA3MA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779070", "createdAt": "2020-12-08T20:21:18Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTE0Nw==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779147", "createdAt": "2020-12-08T20:21:24Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTQ3Mw==", "bodyText": "UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779473", "createdAt": "2020-12-08T20:21:54Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger;\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.NULL : new StringType(event.getValue()))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTY5Ng==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779696", "createdAt": "2020-12-08T20:22:15Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3OTc2NA==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538779764", "createdAt": "2020-12-08T20:22:22Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger;\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.NULL));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDM2OQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780369", "createdAt": "2020-12-08T20:23:22Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.warn(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDQwMw==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780403", "createdAt": "2020-12-08T20:23:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final static String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final static String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger;\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+        resetProgramStateChannels();\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    } else {\n+                        return UnDefType.NULL;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.NULL);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                            if (!ambientLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setAmbientLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setAmbientLightBrightnessState(getThingHaId(), value);\n+                        }\n+                    }\n+\n+                    // ambient light color state\n+                    if (command instanceof StringType && CHANNEL_AMBIENT_LIGHT_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        apiClient.setAmbientLightColorState(getThingHaId(), command.toFullString());\n+                    }\n+\n+                    // ambient light custom color state\n+                    if (CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE.equals(channelUID.getId())) {\n+                        Data ambientLightState = apiClient.getAmbientLightState(getThingHaId());\n+                        if (!ambientLightState.getValueAsBoolean()) {\n+                            // turn on\n+                            apiClient.setAmbientLightState(getThingHaId(), true);\n+                        }\n+                        Data ambientLightColorState = apiClient.getAmbientLightColorState(getThingHaId());\n+                        if (!STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR.equals(ambientLightColorState.getValue())) {\n+                            // set color to custom color\n+                            apiClient.setAmbientLightColorState(getThingHaId(), STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR);\n+                        }\n+\n+                        if (command instanceof HSBType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), mapColor((HSBType) command));\n+                        } else if (command instanceof StringType) {\n+                            apiClient.setAmbientLightCustomColorState(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+\n+                    // program options\n+                    if (command instanceof StringType && CHANNEL_HOOD_ACTIONS_STATE.equals(channelUID.getId())) {\n+                        @Nullable\n+                        String operationState = getOperationState();\n+                        if (OPERATION_STATE_INACTIVE.equals(operationState)\n+                                || OPERATION_STATE_RUN.equals(operationState)) {\n+                            if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                                apiClient.stopProgram(getThingHaId());\n+                            }\n+                        } else {\n+                            logger.debug(\n+                                    \"Device can not handle command {} in current operation state ({}). thing={}, haId={}\",\n+                                    command, operationState, getThingLabel(), getThingHaId());\n+                        }\n+\n+                        // These command always start the hood - even if appliance is turned off\n+                        if (COMMAND_AUTOMATIC.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_AUTOMATIC);\n+                        } else if (COMMAND_DELAYED_SHUT_OFF.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startProgram(getThingHaId(), PROGRAM_HOOD_DELAYED_SHUT_OFF);\n+                        } else if (COMMAND_VENTING_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_01));\n+                        } else if (COMMAND_VENTING_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_02));\n+                        } else if (COMMAND_VENTING_3.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_03));\n+                        } else if (COMMAND_VENTING_4.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_04));\n+                        } else if (COMMAND_VENTING_5.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_STAGE_PAYLOAD_TEMPLATE, STAGE_FAN_STAGE_05));\n+                        } else if (COMMAND_VENTING_INTENSIVE_1.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_1));\n+                        } else if (COMMAND_VENTING_INTENSIVE_2.equalsIgnoreCase(command.toFullString())) {\n+                            apiClient.startCustomProgram(getThingHaId(),\n+                                    format(START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE, STAGE_INTENSIVE_STAGE_2));\n+                        } else {\n+                            logger.info(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                    getThingHaId());\n+                            apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                        }\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.warn(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc4MDgzMQ==", "bodyText": "DEBUG level", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r538780831", "createdAt": "2020-12-08T20:24:07Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger;\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cachePutIfAbsentAndGet(channelUID, cache, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.NULL;\n+                        }\n+                    }\n+                    return UnDefType.NULL;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }\n+\n+                    logger.debug(\"Set setpoint temperature to {} {}. thing={}, haId={}\", value, unit, getThingLabel(),\n+                            getThingHaId());\n+\n+                    if (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSetpointTemperature(getThingHaId(), value, unit);\n+                    } else if (CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSetpointTemperature(getThingHaId(), value, unit);\n+                    }\n+\n+                } else if (command instanceof OnOffType && apiClient.isPresent()) {\n+                    if (CHANNEL_FREEZER_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFreezerSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    } else if (CHANNEL_REFRIGERATOR_SUPER_MODE.equals(channelUID.getId())) {\n+                        apiClient.get().setFridgeSuperMode(getThingHaId(), OnOffType.ON.equals(command));\n+                    }\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                        command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                handleAuthenticationError(e);\n+            } catch (IncommensurableException | UnconvertibleException e) {\n+                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(), e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwMDAwMjIy", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-550000222", "createdAt": "2020-12-11T11:01:32Z", "commit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowMTozM1rOIDz2Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTozODowOFrOID1EqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NjEwMg==", "bodyText": "Use the implicit last argument to the logging functions to log exceptions:\nlogger.error(\"Could not parse event! haId={}\", haId, e);\n(Valid verywhere `e.getMessage() is passed to a logging method)", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540866102", "createdAt": "2020-12-11T11:01:33Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.EVENT;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.NOTIFY;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.STATUS;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.valueOfType;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSourceListener;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener extends EventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger;\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final Queue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            Queue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+        logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    @Override\n+    public void onOpen(@Nullable EventSource eventSource, @Nullable Response response) {\n+        logger.debug(\"Event source listener channel opened ({}).\", haId);\n+    }\n+\n+    @Override\n+    public void onEvent(@Nullable EventSource eventSource, @Nullable String id, @Nullable String type,\n+            @Nullable String data) {\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    @Override\n+    public void onClosed(@Nullable EventSource eventSource) {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    @Override\n+    public void onFailure(@Nullable EventSource eventSource, @Nullable Throwable throwable,\n+            @Nullable Response response) {\n+        @Nullable\n+        String throwableMessage = throwable != null ? throwable.getMessage() : null;\n+        @Nullable\n+        String throwableClass = throwable != null ? throwable.getClass().getName() : null;\n+        @Nullable\n+        String responseCode = response != null ? String.valueOf(response.code()) : null;\n+\n+        String responseBody = \"\";\n+        try {\n+            if (response != null) {\n+                @Nullable\n+                ResponseBody responseBodyObject = response.body();\n+                if (responseBodyObject != null) {\n+                    responseBody = responseBodyObject.string();\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"Could not get HTTP response body as string.\", e);\n+        }\n+\n+        logger.debug(\n+                \"Event source listener connection failure occurred. haId={}, responseCode={}, responseBody={}, throwable={}, throwableMessage={}\",\n+                haId, responseCode, responseBody, throwableClass, throwableMessage);\n+\n+        if (response != null) {\n+            response.close();\n+        }\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (\"429\".equals(responseCode)) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                eventListener.onClosed();\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    private ScheduledFuture<?> createMonitor(ScheduledExecutorService scheduler) {\n+        return scheduler.scheduleWithFixedDelay(() -> {\n+            logger.trace(\"Check event source connection ({}). Last event package received at {}.\", haId,\n+                    lastEventReceived);\n+            if (lastEventReceived != null\n+                    && ChronoUnit.MINUTES.between(lastEventReceived, now()) > SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT) {\n+                logger.warn(\"Dead event source connection detected ({}).\", haId);\n+\n+                client.unregisterEventListener(eventListener);\n+\n+                try {\n+                    eventListener.onClosed();\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+                }\n+                stopMonitor();\n+            }\n+        }, SSE_MONITOR_INITIAL_DELAY, SSE_MONITOR_INTERVAL, TimeUnit.MINUTES);\n+    }\n+\n+    private void stopMonitor() {\n+        logger.debug(\"Dispose event source connection monitor of appliance ({}).\", haId);\n+        eventSourceMonitorFuture.cancel(true);\n+    }\n+\n+    private List<Event> mapEventSourceEventToEvent(String haId, EventType type, @Nullable String data) {\n+        List<Event> events = new ArrayList<>();\n+\n+        if ((STATUS.equals(type) || EVENT.equals(type) || NOTIFY.equals(type)) && data != null && !isEmpty(data)\n+                && !EMPTY_DATA.equals(data)) {\n+            try {\n+                JsonObject responseObject = jsonParser.parse(data).getAsJsonObject();\n+                JsonArray items = responseObject.getAsJsonArray(\"items\");\n+\n+                items.forEach(item -> {\n+                    JsonObject obj = (JsonObject) item;\n+                    @Nullable\n+                    String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                    @Nullable\n+                    String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull()\n+                            ? obj.get(\"value\").getAsString()\n+                            : null;\n+                    @Nullable\n+                    String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+                    @Nullable\n+                    String name = obj.get(\"name\") != null ? obj.get(\"name\").getAsString() : null;\n+                    @Nullable\n+                    String uri = obj.get(\"uri\") != null ? obj.get(\"uri\").getAsString() : null;\n+                    @Nullable\n+                    EventLevel level = obj.get(\"level\") != null\n+                            ? EventLevel.valueOfLevel(obj.get(\"level\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    EventHandling handling = obj.get(\"handling\") != null\n+                            ? EventHandling.valueOfHandling(obj.get(\"handling\").getAsString())\n+                            : null;\n+                    @Nullable\n+                    Long timestamp = obj.get(\"timestamp\") != null ? obj.get(\"timestamp\").getAsLong() : null;\n+                    @Nullable\n+                    ZonedDateTime creation = timestamp != null\n+                            ? ZonedDateTime.ofInstant(Instant.ofEpochSecond(timestamp),\n+                                    TimeZone.getDefault().toZoneId())\n+                            : null;\n+\n+                    events.add(new Event(haId, type, key, name, uri, creation, level, handling, value, unit));\n+                });\n+            } catch (IllegalStateException e) {\n+                logger.error(\"Could not parse event! haId={}, error={}\", haId, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzEzMA==", "bodyText": "Is this meant to stay this way?\nIt shouldn't.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540867130", "createdAt": "2020-12-11T11:03:16Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/OkHttpHelper.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_HOST;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HTTP_PROXY_PORT;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.ProxySetupException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+import okhttp3.OkHttpClient;\n+import okhttp3.OkHttpClient.Builder;\n+import okhttp3.Request;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class OkHttpHelper {\n+    private static final String HEADER_AUTHORIZATION = \"Authorization\";\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(OkHttpHelper.class);\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1))).withInitialTokens(0)).build();\n+\n+    public static Builder builder(boolean enableRateLimiting) {\n+        Builder builder;\n+        if (HTTP_PROXY_ENABLED) {\n+            LOGGER.warn(\"Using http proxy! {}:{}\", HTTP_PROXY_HOST, HTTP_PROXY_PORT);\n+            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(HTTP_PROXY_HOST, HTTP_PROXY_PORT));\n+\n+            try {\n+                TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2ODYyOQ==", "bodyText": "Is the timezone information useful here?\nShould be java.time.Instant in my opinion.\n(Same  goes for all usages of ZonedDateTime", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540868629", "createdAt": "2020-12-11T11:05:49Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/ApiRequest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.time.ZonedDateTime;\n+import java.util.UUID;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * API request model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class ApiRequest {\n+    private final String id;\n+    private final ZonedDateTime time;\n+    private final HomeConnectRequest homeConnectRequest;\n+    private final @Nullable HomeConnectResponse homeConnectResponse;\n+\n+    public ApiRequest(ZonedDateTime time, HomeConnectRequest homeConnectRequest,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA==", "bodyText": "Could be a java.time.Instant", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540869444", "createdAt": "2020-12-11T11:07:12Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Date;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Token model\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Token {\n+\n+    private final String accessToken;\n+    private final String refreshToken;\n+    private final long accessTokenExpiration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MDIxOA==", "bodyText": "You can directly assign the logger here.\nIt will remove the requirement to add it to all constructors and clutter those.\nprivate final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540870218", "createdAt": "2020-12-11T11:08:34Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MTA2OQ==", "bodyText": "Should be a java.time.Duration to have proper typing.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540871069", "createdAt": "2020-12-11T11:09:58Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3MjM5NA==", "bodyText": "java.time API would be better, not that it would make a lot of difference here.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540872394", "createdAt": "2020-12-11T11:12:10Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {\n+            logger.error(\"Exception during scan.\", e);\n+        }\n+        logger.debug(\"Finished device scan.\");\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(new Date().getTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg3NzMyNw==", "bodyText": "Why not ISO8601?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540877327", "createdAt": "2020-12-11T11:21:22Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NDM4NA==", "bodyText": "Doesn't seem to do much.\nIt would make more sense to get the proxy configuration from where the rest of OpenHab also get its from, so all components behave uniformly.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540884384", "createdAt": "2020-12-11T11:34:49Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String EVENT_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String EVENT_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String EVENT_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+    public static final String EVENT_FRIDGE_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = \"Cooking.Common.Setting.Lighting\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // List of state values\n+    public static final String STATE_POWER_OFF = \"BSH.Common.EnumType.PowerState.Off\";\n+    public static final String STATE_POWER_ON = \"BSH.Common.EnumType.PowerState.On\";\n+    public static final String STATE_POWER_STANDBY = \"BSH.Common.EnumType.PowerState.Standby\";\n+    public static final String STATE_DOOR_OPEN = \"BSH.Common.EnumType.DoorState.Open\";\n+    public static final String STATE_DOOR_LOCKED = \"BSH.Common.EnumType.DoorState.Locked\";\n+    public static final String STATE_DOOR_CLOSED = \"BSH.Common.EnumType.DoorState.Closed\";\n+    public static final String STATE_OPERATION_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String STATE_OPERATION_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String STATE_OPERATION_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String STATE_EVENT_PRESENT_STATE_OFF = \"BSH.Common.EnumType.EventPresentState.Off\";\n+\n+    // List of program options\n+    public static final String OPTION_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String OPTION_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String OPTION_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String OPTION_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String OPTION_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String OPTION_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String OPTION_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String OPTION_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String OPTION_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String OPTION_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String OPTION_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String OPTION_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+\n+    // List of stages\n+    public static final String STAGE_FAN_OFF = \"Cooking.Hood.EnumType.Stage.FanOff\";\n+    public static final String STAGE_FAN_STAGE_01 = \"Cooking.Hood.EnumType.Stage.FanStage01\";\n+    public static final String STAGE_FAN_STAGE_02 = \"Cooking.Hood.EnumType.Stage.FanStage02\";\n+    public static final String STAGE_FAN_STAGE_03 = \"Cooking.Hood.EnumType.Stage.FanStage03\";\n+    public static final String STAGE_FAN_STAGE_04 = \"Cooking.Hood.EnumType.Stage.FanStage04\";\n+    public static final String STAGE_FAN_STAGE_05 = \"Cooking.Hood.EnumType.Stage.FanStage05\";\n+    public static final String STAGE_INTENSIVE_STAGE_OFF = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStageOff\";\n+    public static final String STAGE_INTENSIVE_STAGE_1 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1\";\n+    public static final String STAGE_INTENSIVE_STAGE_2 = \"Cooking.Hood.EnumType.IntensiveStage.IntensiveStage2\";\n+    public static final String STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR = \"BSH.Common.EnumType.AmbientLightColor.CustomColor\";\n+\n+    // List of programs\n+    public static final String PROGRAM_HOOD_AUTOMATIC = \"Cooking.Common.Program.Hood.Automatic\";\n+    public static final String PROGRAM_HOOD_VENTING = \"Cooking.Common.Program.Hood.Venting\";\n+    public static final String PROGRAM_HOOD_DELAYED_SHUT_OFF = \"Cooking.Common.Program.Hood.DelayedShutOff\";\n+\n+    // Network and oAuth constants\n+    public static final String API_BASE_URL = \"https://api.home-connect.com\";\n+    public static final String API_SIMULATOR_BASE_URL = \"https://simulator.home-connect.com\";\n+    public static final String OAUTH_TOKEN_PATH = \"/security/oauth/token\";\n+    public static final String OAUTH_AUTHORIZE_PATH = \"/security/oauth/authorize\";\n+    public static final String OAUTH_SCOPE = \"IdentifyAppliance Monitor Settings Dishwasher-Control Washer-Control Dryer-Control WasherDryer-Control CoffeeMaker-Control Hood-Control CleaningRobot-Control\";\n+\n+    // Operation states\n+    public static final String OPERATION_STATE_INACTIVE = \"BSH.Common.EnumType.OperationState.Inactive\";\n+    public static final String OPERATION_STATE_READY = \"BSH.Common.EnumType.OperationState.Ready\";\n+    public static final String OPERATION_STATE_DELAYED_START = \"BSH.Common.EnumType.OperationState.DelayedStart\";\n+    public static final String OPERATION_STATE_RUN = \"BSH.Common.EnumType.OperationState.Run\";\n+    public static final String OPERATION_STATE_PAUSE = \"BSH.Common.EnumType.OperationState.Pause\";\n+    public static final String OPERATION_STATE_ACTION_REQUIRED = \"BSH.Common.EnumType.OperationState.ActionRequired\";\n+    public static final String OPERATION_STATE_FINISHED = \"BSH.Common.EnumType.OperationState.Finished\";\n+    public static final String OPERATION_STATE_ERROR = \"BSH.Common.EnumType.OperationState.Error\";\n+    public static final String OPERATION_STATE_ABORTING = \"BSH.Common.EnumType.OperationState.Aborting\";\n+\n+    // Commands\n+    public static final String COMMAND_START = \"start\";\n+    public static final String COMMAND_STOP = \"stop\";\n+    public static final String COMMAND_SELECTED = \"selected\";\n+    public static final String COMMAND_VENTING_1 = \"venting1\";\n+    public static final String COMMAND_VENTING_2 = \"venting2\";\n+    public static final String COMMAND_VENTING_3 = \"venting3\";\n+    public static final String COMMAND_VENTING_4 = \"venting4\";\n+    public static final String COMMAND_VENTING_5 = \"venting5\";\n+    public static final String COMMAND_VENTING_INTENSIVE_1 = \"ventingIntensive1\";\n+    public static final String COMMAND_VENTING_INTENSIVE_2 = \"ventingIntensive2\";\n+    public static final String COMMAND_AUTOMATIC = \"automatic\";\n+    public static final String COMMAND_DELAYED_SHUT_OFF = \"delayed\";\n+\n+    // proxy settings\n+    public static final boolean HTTP_PROXY_ENABLED = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NTgzOQ==", "bodyText": "I would prefer to have the URL handling at the very outset of the binding and use full URI/Strings throught the plumbing.\nThis would also make it possible for users to specify their own URLs for testing etc.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540885839", "createdAt": "2020-12-11T11:37:26Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4NjE4NA==", "bodyText": "Now that OpenHab depends on Java 11, the new Java 11 HTTP client could be used, slashing the size of the binding considerably.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r540886184", "createdAt": "2020-12-11T11:38:08Z", "author": {"login": "t-8ch"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.collections4.QueueUtils;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger;\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final Queue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/366b0044e000f523d11023f78481aeddc77cc058", "committedDate": "2020-11-30T18:55:56Z", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}, "afterCommit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "committedDate": "2020-12-20T16:38:20Z", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4NDY1MDc1", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-558465075", "createdAt": "2020-12-24T11:09:48Z", "commit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMTowOTo0OVrOILFicA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxMTozNzowOVrOILF_WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ5NTk4NA==", "bodyText": "Just for consistency, please use api_bridge1 as bridge id here and in your channel links.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548495984", "createdAt": "2020-12-24T11:09:49Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,310 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Setup and save thing\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.\n+6. Please follow the steps shown to authenticate your binding. You can redo this step every time. For example if you have authentication problems, just start wizard again.  \n+![Screenshot Home Connect wizard page 1](doc/homeconnect_setup_1.png \"Screenshot Home Connect wizard page 1\")  \n+![Screenshot Home Connect wizard page 2](doc/homeconnect_setup_2.png \"Screenshot Home Connect wizard page 2\")  \n+![Screenshot Home Connect wizard page 3](doc/homeconnect_setup_3.png \"Screenshot Home Connect wizard page 3\")  \n+![Screenshot Home Connect wizard page 4](doc/homeconnect_setup_4.png \"Screenshot Home Connect wizard page 4\")  \n+\n+7. That's it! Now you can use autodiscovery to add devices. Your devices should show up if you start a device scan in the openHAB UI.\n+\n+\n+\n+## Examples: File based configuration\n+\n+If you prefer to configure everything via file instead of openHAB UI, here are some examples.\n+\n+### things/homeconnect.things\n+\n+```\n+Bridge homeconnect:api_bridge:api_bridge1 \"Home Connect API\" [ clientId=\"1234\", clientSecret=\"1234\", simulator=false] {\n+    // Thing configurations\n+    Thing dishwasher dishwasher1 \"Dishwasher\"  [ haId=\"SIEMENS-HCS02DWH1-6F2FC400C1EA4A\" ]\n+    Thing washer washer1 \"Washer\"  [ haId=\"SIEMENS-HCS03WCH1-1F35EC2BE34A0F\" ]\n+    Thing fridgefreezer fridge1 \"Fridge Freezer  [ haId=\"SIEMENS-HCS05FRF1-7B3FA5EB3D885B\" ]\n+    Thing oven oven1 \"Oven\"  [ haId=\"BOSCH-HCS01OVN1-2132B6FA25BA21\" ]\n+    Thing dryer dryer1 \"Dryer\"  [ haId=\"BOSCH-HCS04DYR1-3921C766AD5BAF\" ]\n+    Thing coffeemaker coffee1 \"Coffee machine\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing washerdryer washerdryer1 \"Washerdryer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing fridgefreezer fridgefreezer1 \"Fridge/Freezer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hood hood1 \"Hood\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hob hob1 \"Hob\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+}\n+```\n+\n+### items/homeconnect.items\n+\n+The channel parameter uses the following syntax: `homeconnect:<thing type id>:<bridge id>:<thing id>:<channel type id>`. For example: `homeconnect:dishwasher:simulator_api_bridge:dishwasher1:power_state`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMDc4MQ==", "bodyText": "I am surprised the class is empty. Normally, there is a method to get the state options + the handling of the reference to ChannelTypeI18nLocalizationService .", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548500781", "createdAt": "2020-12-24T11:26:58Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/type/HomeConnectDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.type;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.binding.BaseDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.type.DynamicStateDescriptionProvider;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link HomeConnectDynamicStateDescriptionProvider} is responsible for handling dynamic values.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, HomeConnectDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class HomeConnectDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMjIyNg==", "bodyText": "Replace appliance.getHaId() by HA_ID. What is expected is the parameter name, not its value.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548502226", "createdAt": "2020-12-24T11:32:46Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties)\n+                            .withRepresentationProperty(appliance.getHaId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUwMzM4NQ==", "bodyText": "My understanding of this line is that you will get the HA_ID for each thing, but that's all. It will do nothing and looks as useless.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r548503385", "createdAt": "2020-12-24T11:37:09Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcwOTAwNQ=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 92}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c2874a646b9e7af0e5f8778d6dcf3670c0af4f13", "committedDate": "2020-12-20T16:38:20Z", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}, "afterCommit": {"oid": "b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b2bab267d8b772fc4a62951e9bc00f5d1e5e8cad", "committedDate": "2021-01-16T11:05:11Z", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "543b89c231cb2e234a88c4bc2d9eab79063c0666", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/543b89c231cb2e234a88c4bc2d9eab79063c0666", "committedDate": "2021-01-16T13:11:00Z", "message": "Applied review feedback and changed copy right label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas.bruestel@piobyte.de>"}, "afterCommit": {"oid": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "committedDate": "2021-01-16T13:15:27Z", "message": "Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/5a210b10c4c3cc3fec68ba4897ef982333d3f00a", "committedDate": "2021-01-16T13:15:27Z", "message": "Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}, "afterCommit": {"oid": "979af11d1f80ae7c43b80407039a64f1675b8502", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/979af11d1f80ae7c43b80407039a64f1675b8502", "committedDate": "2021-01-16T13:38:47Z", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "979af11d1f80ae7c43b80407039a64f1675b8502", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/979af11d1f80ae7c43b80407039a64f1675b8502", "committedDate": "2021-01-16T13:38:47Z", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}, "afterCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/9747dacf2e2faa47e6bf8b2b7dc51bde9a659949", "committedDate": "2021-01-16T13:46:34Z", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5OTQ1MDU0", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-569945054", "createdAt": "2021-01-16T15:07:41Z", "commit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQxNTowNzo0MVrOIVBu8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQxODo1NjozMVrOIVG8eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODkxOTQxMA==", "bodyText": "Minor: please fix the comment as now the bridgeHandler is no more a parameter of the constructor.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558919410", "createdAt": "2021-01-16T15:07:41Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk3MjQ1Ng==", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558972456", "createdAt": "2021-01-16T17:26:19Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCoffeeMakerHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_DRIP_TRAY_FULL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_COFFEEMAKER_WATER_TANK_EMPTY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectCoffeeMakerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a coffee machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCoffeeMakerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectCoffeeMakerHandler.class);\n+\n+    public HomeConnectCoffeeMakerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MDEyMA==", "bodyText": "Is there a reason to not use the scheduler provided by the thing handler ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558980120", "createdAt": "2021-01-16T17:46:31Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTU4MA==", "bodyText": "It may be better to first cancel your job before calling super.dispose()", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558981580", "createdAt": "2021-01-16T17:49:50Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Time> quantity = ((QuantityType<Time>) command);\n+\n+                            try {\n+                                String value = String.valueOf(\n+                                        quantity.getUnit().getConverterToAny(SECOND).convert(quantity).intValue());\n+                                logger.debug(\"Set duration to {} seconds. haId={}\", value, getThingHaId());\n+\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_DURATION, value, \"seconds\", true,\n+                                        false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set duration! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+                    } else {\n+                        logger.debug(\"Device can not handle command {} in current operation state ({}). haId={}\",\n+                                command, operationState, getThingHaId());\n+                    }\n+                } catch (ApplianceOfflineException e) {\n+                    logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    updateStatus(OFFLINE);\n+                    resetChannelsOnOfflineEvent();\n+                    resetProgramStateChannels();\n+                } catch (CommunicationException e) {\n+                    logger.debug(\"Could not handle command {}. API communication problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                } catch (AuthorizationException e) {\n+                    logger.debug(\"Could not handle command {}. Authorization problem! thing={}, haId={}, error={}\",\n+                            command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                    handleAuthenticationError(e);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        cavityTemperatureFuture = scheduler.scheduleWithFixedDelay(() -> {\n+            @Nullable\n+            String operationState = getOperationState();\n+            boolean manuallyUpdateCavityTemperature = this.manuallyUpdateCavityTemperature;\n+\n+            if (STATE_OPERATION_RUN.equals(operationState)) {\n+                getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(c -> {\n+                    if (manuallyUpdateCavityTemperature) {\n+                        logger.debug(\"Update cavity temperature manually via API. haId={}\", getThingHaId());\n+                        updateChannel(c.getUID());\n+                    } else {\n+                        logger.debug(\"Update cavity temperature via SSE, don't need to fetch manually. haId={}\",\n+                                getThingHaId());\n+                    }\n+                });\n+            }\n+        }, CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY, CAVITY_TEMPERATURE_SCHEDULER_PERIOD, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4NjYwNg==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558986606", "createdAt": "2021-01-16T18:02:29Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+    private final ScheduledExecutorService scheduler;\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        scheduler = ThreadPoolManager.getScheduledPool(getClass().getSimpleName());\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set setpoint temperature\n+                        if (command instanceof QuantityType\n+                                && CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                                        || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                                    unit = quantity.getUnit().toString();\n+                                    value = String.valueOf(quantity.intValue());\n+                                } else {\n+                                    logger.debug(\n+                                            \"Converting target setpoint temperature from {}{} to \u00b0C value. haId={}\",\n+                                            quantity.intValue(), quantity.getUnit().toString(), getThingHaId());\n+                                    unit = \"\u00b0C\";\n+                                    value = String.valueOf(quantity.getUnit().getConverterToAny(SIUnits.CELSIUS)\n+                                            .convert(quantity).intValue());\n+                                    logger.debug(\"{}{}\", value, unit);\n+                                }\n+\n+                                logger.debug(\"Set setpoint temperature to {} {}. haId={}\", value, unit, getThingHaId());\n+                                apiClient.setProgramOptions(getThingHaId(), OPTION_SETPOINT_TEMPERATURE, value, unit,\n+                                        true, false);\n+                            } catch (IncommensurableException | UnconvertibleException e) {\n+                                logger.warn(\"Could not set setpoint! haId={}, error={}\", getThingHaId(),\n+                                        e.getMessage());\n+                            }\n+                        }\n+\n+                        // set duration\n+                        if (command instanceof QuantityType && CHANNEL_DURATION.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzg4Mw==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987883", "createdAt": "2021-01-16T18:05:43Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4Nzk0Mg==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558987942", "createdAt": "2021-01-16T18:05:48Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherDryerHandler.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washer dryer combined machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherDryerHandler.class);\n+\n+    public HomeConnectWasherDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // only handle these commands if operation state allows it\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                        // set temperature option\n+                        if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set spin speed option\n+                        if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                    command.toFullString(), null, false, false);\n+                        }\n+\n+                        // set drying target option\n+                        if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTAxMg==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989012", "createdAt": "2021-01-16T18:08:33Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTA3Ng==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989076", "createdAt": "2021-01-16T18:08:38Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTEwNQ==", "bodyText": "I rather suggest \"else if\" but I let you decide.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989105", "createdAt": "2021-01-16T18:08:44Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectWasherHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectWasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a washing machine.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectWasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectWasherHandler.class);\n+\n+    public HomeConnectWasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+\n+        // register washer specific handlers\n+        handlers.put(CHANNEL_WASHER_SPIN_SPEED, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_WASHER_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler()\n+                        .handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register washer specific event handlers\n+        handlers.put(EVENT_WASHER_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_WASHER_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_SPIN_SPEED,\n+                event -> getThingChannel(CHANNEL_WASHER_SPIN_SPEED).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_1_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS1).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+        handlers.put(EVENT_WASHER_IDOS_2_DOSING_LEVEL,\n+                event -> getThingChannel(CHANNEL_WASHER_IDOS2).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                // only handle these commands if operation state allows it\n+                if (operationState != null && INACTIVE_STATE.contains(operationState) && apiClient.isPresent()) {\n+                    // set temperature option\n+                    if (command instanceof StringType && CHANNEL_WASHER_TEMPERATURE.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_TEMPERATURE,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set spin speed option\n+                    if (command instanceof StringType && CHANNEL_WASHER_SPIN_SPEED.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_SPIN_SPEED,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 1 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS1.equals(channelUID.getId())) {\n+                        apiClient.get().setProgramOptions(getThingHaId(), OPTION_WASHER_IDOS_1_DOSING_LEVEL,\n+                                command.toFullString(), null, false, false);\n+                    }\n+\n+                    // set iDos 2 option\n+                    if (command instanceof StringType && CHANNEL_WASHER_IDOS2.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4OTkxNQ==", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558989915", "createdAt": "2021-01-16T18:11:21Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectCooktopHandler.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link HomeConnectCooktopHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectCooktopHandler extends AbstractHomeConnectThingHandler {\n+\n+    public HomeConnectCooktopHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDAyMg==", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990022", "createdAt": "2021-01-16T18:11:42Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDishwasherHandler.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDishwasherHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dishwasher.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDishwasherHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDishwasherHandler.class);\n+\n+    public HomeConnectDishwasherHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk5MDI2Mw==", "bodyText": "This will update the state of channels while the thing handler is even not yet initialized.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r558990263", "createdAt": "2021-01-16T18:12:32Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        resetProgramStateChannels();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg==", "bodyText": "If method is called while your thing (bridge) was not yet initialized, oAuthClientService will be null.\nIt would be safer to check that this variable is not null.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r559004792", "createdAt": "2021-01-16T18:56:31Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NzEyNjE5", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-576712619", "createdAt": "2021-01-26T19:59:29Z", "commit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQxOTo1OTozMFrOIaoTOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNlQyMTowNToxNVrOIaqnjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NDE2OQ==", "bodyText": "It looks like this class is not used.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564794169", "createdAt": "2021-01-26T19:59:30Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/exception/ProxySetupException.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * HTTP proxy setup exception\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ProxySetupException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5NTMxMw==", "bodyText": "Call to super() is useless I believe", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564795313", "createdAt": "2021-01-26T20:01:18Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/HomeConnectResponse.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * HTTP response model.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectResponse {\n+    private final int code;\n+    private final Map<String, String> header;\n+    private final @Nullable String body;\n+\n+    public HomeConnectResponse(int code, Map<String, String> header, @Nullable String body) {\n+        super();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5ODQzMA==", "bodyText": "Please don't use org.apache.commons.lang.StringUtils, we search to remove tthis dependency.\nThis can easily be replaced I believe.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564798430", "createdAt": "2021-01-26T20:06:30Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        String path = BASE_PATH + haId + \"/programs/available/\" + programKey;\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.code() == HTTP_OK) {\n+                return responseBody;\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(asList(HTTP_OK, HTTP_NOT_FOUND), request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.code() == HTTP_OK) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(ACCEPT, BSH_JSON_V1).delete()\n+                .build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createGetRequest(path);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        RequestBody requestBody = RequestBody.create(BSH_JSON_V1_MEDIA_TYPE,\n+                requestBodyPayload.getBytes(StandardCharsets.UTF_8));\n+\n+        Request request = requestBuilder(oAuthClientService).url(apiUrl + path).header(CONTENT_TYPE, BSH_JSON_V1)\n+                .header(ACCEPT, BSH_JSON_V1).put(requestBody).build();\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_NO_CONTENT, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, mapToString(response.body()));\n+        } catch (IOException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, Response response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, Response response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HTTP_UNAUTHORIZED) && response.code() == HTTP_UNAUTHORIZED) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.code())) {\n+            int code = response.code();\n+            String message = response.message();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = \"\";\n+            try {\n+                responseBody = mapToString(response.body());\n+            } catch (IOException e) {\n+                logger.error(\"Could not get HTTP response body as string.\", e);\n+            }\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            if (code == HTTP_CONFLICT && containsIgnoreCase(responseBody, \"error\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 936}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDc5OTc0MQ==", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils\nShould be easy here.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564799741", "createdAt": "2021-01-26T20:08:37Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgxMjIxNA==", "bodyText": "Please add the missing parameter haId", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564812214", "createdAt": "2021-01-26T20:30:09Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import okhttp3.Request;\n+import okhttp3.sse.EventSource;\n+import okhttp3.sse.EventSources;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final String ACCEPT = \"Accept\";\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final EventSource.Factory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, EventSource> eventSourceConnections;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(OAuthClientService oAuthClientService, boolean simulated,\n+            ScheduledExecutorService scheduler, @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceFactory = EventSources.createFactory(OkHttpHelper.builder(false)\n+                .readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).retryOnConnectionFailure(true).build());\n+        eventSourceConnections = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param eventListener appliance event listener", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDMwOQ==", "bodyText": "Please add the missing parameter unit", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820309", "createdAt": "2021-01-26T20:44:33Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgyMDYwMw==", "bodyText": "Please add the missing parameter unit", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564820603", "createdAt": "2021-01-26T20:45:06Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1137 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.net.HttpURLConnection.HTTP_CONFLICT;\n+import static java.net.HttpURLConnection.HTTP_NOT_FOUND;\n+import static java.net.HttpURLConnection.HTTP_NO_CONTENT;\n+import static java.net.HttpURLConnection.HTTP_OK;\n+import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang.StringUtils.containsIgnoreCase;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_AMBIENT_LIGHT_ENABLED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_LIGHTING_BRIGHTNESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.SETTING_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATUS_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.formatJsonBody;\n+import static org.openhab.binding.homeconnect.internal.client.OkHttpHelper.requestBuilder;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String ACCEPT = \"Accept\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final MediaType BSH_JSON_V1_MEDIA_TYPE = requireNonNull(MediaType.parse(BSH_JSON_V1));\n+    private static final int REQUEST_READ_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final OkHttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        client = OkHttpHelper.builder(true).readTimeout(REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).build();\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, null, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createGetRequest(BASE_PATH + haId);\n+        try (Response response = client.newCall(request).execute()) {\n+            checkResponseCode(HTTP_OK, request, response, haId, null);\n+\n+            String responseBody = mapToString(response.body());\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (IOException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMDAzMA==", "bodyText": "Please remove use of org.apache.commons.lang.StringUtils", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564830030", "createdAt": "2021-01-26T21:01:16Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDgzMjE0Mw==", "bodyText": "You need to try a second time ?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r564832143", "createdAt": "2021-01-26T21:05:15Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,628 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.apache.commons.lang.StringUtils.isEmpty;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1eb8165e67aa1a262cf44187224c4f151420c11"}, "originalPosition": 140}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ba3fdbfe06ec674a9ce3c7085f7ccfd949da1c8", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1ba3fdbfe06ec674a9ce3c7085f7ccfd949da1c8", "committedDate": "2021-03-02T15:48:09Z", "message": "Merge pull request #2 from lolodomo/homeconnect\n\n[homeconnect] Remove Okhttp dependency"}, "afterCommit": {"oid": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/77806786a7e91f9029fb1ba90a236d87ca371f7e", "committedDate": "2021-03-02T16:55:29Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "77806786a7e91f9029fb1ba90a236d87ca371f7e", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/77806786a7e91f9029fb1ba90a236d87ca371f7e", "committedDate": "2021-03-02T16:55:29Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "committedDate": "2021-03-02T16:59:18Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/edf810f3e5d4a4347400fb4f816127fa91ab7ff0", "committedDate": "2021-03-02T16:59:18Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "committedDate": "2021-03-02T17:06:32Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/4c38bba2d62ce4121ff8716afbf7d601b45c4f0b", "committedDate": "2021-03-02T17:06:32Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}, "afterCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/d87bf3c15b837ef0487e30f37e609e29f9aa438d", "committedDate": "2021-03-02T17:13:16Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMTEzNjMx", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-602113631", "createdAt": "2021-03-02T18:05:07Z", "commit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzAyMDcw", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-602302070", "createdAt": "2021-03-02T21:46:30Z", "commit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMTo0NjozMFrOIuygeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQyMjowNzowMlrOIuzOXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzMjkyMA==", "bodyText": "Is this still necessary?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585932920", "createdAt": "2021-03-02T21:46:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/NOTICE", "diffHunk": "@@ -0,0 +1,75 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab2-addons\n+\n+== Third-party Content\n+\n+Thymeleaf\n+* License: Apache License 2.0\n+* Project: https://www.thymeleaf.org/\n+* Source:  https://github.com/thymeleaf/thymeleaf\n+\n+Thymeleaf - Java 8 Time API compatibility\n+* License: Apache License 2.0\n+* Project: https://www.thymeleaf.org/\n+* Source:  https://github.com/thymeleaf/thymeleaf-extras-java8time", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzMzk0NQ==", "bodyText": "Does the first sentence make any sense? Can you mention the Thing Type ID?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585933945", "createdAt": "2021-03-02T21:48:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzNDkwOQ==", "bodyText": "Can you fix the formatting of the table? There are several online markdown table formatters on the net.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585934909", "createdAt": "2021-03-02T21:49:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzNzAzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n          \n          \n            \n            | program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance in percent. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker |", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585937039", "createdAt": "2021-03-02T21:53:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzODg4MQ==", "bodyText": "Why not making it Dimmer? Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585938881", "createdAt": "2021-03-02T21:56:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkzOTczOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n          \n          \n            \n            2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS)](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585939739", "createdAt": "2021-03-02T21:58:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTk0MDE2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n          \n          \n            \n            2. Please make sure you've added your associated Home Connect account email at <https://developer.home-connect.com/user/me/edit>. You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585940163", "createdAt": "2021-03-02T21:58:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTk0MTI0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.\n          \n          \n            \n            5. Now navigate to the URL (`Redirct URI`) you've added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585941245", "createdAt": "2021-03-02T22:00:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Setup and save thing\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTk0Mzc5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Home Connect API enforces rate [limits](https://developer.home-connect.com/docs/general/ratelimiting) . If you have a lot of `429` response codes in your request log section (http(s)://[YOUROPENHAB]:[YOURPORT]/log/requests), please check the error response.\n          \n          \n            \n            The Home Connect API enforces rate [limits](https://developer.home-connect.com/docs/general/ratelimiting). If you have a lot of `429` response codes in your request log section (http(s)://[YOUROPENHAB]:[YOURPORT]/log/requests), please check the error response.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585943799", "createdAt": "2021-03-02T22:05:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Setup and save thing\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.\n+6. Please follow the steps shown to authenticate your binding. You can redo this step every time. For example if you have authentication problems, just start wizard again.  \n+![Screenshot Home Connect wizard page 1](doc/homeconnect_setup_1.png \"Screenshot Home Connect wizard page 1\")  \n+![Screenshot Home Connect wizard page 2](doc/homeconnect_setup_2.png \"Screenshot Home Connect wizard page 2\")  \n+![Screenshot Home Connect wizard page 3](doc/homeconnect_setup_3.png \"Screenshot Home Connect wizard page 3\")  \n+![Screenshot Home Connect wizard page 4](doc/homeconnect_setup_4.png \"Screenshot Home Connect wizard page 4\")  \n+\n+7. That's it! Now you can use autodiscovery to add devices. Your devices should show up if you start a device scan in the openHAB UI.\n+\n+\n+\n+## Examples: File based configuration\n+\n+If you prefer to configure everything via file instead of openHAB UI, here are some examples.\n+\n+### things/homeconnect.things\n+\n+```\n+Bridge homeconnect:api_bridge:api_bridge_at_home \"Home Connect API\" [ clientId=\"1234\", clientSecret=\"1234\", simulator=false] {\n+    // Thing configurations\n+    Thing dishwasher dishwasher1 \"Dishwasher\"  [ haId=\"SIEMENS-HCS02DWH1-6F2FC400C1EA4A\" ]\n+    Thing washer washer1 \"Washer\"  [ haId=\"SIEMENS-HCS03WCH1-1F35EC2BE34A0F\" ]\n+    Thing fridgefreezer fridge1 \"Fridge Freezer  [ haId=\"SIEMENS-HCS05FRF1-7B3FA5EB3D885B\" ]\n+    Thing oven oven1 \"Oven\"  [ haId=\"BOSCH-HCS01OVN1-2132B6FA25BA21\" ]\n+    Thing dryer dryer1 \"Dryer\"  [ haId=\"BOSCH-HCS04DYR1-3921C766AD5BAF\" ]\n+    Thing coffeemaker coffee1 \"Coffee machine\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing washerdryer washerdryer1 \"Washerdryer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing fridgefreezer fridgefreezer1 \"Fridge/Freezer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hood hood1 \"Hood\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hob hob1 \"Hob\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+}\n+```\n+\n+### items/homeconnect.items\n+\n+The channel parameter uses the following syntax: `homeconnect:<thing type id>:<bridge id>:<thing id>:<channel type id>`. For example: `homeconnect:dishwasher:api_bridge_at_home:dishwasher1:power_state`\n+\n+```\n+// dishwasher\n+Switch                 Dishwasher_PowerState                  \"Power State\"                       {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:power_state\"}\n+Contact                Dishwasher_DoorState                   \"Door State\"                        {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:door_state\"}\n+String                 Dishwasher_OperationState              \"Operation State\"                   {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:operation_state\"}\n+Switch                 Dishwasher_RemoteStartAllowanceState   \"Remote Start Allowance State\"      {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remote_start_allowance_state\"}\n+Switch                 Dishwasher_RemoteControlActiveState    \"Remote Control Activation State\"   {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remote_control_active_state\"}\n+String                 Dishwasher_SelectedProgramState        \"Selected Program\"                  {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:selected_program_state\"}\n+String                 Dishwasher_ActiveProgramState          \"Active Program\"                    {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:active_program_state\"}\n+Number:Time            Dishwasher_RemainingProgramTimeState   \"Remaining program time\"            {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remaining_program_time_state\"}\n+Number:Dimensionless   Dishwasher_ProgramProgressState        \"Progress State\"                    {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:program_progress_state\"}\n+```\n+\n+## Home Connect Console\n+\n+The binding comes with a separate user interface, which is reachable through the web browser http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). \n+\n+Features:\n+\n+* overview of your bridges and appliances\n+* send commands to your appliances\n+* see latest API requests\n+* see received events from the Home Connect backend\n+* API request counts\n+\n+> **INFO**: If you have a problems with your installation, please always provide request and event exports. ![Screenshot Home Connect wizard page 4](doc/export_button.png \"Export button\")\n+\n+## How To\n+\n+### Notification on credential error\n+\n+To get notified when your Home Connect credentials have been revoked or expired you can use the following rule to get notified. \n+\n+This can happen if \n+\n+* your openHAB instance was offline for a longer period or\n+* new terms weren't accepted or\n+* a technical problem occurred.\n+\n+```java\n+rule \"Offline check - Home Connect bridge\"\n+when\n+    Thing \"<thingUID>\" changed\n+then\n+    val statusInfo = getThingStatusInfo(\"<thingUID>\")\n+    val status = statusInfo.getStatus()\n+    val statusDetail = statusInfo.getStatusDetail()\n+\n+    if ((status !== null) && (statusDetail !== null)) {\n+        logInfo(\"api_bridge\", \"Home Connect bridge status: \" + status.toString() + \" detail: \" + statusDetail.toString())\n+        if (status.toString() == 'OFFLINE' && statusDetail.toString() == 'CONFIGURATION_PENDING') {\n+            logError(\"api_bridge\", \"Home Connect bridge offline.\")\n+            // send push, email, ...\n+        }\n+    }\n+end\n+```\n+\n+### Start program with custom settings\n+\n+Currently, not all program options of a device are available as items in openHAB. For example, you cannot change the `Fill quantity` of a coffee maker program. If you wish to start a program with a custom setting, you can send a special command to the item of type `basic_actions_state`.\n+\n+> **INFO**: Only for advanced users. You need to know how to use the `curl` command. Alternatively you you can use the binding UI to trigger the commands.\n+\n+#### 1. Retrieve \"special command\" payload\n+\n+You have a couple options to get the program settings payload. \n+\n+a) You could have a look at the Home Connect developer documentation (https://developer.home-connect.com/docs/) and create the payload on your own. \n+\n+b) You could have a look at the request logs and extract the payload from there. \n+\n+1. On the physical device, select your desired program with the appropriate options.\n+2. Open the appliance section of the binding UI (http(s)://[YOUROPENHAB]:[YOURPORT]/appliances) and click the 'Selected Program' button.\n+![Screenshot Home Connect wizard page 4](doc/selected_program_1.png \"Get selected program\")\n+3. ![Screenshot Home Connect wizard page 4](doc/selected_program_2.png \"Get selected program\") Copy the JSON payload. In a further step, this payload will be used to start the program.\n+\n+\n+#### 2. Start program\n+\n+After you've extracted the desired program command, you can start your program via openHAB rule or through a `curl` command.\n+\n+##### in rule\n+\n+*Example rule:*\n+\n+```java\n+rule \"trigger program\"\n+when\n+    Time cron \"0 32 13 ? * * *\"\n+then\n+    homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state.sendCommand('{\"data\":{\"key\":\"ConsumerProducts.CoffeeMaker.Program.Beverage.EspressoMacchiato\",\"options\":[{\"key\":\"ConsumerProducts.CoffeeMaker.Option.CoffeeTemperature\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.CoffeeTemperature.94C\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.BeanAmount\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.BeanAmount.Mild\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.FillQuantity\",\"value\":60,\"unit\":\"ml\"}]}}')\n+end\n+```\n+\n+Please replace `homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state` with your item name (of channel type `basic_actions_state`).\n+\n+##### via curl\n+\n+*Example command:*\n+\n+```bash\n+curl -X POST --header \"Content-Type: text/plain\" --header \"Accept: application/json\" -d '{\"data\":{\"key\":\"ConsumerProducts.CoffeeMaker.Program.Beverage.EspressoMacchiato\",\"options\":[{\"key\":\"ConsumerProducts.CoffeeMaker.Option.CoffeeTemperature\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.CoffeeTemperature.94C\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.BeanAmount\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.BeanAmount.Mild\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.FillQuantity\",\"value\":60,\"unit\":\"ml\"}]}}' \"http://localhost:8080/rest/items/homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state\"\n+```\n+\n+Please replace `homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state` with your item name (of channel type `basic_actions_state`).\n+\n+## FAQ\n+\n+### I can't start my oven via openHAB.\n+\n+Some operations are not possible at the moment. You need to sign an \"Additional Partner Agreement\". Please have a look at:\n+https://developer.home-connect.com/docs/authorization/scope\n+\n+### I can't switch remote start to on.\n+\n+The channel of type `remote_start_allowance_state` is read only. You can only enable it directly on the physical appliance.\n+\n+### In case of error...\n+\n+Please check log UI (http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect) and ask for help in the community forum or on github. Please provide request and event exports.  \n+ ![Screenshot Home Connect wizard page 4](doc/export_button.png \"Export button\")\n+\n+### Rate limit reached\n+\n+The Home Connect API enforces rate [limits](https://developer.home-connect.com/docs/general/ratelimiting) . If you have a lot of `429` response codes in your request log section (http(s)://[YOUROPENHAB]:[YOURPORT]/log/requests), please check the error response.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTk0NDY2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            1. You can use the OpenHAB UI and start a scan. ![Screenshot OpenHAB UI Scan for new devices](doc/ui-scan-for-haid.png \"Scan\")\n          \n          \n            \n            1. You can use the openHAB UI and start a scan. ![Screenshot OpenHAB UI Scan for new devices](doc/ui-scan-for-haid.png \"Scan\")", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r585944669", "createdAt": "2021-03-02T22:07:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/README.md", "diffHunk": "@@ -0,0 +1,317 @@\n+# Home Connect Binding\n+\n+The binding integrates the [Home Connect](https://www.home-connect.com/) system into openHAB.\n+By using the Home Connect API it connects to household devices from brands like Bosch and Siemens. \n+\n+Because all status updates and commands have to go through the API, a permanent internet connection is required.\n+\n+## Supported Things\n+\n+### Bridge\n+\n+The __Home Connect API__ is responsible for the communication with the Home Connect API. All devices use a bridge to execute commands and listen for updates. Without a working bridge the devices cannot communicate.\n+\n+### Devices\n+\n+Supported devices: dishwasher, washer, washer / dryer combination, dryer, oven, refrigerator freezer, coffee machine, hood, cooktop*\n+\n+*\\* experimental support*\n+\n+| Home appliance | Thing Type ID    | \n+| --------------- | ------------ |\n+| Dishwasher | dishwasher | \n+| Washer | washer | \n+| Washer / Dryer combination | washerdryer | \n+| Dryer | dryer | \n+| Oven | oven | \n+| Hood | hood | \n+| Cooktop | hob | \n+| Refrigerator Freezer | fridgefreezer | \n+| Coffee Machine | coffeemaker | \n+\n+> **INFO**: Currently the Home Connect API does not support all appliance programs. Please check if your desired program is available (e.g. https://developer.home-connect.com/docs/washing-machine/supported_programs_and_options).\n+\n+\n+## Discovery\n+\n+After the bridge has been added and authorized, devices are discovered automatically.\n+\n+\n+## Channels\n+\n+| Channel Type ID | Item Type    | Read only | Description  | Available on thing |\n+| --------------- | ------------ | --------- | ------------ | ------------------ |\n+| power_state | Switch | false | This setting describes the current power state of the home appliance. | dishwasher, oven, coffeemaker, hood, hob  | \n+| door_state | Contact | true | This status describes the door state of a home appliance. A status change is either triggered by the user operating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking the door). | dishwasher, washer, washerdryer, dryer, oven, fridgefreezer | \n+| operation_state | String | true | This status describes the operation state of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker | \n+| remote_start_allowance_state | Switch | true  | This status indicates whether the remote program start is enabled. This can happen due to a programmatic change (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically after a certain duration - usually in 24 hours. | dishwasher, washer, washerdryer, dryer, oven, hood, coffeemaker | \n+| remote_control_active_state | Switch | true  | This status indicates whether the allowance for remote controlling is enabled. | dishwasher, washer, washerdryer, dryer, oven, hood, hob | \n+| active_program_state | String | true  | This status describes the active program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hood, hob, coffeemaker  | \n+| selected_program_state | String | false | This state describes the selected program of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, hob, coffeemaker | \n+| remaining_program_time_state | Number:Time | true | This status indicates the remaining program time of the home appliance. | dishwasher, washer, washerdryer, dryer, oven | \n+| elapsed_program_time | Number:Time | true | This status indicates the elapsed program time of the home appliance. | oven | \n+| program_progress_state | Number:Dimensionless | true | This status describes the program progress of the home appliance. | dishwasher, washer, washerdryer, dryer, oven, coffeemaker | \n+| duration | Number:Time | true | This status describes the duration of the program of the home appliance. | oven | \n+| oven_current_cavity_temperature | Number:Temperature | true | This status describes the current cavity temperature of the home appliance. | oven | \n+| setpoint_temperature | Number:Temperature | false | This status describes the setpoint/target temperature of the home appliance. | oven | \n+| laundry_care_washer_temperature | String | false | This status describes the temperature of the washing program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_spin_speed | String | false | This status defines the spin speed of a washer program of the home appliance. | washer, washerdryer | \n+| laundry_care_washer_idos1 | String | false | This status defines the i-Dos 1 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| laundry_care_washer_idos2 | String | false | This status defines the i-Dos 2 dosing level of a washer program of the home appliance (if appliance supports i-Dos). | washer | \n+| dryer_drying_target | String | false | This status defines the desired dryness of a program of the home appliance. | dryer, washerdryer | \n+| setpoint_temperature_refrigerator | Number:Temperature | false | Target temperature of the refrigerator compartment (range depends on appliance - common range 2 to 8\u00b0C). | fridgefreezer | \n+| setpoint_temperature_freezer | Number:Temperature | false | Target temperature of the freezer compartment (range depends on appliance - common range -16 to -24\u00b0C). | fridgefreezer | \n+| super_mode_refrigerator | Switch | false | The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout. | fridgefreezer | \n+| super_mode_freezer | Switch | false | This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the lowest possible temperature until it is disabled manually by the customer or by the home appliance because of a timeout. | fridgefreezer | \n+| coffeemaker_drip_tray_full_state | Switch | true | Is coffee maker drip tray full? | coffeemaker | \n+| coffeemaker_water_tank_empty_state | Switch | true | Is coffee maker water tank empty? | coffeemaker | \n+| coffeemaker_bean_container_empty_state | Switch | true | Is coffee maker bean container empty? | coffeemaker | \n+| hood_venting_level | String | true | This option defines the required fan setting of the hood. | hood | \n+| hood_intensive_level | String | true | This option defines the intensive setting of the hood. | hood | \n+| hood_program_state | String | false | Adds hood controller actions to the appliance. The following commands are supported: `stop`, `venting1`, `venting2`, `venting3`, `venting4`, `venting5`, `ventingIntensive1`, `ventingIntensive1`, `automatic` and `delayed`. Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | hood | \n+| basic_actions_state | String | false | Adds basic controller actions to the appliance. The following basic commands are supported: `start` (start current selected program), `stop` (stop current program) and `selected` (show current program information). Furthermore it is possible to send raw (Home Connect JSON payload) to the home appliance. | dishwasher, oven, washer, washerdryer, dryer, coffeemaker | \n+| functional_light_state | Switch | false | This setting describes the current functional light state of the home appliance. | hood | \n+| functional_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the functional light (Value range 10 - 100%). | hood | \n+| ambient_light_state | Switch | false | This setting describes the current ambient light state of the home appliance. | dishwasher, hood | \n+| ambient_light_brightness_state | Number:Dimensionless | false | This setting describes the brightness state of the ambient light (Value range 10 - 100%). *INFO: Please note that the brightness can't be set if the ambient light color is set to `CustomColor`.* | dishwasher, hood | \n+| ambient_light_color_state | String | false | This setting describes the current ambient light color state of the home appliance. | dishwasher, hood | \n+| ambient_light_custom_color_state | Color | false | This setting describes the custom color state of the ambient light. HSB color commands are supported as well as hex color string e.g. `#11ff00`. *INFO: Please note that the brightness can't be set.* | dishwasher, hood | \n+\n+            \n+## Thing Configuration\n+\n+### Configuring the __Home Connect API__ Bridge\n+\n+\n+#### 1. Preconditions\n+\n+1. Please create an account at [Home Connect](https://www.home-connect.com/) and add your physical appliance to your account.\n+2. Test the connection to your physical appliance via mobile app ([Apple App Store (iOS) ](https://itunes.apple.com/de/app/home-connect-app/id901397789?mt=8) or [Google Play Store (Android)](https://play.google.com/store/apps/details?id=com.bshg.homeconnect.android.release)).\n+\n+#### 2. Create Home Connect developer account\n+\n+1. Create an account at [https://developer.home-connect.com](https://developer.home-connect.com) and login.\n+2. Please make sure you've added your associated Home Connect account email at [https://developer.home-connect.com/user/me/edit](https://developer.home-connect.com/user/me/edit). You should fill in your email address, which you use for the official Android or iOS app, at `Default Home Connect User Account for Testing`.  \n+![Screenshot Home Connect profile page](doc/home_connect_profile.png \"Screenshot Home Connect profile page\")\n+\n+3. Register / Create an application at [https://developer.home-connect.com/applications](https://developer.home-connect.com/applications)\n+    * _Application ID_: e.g. `openhab-binding`\n+    * _OAuth Flow_: Authorization Code Grant Flow\n+    * _Home Connect User Account for Testing_: the associated user account email from [Home Connect](https://www.home-connect.com/)  \n+       > **WARNING**: Please don't use your developer account username  \n+\n+     **_Please don't use your developer account username_**\n+    * _Redirect URIs_: add your openHAB URL followed by `/homeconnect`  \n+    for example: `http://192.168.178.34:8080/homeconnect` or `https://myhome.domain.com/homeconnect`\n+    * _One Time Token Mode_: keep unchecked \n+    * _Proof Key for Code Exchange_: keep unchecked\n+4. After your application has been created, you should see the _Client ID_ and _Client Secret_ of the application. Please save these for later.  \n+\n+![Screenshot Home Connect application page](doc/home_connect_application.png \"Screenshot Home Connect application page\")\n+\n+\n+\n+#### 3. Setup bridge (openHAB UI)\n+\n+The Home Connect bridge can be configured in the openHAB UI as follows:\n+\n+1. Go to the Inbox and press the add button\n+2. Choose `Home Connect Binding`\n+3. Select `Home Connect API`\n+4. Setup and save thing\n+    * __client id:__ your application client id\n+    * __client secret:__ your application client secret\n+    * __simulator:__ false\n+5. Now navigate to the URL (`Redirct URI`) you've  added to your Home Connect application in the previous step (2.3). For example `http://192.168.178.80:8080/homeconnect`.\n+6. Please follow the steps shown to authenticate your binding. You can redo this step every time. For example if you have authentication problems, just start wizard again.  \n+![Screenshot Home Connect wizard page 1](doc/homeconnect_setup_1.png \"Screenshot Home Connect wizard page 1\")  \n+![Screenshot Home Connect wizard page 2](doc/homeconnect_setup_2.png \"Screenshot Home Connect wizard page 2\")  \n+![Screenshot Home Connect wizard page 3](doc/homeconnect_setup_3.png \"Screenshot Home Connect wizard page 3\")  \n+![Screenshot Home Connect wizard page 4](doc/homeconnect_setup_4.png \"Screenshot Home Connect wizard page 4\")  \n+\n+7. That's it! Now you can use autodiscovery to add devices. Your devices should show up if you start a device scan in the openHAB UI.\n+\n+\n+\n+## Examples: File based configuration\n+\n+If you prefer to configure everything via file instead of openHAB UI, here are some examples.\n+\n+### things/homeconnect.things\n+\n+```\n+Bridge homeconnect:api_bridge:api_bridge_at_home \"Home Connect API\" [ clientId=\"1234\", clientSecret=\"1234\", simulator=false] {\n+    // Thing configurations\n+    Thing dishwasher dishwasher1 \"Dishwasher\"  [ haId=\"SIEMENS-HCS02DWH1-6F2FC400C1EA4A\" ]\n+    Thing washer washer1 \"Washer\"  [ haId=\"SIEMENS-HCS03WCH1-1F35EC2BE34A0F\" ]\n+    Thing fridgefreezer fridge1 \"Fridge Freezer  [ haId=\"SIEMENS-HCS05FRF1-7B3FA5EB3D885B\" ]\n+    Thing oven oven1 \"Oven\"  [ haId=\"BOSCH-HCS01OVN1-2132B6FA25BA21\" ]\n+    Thing dryer dryer1 \"Dryer\"  [ haId=\"BOSCH-HCS04DYR1-3921C766AD5BAF\" ]\n+    Thing coffeemaker coffee1 \"Coffee machine\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing washerdryer washerdryer1 \"Washerdryer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing fridgefreezer fridgefreezer1 \"Fridge/Freezer\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hood hood1 \"Hood\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+    Thing hob hob1 \"Hob\"  [ haId=\"BOSCH-HCS06COM1-2140A8821AE7AB\" ]\n+}\n+```\n+\n+### items/homeconnect.items\n+\n+The channel parameter uses the following syntax: `homeconnect:<thing type id>:<bridge id>:<thing id>:<channel type id>`. For example: `homeconnect:dishwasher:api_bridge_at_home:dishwasher1:power_state`\n+\n+```\n+// dishwasher\n+Switch                 Dishwasher_PowerState                  \"Power State\"                       {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:power_state\"}\n+Contact                Dishwasher_DoorState                   \"Door State\"                        {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:door_state\"}\n+String                 Dishwasher_OperationState              \"Operation State\"                   {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:operation_state\"}\n+Switch                 Dishwasher_RemoteStartAllowanceState   \"Remote Start Allowance State\"      {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remote_start_allowance_state\"}\n+Switch                 Dishwasher_RemoteControlActiveState    \"Remote Control Activation State\"   {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remote_control_active_state\"}\n+String                 Dishwasher_SelectedProgramState        \"Selected Program\"                  {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:selected_program_state\"}\n+String                 Dishwasher_ActiveProgramState          \"Active Program\"                    {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:active_program_state\"}\n+Number:Time            Dishwasher_RemainingProgramTimeState   \"Remaining program time\"            {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:remaining_program_time_state\"}\n+Number:Dimensionless   Dishwasher_ProgramProgressState        \"Progress State\"                    {channel=\"homeconnect:dishwasher:api_bridge_at_home:dishwasher1:program_progress_state\"}\n+```\n+\n+## Home Connect Console\n+\n+The binding comes with a separate user interface, which is reachable through the web browser http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). \n+\n+Features:\n+\n+* overview of your bridges and appliances\n+* send commands to your appliances\n+* see latest API requests\n+* see received events from the Home Connect backend\n+* API request counts\n+\n+> **INFO**: If you have a problems with your installation, please always provide request and event exports. ![Screenshot Home Connect wizard page 4](doc/export_button.png \"Export button\")\n+\n+## How To\n+\n+### Notification on credential error\n+\n+To get notified when your Home Connect credentials have been revoked or expired you can use the following rule to get notified. \n+\n+This can happen if \n+\n+* your openHAB instance was offline for a longer period or\n+* new terms weren't accepted or\n+* a technical problem occurred.\n+\n+```java\n+rule \"Offline check - Home Connect bridge\"\n+when\n+    Thing \"<thingUID>\" changed\n+then\n+    val statusInfo = getThingStatusInfo(\"<thingUID>\")\n+    val status = statusInfo.getStatus()\n+    val statusDetail = statusInfo.getStatusDetail()\n+\n+    if ((status !== null) && (statusDetail !== null)) {\n+        logInfo(\"api_bridge\", \"Home Connect bridge status: \" + status.toString() + \" detail: \" + statusDetail.toString())\n+        if (status.toString() == 'OFFLINE' && statusDetail.toString() == 'CONFIGURATION_PENDING') {\n+            logError(\"api_bridge\", \"Home Connect bridge offline.\")\n+            // send push, email, ...\n+        }\n+    }\n+end\n+```\n+\n+### Start program with custom settings\n+\n+Currently, not all program options of a device are available as items in openHAB. For example, you cannot change the `Fill quantity` of a coffee maker program. If you wish to start a program with a custom setting, you can send a special command to the item of type `basic_actions_state`.\n+\n+> **INFO**: Only for advanced users. You need to know how to use the `curl` command. Alternatively you you can use the binding UI to trigger the commands.\n+\n+#### 1. Retrieve \"special command\" payload\n+\n+You have a couple options to get the program settings payload. \n+\n+a) You could have a look at the Home Connect developer documentation (https://developer.home-connect.com/docs/) and create the payload on your own. \n+\n+b) You could have a look at the request logs and extract the payload from there. \n+\n+1. On the physical device, select your desired program with the appropriate options.\n+2. Open the appliance section of the binding UI (http(s)://[YOUROPENHAB]:[YOURPORT]/appliances) and click the 'Selected Program' button.\n+![Screenshot Home Connect wizard page 4](doc/selected_program_1.png \"Get selected program\")\n+3. ![Screenshot Home Connect wizard page 4](doc/selected_program_2.png \"Get selected program\") Copy the JSON payload. In a further step, this payload will be used to start the program.\n+\n+\n+#### 2. Start program\n+\n+After you've extracted the desired program command, you can start your program via openHAB rule or through a `curl` command.\n+\n+##### in rule\n+\n+*Example rule:*\n+\n+```java\n+rule \"trigger program\"\n+when\n+    Time cron \"0 32 13 ? * * *\"\n+then\n+    homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state.sendCommand('{\"data\":{\"key\":\"ConsumerProducts.CoffeeMaker.Program.Beverage.EspressoMacchiato\",\"options\":[{\"key\":\"ConsumerProducts.CoffeeMaker.Option.CoffeeTemperature\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.CoffeeTemperature.94C\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.BeanAmount\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.BeanAmount.Mild\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.FillQuantity\",\"value\":60,\"unit\":\"ml\"}]}}')\n+end\n+```\n+\n+Please replace `homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state` with your item name (of channel type `basic_actions_state`).\n+\n+##### via curl\n+\n+*Example command:*\n+\n+```bash\n+curl -X POST --header \"Content-Type: text/plain\" --header \"Accept: application/json\" -d '{\"data\":{\"key\":\"ConsumerProducts.CoffeeMaker.Program.Beverage.EspressoMacchiato\",\"options\":[{\"key\":\"ConsumerProducts.CoffeeMaker.Option.CoffeeTemperature\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.CoffeeTemperature.94C\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.BeanAmount\",\"value\":\"ConsumerProducts.CoffeeMaker.EnumType.BeanAmount.Mild\",\"unit\":\"enum\"},{\"key\":\"ConsumerProducts.CoffeeMaker.Option.FillQuantity\",\"value\":60,\"unit\":\"ml\"}]}}' \"http://localhost:8080/rest/items/homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state\"\n+```\n+\n+Please replace `homeconnect_CoffeeMaker_BOSCH_HCS06COM1_B95E5103934D_basic_actions_state` with your item name (of channel type `basic_actions_state`).\n+\n+## FAQ\n+\n+### I can't start my oven via openHAB.\n+\n+Some operations are not possible at the moment. You need to sign an \"Additional Partner Agreement\". Please have a look at:\n+https://developer.home-connect.com/docs/authorization/scope\n+\n+### I can't switch remote start to on.\n+\n+The channel of type `remote_start_allowance_state` is read only. You can only enable it directly on the physical appliance.\n+\n+### In case of error...\n+\n+Please check log UI (http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect) and ask for help in the community forum or on github. Please provide request and event exports.  \n+ ![Screenshot Home Connect wizard page 4](doc/export_button.png \"Export button\")\n+\n+### Rate limit reached\n+\n+The Home Connect API enforces rate [limits](https://developer.home-connect.com/docs/general/ratelimiting) . If you have a lot of `429` response codes in your request log section (http(s)://[YOUROPENHAB]:[YOURPORT]/log/requests), please check the error response.\n+\n+\n+### Error message 'Program not supported', 'Unsupported operation' or 'SDK.Error.UnsupportedOption'\n+\n+Not all appliance programs and program options are supported by the Home Connect API. Unfortunately you can't use them. You will see error messages like the following in the binding UI (request log):\n+\n+```json\n+{\n+  \"error\": {\n+    \"key\": \"SDK.Error.UnsupportedProgram\",\n+    \"description\": \"Unsupported operation: LaundryCare.Washer.Program.Cotton.CottonEco\"\n+  }\n+}\n+```\n+\n+```json\n+{\n+  \"error\": {\n+    \"key\": \"SDK.Error.UnsupportedProgram\",\n+    \"description\": \"Program not supported\"\n+  }\n+}\n+```\n+\n+### How to find the Home Appliance ID (HaID) of my device?\n+\n+You have two options to find the right HaID of your device.\n+\n+1. You can use the OpenHAB UI and start a scan. ![Screenshot OpenHAB UI Scan for new devices](doc/ui-scan-for-haid.png \"Scan\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87bf3c15b837ef0487e30f37e609e29f9aa438d"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3MTg5ODU5", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-607189859", "createdAt": "2021-03-09T09:29:35Z", "commit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 68, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wOVQwOToyOTozNVrOIyymeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xMFQyMzozNzoyN1rOI0iK1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MDEyODc2MQ==", "bodyText": "This seems doubled.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r590128761", "createdAt": "2021-03-09T09:29:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/NOTICE", "diffHunk": "@@ -0,0 +1,75 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab2-addons\n+\n+== Third-party Content\n+\n+Thymeleaf\n+* License: Apache License 2.0\n+* Project: https://www.thymeleaf.org/\n+* Source:  https://github.com/thymeleaf/thymeleaf\n+\n+Thymeleaf - Java 8 Time API compatibility\n+* License: Apache License 2.0\n+* Project: https://www.thymeleaf.org/\n+* Source:  https://github.com/thymeleaf/thymeleaf-extras-java8time\n+\n+OGNL Object Graph Navigation Library\n+* License: Apache License 2.0\n+* Project: http://www.opensymphony.com/ognl/\n+* Source:  https://github.com/jkuhnert/ognl/\n+\n+OGNL Object Graph Navigation Library\n+* License: Apache License 2.0\n+* Project: http://www.opensymphony.com/ognl/\n+* Source:  https://github.com/jkuhnert/ognl/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3MzM0OQ==", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n          \n          \n            \n                        .collect(Collectors.toSet());\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Set\n          \n          \n            \n                        .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n          \n          \n            \n                                THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP);", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591873349", "createdAt": "2021-03-10T21:09:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/HomeConnectBindingConstants.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link HomeConnectBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBindingConstants {\n+\n+    public static final String BINDING_ID = \"homeconnect\";\n+\n+    public static final String HA_ID = \"haId\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_API_BRIDGE = new ThingTypeUID(BINDING_ID, \"api_bridge\");\n+    public static final ThingTypeUID THING_TYPE_DISHWASHER = new ThingTypeUID(BINDING_ID, \"dishwasher\");\n+    public static final ThingTypeUID THING_TYPE_OVEN = new ThingTypeUID(BINDING_ID, \"oven\");\n+    public static final ThingTypeUID THING_TYPE_WASHER = new ThingTypeUID(BINDING_ID, \"washer\");\n+    public static final ThingTypeUID THING_TYPE_WASHER_DRYER = new ThingTypeUID(BINDING_ID, \"washerdryer\");\n+    public static final ThingTypeUID THING_TYPE_FRIDGE_FREEZER = new ThingTypeUID(BINDING_ID, \"fridgefreezer\");\n+    public static final ThingTypeUID THING_TYPE_DRYER = new ThingTypeUID(BINDING_ID, \"dryer\");\n+    public static final ThingTypeUID THING_TYPE_COFFEE_MAKER = new ThingTypeUID(BINDING_ID, \"coffeemaker\");\n+    public static final ThingTypeUID THING_TYPE_HOOD = new ThingTypeUID(BINDING_ID, \"hood\");\n+    public static final ThingTypeUID THING_TYPE_COOKTOP = new ThingTypeUID(BINDING_ID, \"hob\");\n+\n+    // Setting\n+    public static final String SETTING_POWER_STATE = \"BSH.Common.Setting.PowerState\";\n+    public static final String SETTING_LIGHTING = \"Cooking.Common.Setting.Lighting\";\n+    public static final String SETTING_AMBIENT_LIGHT_ENABLED = \"BSH.Common.Setting.AmbientLightEnabled\";\n+    public static final String SETTING_LIGHTING_BRIGHTNESS = \"Cooking.Common.Setting.LightingBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_BRIGHTNESS = \"BSH.Common.Setting.AmbientLightBrightness\";\n+    public static final String SETTING_AMBIENT_LIGHT_COLOR = \"BSH.Common.Setting.AmbientLightColor\";\n+    public static final String SETTING_AMBIENT_LIGHT_CUSTOM_COLOR = \"BSH.Common.Setting.AmbientLightCustomColor\";\n+    public static final String SETTING_FREEZER_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureFreezer\";\n+    public static final String SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE = \"Refrigeration.FridgeFreezer.Setting.SetpointTemperatureRefrigerator\";\n+    public static final String SETTING_REFRIGERATOR_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeRefrigerator\";\n+    public static final String SETTING_FREEZER_SUPER_MODE = \"Refrigeration.FridgeFreezer.Setting.SuperModeFreezer\";\n+\n+    // Status\n+    public static final String STATUS_DOOR_STATE = \"BSH.Common.Status.DoorState\";\n+    public static final String STATUS_OPERATION_STATE = \"BSH.Common.Status.OperationState\";\n+    public static final String STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE = \"Cooking.Oven.Status.CurrentCavityTemperature\";\n+    public static final String STATUS_REMOTE_CONTROL_START_ALLOWED = \"BSH.Common.Status.RemoteControlStartAllowed\";\n+    public static final String STATUS_REMOTE_CONTROL_ACTIVE = \"BSH.Common.Status.RemoteControlActive\";\n+    public static final String STATUS_LOCAL_CONTROL_ACTIVE = \"BSH.Common.Status.LocalControlActive\";\n+\n+    // SSE Event types\n+    public static final String EVENT_ELAPSED_PROGRAM_TIME = \"BSH.Common.Option.ElapsedProgramTime\";\n+    public static final String EVENT_OVEN_CAVITY_TEMPERATURE = STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+    public static final String EVENT_POWER_STATE = SETTING_POWER_STATE;\n+    public static final String EVENT_CONNECTED = \"CONNECTED\";\n+    public static final String EVENT_DISCONNECTED = \"DISCONNECTED\";\n+    public static final String EVENT_DOOR_STATE = STATUS_DOOR_STATE;\n+    public static final String EVENT_OPERATION_STATE = STATUS_OPERATION_STATE;\n+    public static final String EVENT_ACTIVE_PROGRAM = \"BSH.Common.Root.ActiveProgram\";\n+    public static final String EVENT_SELECTED_PROGRAM = \"BSH.Common.Root.SelectedProgram\";\n+    public static final String EVENT_REMOTE_CONTROL_START_ALLOWED = STATUS_REMOTE_CONTROL_START_ALLOWED;\n+    public static final String EVENT_REMOTE_CONTROL_ACTIVE = STATUS_REMOTE_CONTROL_ACTIVE;\n+    public static final String EVENT_LOCAL_CONTROL_ACTIVE = STATUS_LOCAL_CONTROL_ACTIVE;\n+    public static final String EVENT_REMAINING_PROGRAM_TIME = \"BSH.Common.Option.RemainingProgramTime\";\n+    public static final String EVENT_PROGRAM_PROGRESS = \"BSH.Common.Option.ProgramProgress\";\n+    public static final String EVENT_SETPOINT_TEMPERATURE = \"Cooking.Oven.Option.SetpointTemperature\";\n+    public static final String EVENT_DURATION = \"BSH.Common.Option.Duration\";\n+    public static final String EVENT_WASHER_TEMPERATURE = \"LaundryCare.Washer.Option.Temperature\";\n+    public static final String EVENT_WASHER_SPIN_SPEED = \"LaundryCare.Washer.Option.SpinSpeed\";\n+    public static final String EVENT_WASHER_IDOS_1_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos1DosingLevel\";\n+    public static final String EVENT_WASHER_IDOS_2_DOSING_LEVEL = \"LaundryCare.Washer.Option.IDos2DosingLevel\";\n+    public static final String EVENT_FREEZER_SETPOINT_TEMPERATURE = SETTING_FREEZER_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FRIDGE_SETPOINT_TEMPERATURE = SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+    public static final String EVENT_FREEZER_SUPER_MODE = SETTING_FREEZER_SUPER_MODE;\n+    public static final String EVENT_FRIDGE_SUPER_MODE = SETTING_REFRIGERATOR_SUPER_MODE;\n+    public static final String EVENT_DRYER_DRYING_TARGET = \"LaundryCare.Dryer.Option.DryingTarget\";\n+    public static final String EVENT_COFFEEMAKER_BEAN_CONTAINER_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.BeanContainerEmpty\";\n+    public static final String EVENT_COFFEEMAKER_WATER_TANK_EMPTY = \"ConsumerProducts.CoffeeMaker.Event.WaterTankEmpty\";\n+    public static final String EVENT_COFFEEMAKER_DRIP_TRAY_FULL = \"ConsumerProducts.CoffeeMaker.Event.DripTrayFull\";\n+    public static final String EVENT_HOOD_VENTING_LEVEL = \"Cooking.Common.Option.Hood.VentingLevel\";\n+    public static final String EVENT_HOOD_INTENSIVE_LEVEL = \"Cooking.Common.Option.Hood.IntensiveLevel\";\n+    public static final String EVENT_FUNCTIONAL_LIGHT_STATE = SETTING_LIGHTING;\n+    public static final String EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = SETTING_LIGHTING_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_STATE = SETTING_AMBIENT_LIGHT_ENABLED;\n+    public static final String EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE = SETTING_AMBIENT_LIGHT_BRIGHTNESS;\n+    public static final String EVENT_AMBIENT_LIGHT_COLOR_STATE = SETTING_AMBIENT_LIGHT_COLOR;\n+    public static final String EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = SETTING_AMBIENT_LIGHT_CUSTOM_COLOR;\n+\n+    // Channel IDs\n+    public static final String CHANNEL_DOOR_STATE = \"door_state\";\n+    public static final String CHANNEL_ELAPSED_PROGRAM_TIME = \"elapsed_program_time\";\n+    public static final String CHANNEL_POWER_STATE = \"power_state\";\n+    public static final String CHANNEL_OPERATION_STATE = \"operation_state\";\n+    public static final String CHANNEL_ACTIVE_PROGRAM_STATE = \"active_program_state\";\n+    public static final String CHANNEL_SELECTED_PROGRAM_STATE = \"selected_program_state\";\n+    public static final String CHANNEL_BASIC_ACTIONS_STATE = \"basic_actions_state\";\n+    public static final String CHANNEL_REMOTE_START_ALLOWANCE_STATE = \"remote_start_allowance_state\";\n+    public static final String CHANNEL_REMOTE_CONTROL_ACTIVE_STATE = \"remote_control_active_state\";\n+    public static final String CHANNEL_LOCAL_CONTROL_ACTIVE_STATE = \"local_control_active_state\";\n+    public static final String CHANNEL_REMAINING_PROGRAM_TIME_STATE = \"remaining_program_time_state\";\n+    public static final String CHANNEL_PROGRAM_PROGRESS_STATE = \"program_progress_state\";\n+    public static final String CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE = \"oven_current_cavity_temperature\";\n+    public static final String CHANNEL_SETPOINT_TEMPERATURE = \"setpoint_temperature\";\n+    public static final String CHANNEL_DURATION = \"duration\";\n+    public static final String CHANNEL_WASHER_TEMPERATURE = \"laundry_care_washer_temperature\";\n+    public static final String CHANNEL_WASHER_SPIN_SPEED = \"laundry_care_washer_spin_speed\";\n+    public static final String CHANNEL_WASHER_IDOS1 = \"laundry_care_washer_idos1\";\n+    public static final String CHANNEL_WASHER_IDOS2 = \"laundry_care_washer_idos2\";\n+    public static final String CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE = \"setpoint_temperature_refrigerator\";\n+    public static final String CHANNEL_REFRIGERATOR_SUPER_MODE = \"super_mode_refrigerator\";\n+    public static final String CHANNEL_FREEZER_SETPOINT_TEMPERATURE = \"setpoint_temperature_freezer\";\n+    public static final String CHANNEL_FREEZER_SUPER_MODE = \"super_mode_freezer\";\n+    public static final String CHANNEL_DRYER_DRYING_TARGET = \"dryer_drying_target\";\n+    public static final String CHANNEL_COFFEEMAKER_DRIP_TRAY_FULL_STATE = \"coffeemaker_drip_tray_full_state\";\n+    public static final String CHANNEL_COFFEEMAKER_WATER_TANK_EMPTY_STATE = \"coffeemaker_water_tank_empty_state\";\n+    public static final String CHANNEL_COFFEEMAKER_BEAN_CONTAINER_EMPTY_STATE = \"coffeemaker_bean_container_empty_state\";\n+    public static final String CHANNEL_HOOD_VENTING_LEVEL = \"hood_venting_level\";\n+    public static final String CHANNEL_HOOD_INTENSIVE_LEVEL = \"hood_intensive_level\";\n+    public static final String CHANNEL_HOOD_ACTIONS_STATE = \"hood_program_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_STATE = \"functional_light_state\";\n+    public static final String CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE = \"functional_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_STATE = \"ambient_light_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE = \"ambient_light_brightness_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_COLOR_STATE = \"ambient_light_color_state\";\n+    public static final String CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE = \"ambient_light_custom_color_state\";\n+\n+    // List of all supported devices\n+    public static final Set<ThingTypeUID> SUPPORTED_DEVICE_THING_TYPES_UIDS = Stream.of(THING_TYPE_API_BRIDGE,\n+            THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+            THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());\n+\n+    // Discoverable devices\n+    public static final Set<ThingTypeUID> DISCOVERABLE_DEVICE_THING_TYPES_UIDS = Stream\n+            .of(THING_TYPE_DISHWASHER, THING_TYPE_OVEN, THING_TYPE_WASHER, THING_TYPE_DRYER, THING_TYPE_WASHER_DRYER,\n+                    THING_TYPE_FRIDGE_FREEZER, THING_TYPE_COFFEE_MAKER, THING_TYPE_HOOD, THING_TYPE_COOKTOP)\n+            .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg3NjAwOA==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591876008", "createdAt": "2021-03-10T21:14:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4Mjg5OQ==", "bodyText": "As this pattern occurs quite often, you could simplify code by including the message in the exception. Then, you only need to log the message once, where the exception is caught finally.\nAlso, take care to handle the InterruptedException appropriately. The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(e);\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n          \n          \n            \n                        trackAndLogApiRequest(null, request, null, null, null);\n          \n          \n            \n                        throw new CommunicationException(\"Failed to fetch home appliances\", e);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591882899", "createdAt": "2021-03-10T21:25:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4ODE1MQ==", "bodyText": "As this can also happen if the JSON contains unexpected data, this should be warn. error can be used if a bug in your code has been detected, for example.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591888151", "createdAt": "2021-03-10T21:34:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 958}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg4OTA5OQ==", "bodyText": "Is there any reason why you don't use DTOs for the mapping methods?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591889099", "createdAt": "2021-03-10T21:35:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectApiClient.java", "diffHunk": "@@ -0,0 +1,1100 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.HttpHelper.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgram;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeConnectResponse;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp by the Jetty HTTP client provided by the openHAB core framework\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectApiClient {\n+    private static final String BSH_JSON_V1 = \"application/vnd.bsh.sdk.v1+json\";\n+    private static final String BASE = \"/api/homeappliances\";\n+    private static final String BASE_PATH = BASE + \"/\";\n+    private static final int REQUEST_TIMEOUT = 30;\n+    private static final int VALUE_TYPE_STRING = 0;\n+    private static final int VALUE_TYPE_INT = 1;\n+    private static final int VALUE_TYPE_BOOLEAN = 2;\n+    private static final int COMMUNICATION_QUEUE_SIZE = 50;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectApiClient.class);\n+    private final HttpClient client;\n+    private final String apiUrl;\n+    private final Map<String, List<AvailableProgramOption>> availableProgramOptionsCache;\n+    private final OAuthClientService oAuthClientService;\n+    private final CircularQueue<ApiRequest> communicationQueue;\n+    private final JsonParser jsonParser;\n+\n+    public HomeConnectApiClient(HttpClient httpClient, OAuthClientService oAuthClientService, boolean simulated,\n+            @Nullable List<ApiRequest> apiRequestHistory) {\n+        this.client = httpClient;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        availableProgramOptionsCache = new ConcurrentHashMap<>();\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        jsonParser = new JsonParser();\n+        communicationQueue = new CircularQueue<>(COMMUNICATION_QUEUE_SIZE);\n+        if (apiRequestHistory != null) {\n+            communicationQueue.addAll(apiRequestHistory);\n+        }\n+    }\n+\n+    /**\n+     * Get all home appliances\n+     *\n+     * @return list of {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public List<HomeAppliance> getHomeAppliances() throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, null, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(null, request, null, response, responseBody);\n+\n+            return mapToHomeAppliances(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to fetch home appliances! error={}\", e.getMessage());\n+            trackAndLogApiRequest(null, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance by id\n+     *\n+     * @param haId home appliance id\n+     * @return {@link HomeAppliance}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public HomeAppliance getHomeAppliance(String haId) throws CommunicationException, AuthorizationException {\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToHomeAppliance(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException | ApplianceOfflineException e) {\n+            logger.warn(\"Failed to get home appliance! haId={}, error={}\", haId, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_ENABLED);\n+    }\n+\n+    /**\n+     * Set ambient light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable ambient light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_ENABLED, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING);\n+    }\n+\n+    /**\n+     * Set functional light state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable functional light\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightState(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get functional light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFunctionalLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_LIGHTING_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set functional light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFunctionalLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_LIGHTING_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light brightness state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightBrightnessState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_BRIGHTNESS);\n+    }\n+\n+    /**\n+     * Set ambient light brightness of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value brightness value 10-100\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightBrightnessState(String haId, int value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_BRIGHTNESS, String.valueOf(value), \"%\"), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get ambient light color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get ambient light custom color state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getAmbientLightCustomColorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_AMBIENT_LIGHT_CUSTOM_COLOR);\n+    }\n+\n+    /**\n+     * Set ambient light color of device.\n+     *\n+     * @param haId home appliance id\n+     * @param value color code\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setAmbientLightCustomColorState(String haId, String value)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_AMBIENT_LIGHT_CUSTOM_COLOR, value, null));\n+    }\n+\n+    /**\n+     * Get power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getPowerState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_POWER_STATE);\n+    }\n+\n+    /**\n+     * Set power state of device.\n+     *\n+     * @param haId home appliance id\n+     * @param state target state\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setPowerState(String haId, String state)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_POWER_STATE, state, null));\n+    }\n+\n+    /**\n+     * Get setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of freezer\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null in case of communication error\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSetpointTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Set setpoint temperature of fridge\n+     *\n+     * @param haId home appliance id\n+     * @param state new temperature\n+     * @param unit temperature unit\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSetpointTemperature(String haId, String state, String unit)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SETPOINT_TEMPERATURE, state, unit), VALUE_TYPE_INT);\n+    }\n+\n+    /**\n+     * Get fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFridgeSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_REFRIGERATOR_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set fridge super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable fridge super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFridgeSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_REFRIGERATOR_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getFreezerSuperMode(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getSetting(haId, SETTING_FREEZER_SUPER_MODE);\n+    }\n+\n+    /**\n+     * Set freezer super mode\n+     *\n+     * @param haId home appliance id\n+     * @param enable enable or disable freezer super mode\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public void setFreezerSuperMode(String haId, boolean enable)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, new Data(SETTING_FREEZER_SUPER_MODE, String.valueOf(enable), null), VALUE_TYPE_BOOLEAN);\n+    }\n+\n+    /**\n+     * Get door state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getDoorState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_DOOR_STATE);\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getOperationState(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OPERATION_STATE);\n+    }\n+\n+    /**\n+     * Get current cavity temperature of oven.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data}\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public Data getCurrentCavityTemperature(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getStatus(haId, STATUS_OVEN_CURRENT_CAVITY_TEMPERATURE);\n+    }\n+\n+    /**\n+     * Is remote start allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlStartAllowed(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_START_ALLOWED);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is remote control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isRemoteControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_REMOTE_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Is local control allowed?\n+     *\n+     * @param haId haId home appliance id\n+     * @return true or false\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public boolean isLocalControlActive(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Data data = getStatus(haId, STATUS_LOCAL_CONTROL_ACTIVE);\n+        return Boolean.parseBoolean(data.getValue());\n+    }\n+\n+    /**\n+     * Get active program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no active program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getActiveProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    /**\n+     * Get selected program of device.\n+     *\n+     * @param haId home appliance id\n+     * @return {@link Data} or null if there is no selected program\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     * @throws ApplianceOfflineException appliance is not connected to the cloud\n+     */\n+    public @Nullable Program getSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getProgram(haId, BASE_PATH + haId + \"/programs/selected\");\n+    }\n+\n+    public void setSelectedProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/selected\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startProgram(String haId, String program)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/programs/active\", new Data(program, null, null), VALUE_TYPE_STRING);\n+    }\n+\n+    public void startSelectedProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        @Nullable\n+        String selectedProgram = getRaw(haId, BASE_PATH + haId + \"/programs/selected\");\n+        if (selectedProgram != null) {\n+            putRaw(haId, BASE_PATH + haId + \"/programs/active\", selectedProgram);\n+        }\n+    }\n+\n+    public void startCustomProgram(String haId, String json)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putRaw(haId, BASE_PATH + haId + \"/programs/active\", json);\n+    }\n+\n+    public void setProgramOptions(String haId, String key, String value, @Nullable String unit, boolean valueAsInt,\n+            boolean isProgramActive) throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        String programState = isProgramActive ? \"active\" : \"selected\";\n+\n+        putOption(haId, BASE_PATH + haId + \"/programs/\" + programState + \"/options\", new Option(key, value, unit),\n+                valueAsInt);\n+    }\n+\n+    public void stopProgram(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        sendDelete(haId, BASE_PATH + haId + \"/programs/active\");\n+    }\n+\n+    public List<AvailableProgram> getPrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs\");\n+    }\n+\n+    public List<AvailableProgram> getAvailablePrograms(String haId)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getAvailablePrograms(haId, BASE_PATH + haId + \"/programs/available\");\n+    }\n+\n+    public List<AvailableProgramOption> getProgramOptions(String haId, String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (availableProgramOptionsCache.containsKey(programKey)) {\n+            logger.debug(\"Returning cached options for '{}'.\", programKey);\n+            List<AvailableProgramOption> availableProgramOptions = availableProgramOptionsCache.get(programKey);\n+            return availableProgramOptions != null ? availableProgramOptions : Collections.emptyList();\n+        }\n+\n+        Request request = createRequest(HttpMethod.GET, BASE_PATH + haId + \"/programs/available/\" + programKey);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            List<AvailableProgramOption> availableProgramOptions = mapToAvailableProgramOption(responseBody, haId);\n+            availableProgramOptionsCache.put(programKey, availableProgramOptions);\n+            return availableProgramOptions;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program options! haId={}, programKey={}, error={}\", haId, programKey,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Get latest API requests.\n+     *\n+     * @return communication queue\n+     */\n+    public Collection<ApiRequest> getLatestApiRequests() {\n+        return communicationQueue.getAll();\n+    }\n+\n+    private Data getSetting(String haId, String setting)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/settings/\" + setting);\n+    }\n+\n+    private void putSettings(String haId, Data data)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putSettings(haId, data, VALUE_TYPE_STRING);\n+    }\n+\n+    private void putSettings(String haId, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        putData(haId, BASE_PATH + haId + \"/settings/\" + data.getName(), data, valueType);\n+    }\n+\n+    private Data getStatus(String haId, String status)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getData(haId, BASE_PATH + haId + \"/status/\" + status);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        return getRaw(haId, path, false);\n+    }\n+\n+    public @Nullable String getRaw(String haId, String path, boolean ignoreResponseCode)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (ignoreResponseCode || response.getStatus() == HttpStatus.OK_200) {\n+                return responseBody;\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get raw! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    public String putRaw(String haId, String path, String requestBodyPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, responseBody);\n+            return responseBody;\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put raw! haId={}, path={}, payload={}, error={}\", haId, path, requestBodyPayload,\n+                    e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private @Nullable Program getProgram(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(asList(HttpStatus.OK_200, HttpStatus.NOT_FOUND_404), request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                return mapToProgram(responseBody);\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get program! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+        return null;\n+    }\n+\n+    private List<AvailableProgram> getAvailablePrograms(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToAvailablePrograms(responseBody, haId);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get available programs! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void sendDelete(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.DELETE, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, null);\n+\n+            trackAndLogApiRequest(haId, request, null, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to send delete! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private Data getData(String haId, String path)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Request request = createRequest(HttpMethod.GET, path);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.OK_200, request, response, haId, null);\n+\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, null, response, responseBody);\n+\n+            return mapToState(responseBody);\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to get data! haId={}, path={}, error={}\", haId, path, e.getMessage());\n+            trackAndLogApiRequest(haId, request, null, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putData(String haId, String path, Data data, int valueType)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", data.getName());\n+\n+        if (data.getValue() != null) {\n+            if (valueType == VALUE_TYPE_INT) {\n+                innerObject.addProperty(\"value\", data.getValueAsInt());\n+            } else if (valueType == VALUE_TYPE_BOOLEAN) {\n+                innerObject.addProperty(\"value\", data.getValueAsBoolean());\n+            } else {\n+                innerObject.addProperty(\"value\", data.getValue());\n+            }\n+        }\n+\n+        if (data.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", data.getUnit());\n+        }\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", innerObject);\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put data! haId={}, path={}, data={}, valueType={}, error={}\", haId, path, data,\n+                    valueType, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void putOption(String haId, String path, Option option, boolean asInt)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        JsonObject innerObject = new JsonObject();\n+        innerObject.addProperty(\"key\", option.getKey());\n+\n+        if (option.getValue() != null) {\n+            if (asInt) {\n+                innerObject.addProperty(\"value\", option.getValueAsInt());\n+            } else {\n+                innerObject.addProperty(\"value\", option.getValue());\n+            }\n+        }\n+\n+        if (option.getUnit() != null) {\n+            innerObject.addProperty(\"unit\", option.getUnit());\n+        }\n+\n+        JsonArray optionsArray = new JsonArray();\n+        optionsArray.add(innerObject);\n+\n+        JsonObject optionsObject = new JsonObject();\n+        optionsObject.add(\"options\", optionsArray);\n+\n+        JsonObject dataObject = new JsonObject();\n+        dataObject.add(\"data\", optionsObject);\n+\n+        String requestBodyPayload = dataObject.toString();\n+\n+        Request request = createRequest(HttpMethod.PUT, path).content(new StringContentProvider(requestBodyPayload),\n+                BSH_JSON_V1);\n+        try {\n+            ContentResponse response = sendRequest(request);\n+            checkResponseCode(HttpStatus.NO_CONTENT_204, request, response, haId, requestBodyPayload);\n+\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, response, response.getContentAsString());\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Failed to put option! haId={}, path={}, option={}, asInt={}, error={}\", haId, path, option,\n+                    asInt, e.getMessage());\n+            trackAndLogApiRequest(haId, request, requestBodyPayload, null, null);\n+            throw new CommunicationException(e);\n+        }\n+    }\n+\n+    private void checkResponseCode(int desiredCode, Request request, ContentResponse response, @Nullable String haId,\n+            @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        checkResponseCode(singletonList(desiredCode), request, response, haId, requestPayload);\n+    }\n+\n+    private void checkResponseCode(List<Integer> desiredCodes, Request request, ContentResponse response,\n+            @Nullable String haId, @Nullable String requestPayload)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        if (!desiredCodes.contains(HttpStatus.UNAUTHORIZED_401)\n+                && response.getStatus() == HttpStatus.UNAUTHORIZED_401) {\n+            logger.debug(\"Current access token is invalid.\");\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+            throw new AuthorizationException(\"Token invalid!\");\n+        }\n+\n+        if (!desiredCodes.contains(response.getStatus())) {\n+            int code = response.getStatus();\n+            String message = response.getReason();\n+\n+            logger.debug(\"Invalid HTTP response code {} (allowed: {})\", code, desiredCodes);\n+            String responseBody = response.getContentAsString();\n+            trackAndLogApiRequest(haId, request, requestPayload, response, responseBody);\n+\n+            responseBody = responseBody == null ? \"\" : responseBody;\n+            if (code == HttpStatus.CONFLICT_409 && responseBody.toLowerCase().contains(\"error\")\n+                    && responseBody.toLowerCase().contains(\"offline\")) {\n+                throw new ApplianceOfflineException(code, message, responseBody);\n+            } else {\n+                throw new CommunicationException(code, message, responseBody);\n+            }\n+        }\n+    }\n+\n+    private Program mapToProgram(String json) {\n+        ArrayList<Option> optionList = new ArrayList<>();\n+        JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+        JsonObject data = responseObject.getAsJsonObject(\"data\");\n+        Program result = new Program(data.get(\"key\").getAsString(), optionList);\n+        JsonArray options = data.getAsJsonArray(\"options\");\n+\n+        options.forEach(option -> {\n+            JsonObject obj = (JsonObject) option;\n+\n+            @Nullable\n+            String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+            @Nullable\n+            String value = obj.get(\"value\") != null && !obj.get(\"value\").isJsonNull() ? obj.get(\"value\").getAsString()\n+                    : null;\n+            @Nullable\n+            String unit = obj.get(\"unit\") != null ? obj.get(\"unit\").getAsString() : null;\n+\n+            optionList.add(new Option(key, value, unit));\n+        });\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgram> mapToAvailablePrograms(String json, String haId) {\n+        ArrayList<AvailableProgram> result = new ArrayList<>();\n+\n+        try {\n+            JsonObject responseObject = jsonParser.parse(json).getAsJsonObject();\n+\n+            JsonArray programs = responseObject.getAsJsonObject(\"data\").getAsJsonArray(\"programs\");\n+            programs.forEach(program -> {\n+                JsonObject obj = (JsonObject) program;\n+                @Nullable\n+                String key = obj.get(\"key\") != null ? obj.get(\"key\").getAsString() : null;\n+                JsonObject constraints = obj.getAsJsonObject(\"constraints\");\n+                boolean available = constraints.get(\"available\") != null && constraints.get(\"available\").getAsBoolean();\n+                @Nullable\n+                String execution = constraints.get(\"execution\") != null ? constraints.get(\"execution\").getAsString()\n+                        : null;\n+\n+                if (key != null && execution != null) {\n+                    result.add(new AvailableProgram(key, available, execution));\n+                }\n+            });\n+        } catch (Exception e) {\n+            logger.error(\"Could not parse available programs response! haId={}, error={}\", haId, e.getMessage());\n+        }\n+\n+        return result;\n+    }\n+\n+    private List<AvailableProgramOption> mapToAvailableProgramOption(String json, String haId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 964}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MTgxNg==", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591891816", "createdAt": "2021-03-10T21:40:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceClient.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.Client;\n+import javax.ws.rs.client.ClientBuilder;\n+import javax.ws.rs.sse.SseEventSource;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Server-Sent-Events client for Home Connect API.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceClient {\n+\n+    private static final int SSE_REQUEST_READ_TIMEOUT = 90;\n+    private static final int EVENT_QUEUE_SIZE = 300;\n+\n+    private final String apiUrl;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthClientService oAuthClientService;\n+    private final Map<HomeConnectEventListener, SseEventSource> eventSourceConnections;\n+    private final Map<SseEventSource, HomeConnectEventSourceListener> eventSourceListeners;\n+    private final ScheduledExecutorService scheduler;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceClient.class);\n+\n+    public HomeConnectEventSourceClient(ClientBuilder clientBuilder, SseEventSourceFactory eventSourceFactory,\n+            OAuthClientService oAuthClientService, boolean simulated, ScheduledExecutorService scheduler,\n+            @Nullable List<Event> eventHistory) {\n+        this.scheduler = scheduler;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthClientService = oAuthClientService;\n+\n+        apiUrl = simulated ? API_SIMULATOR_BASE_URL : API_BASE_URL;\n+        eventSourceConnections = new HashMap<>();\n+        eventSourceListeners = new HashMap<>();\n+        eventQueue = new CircularQueue<>(EVENT_QUEUE_SIZE);\n+        if (eventHistory != null) {\n+            eventQueue.addAll(eventHistory);\n+        }\n+    }\n+\n+    /**\n+     * Register {@link HomeConnectEventListener} to receive events by Home Connect API. This helps to reduce the\n+     * amount of request you would usually need to update all channels.\n+     *\n+     * Checkout rate limits of the API at. https://developer.home-connect.com/docs/general/ratelimiting\n+     *\n+     * @param haId appliance id\n+     * @param eventListener appliance event listener\n+     * @throws CommunicationException API communication exception\n+     * @throws AuthorizationException oAuth authorization exception\n+     */\n+    public synchronized void registerEventListener(final String haId, final HomeConnectEventListener eventListener)\n+            throws CommunicationException, AuthorizationException {\n+        logger.debug(\"Register event listener for '{}': {}\", haId, eventListener);\n+\n+        if (!eventSourceConnections.containsKey(eventListener)) {\n+            logger.debug(\"Create new event source listener for '{}'.\", haId);\n+            Client client = clientBuilder.readTimeout(SSE_REQUEST_READ_TIMEOUT, TimeUnit.SECONDS).register(\n+                    new HomeConnectStreamingRequestFilter(HttpHelper.getAuthorizationHeader(oAuthClientService)))\n+                    .build();\n+            SseEventSource eventSource = eventSourceFactory\n+                    .newSource(client.target(apiUrl + \"/api/homeappliances/\" + haId + \"/events\"));\n+            HomeConnectEventSourceListener eventSourceListener = new HomeConnectEventSourceListener(haId, eventListener,\n+                    this, scheduler, eventQueue);\n+            eventSource.register(eventSourceListener::onEvent, eventSourceListener::onError,\n+                    eventSourceListener::onComplete);\n+            eventSourceListeners.put(eventSource, eventSourceListener);\n+            eventSourceConnections.put(eventListener, eventSource);\n+            eventSource.open();\n+        }\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener) {\n+        unregisterEventListener(eventListener, false, false);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean completed) {\n+        unregisterEventListener(eventListener, false, completed);\n+    }\n+\n+    /**\n+     * Unregister {@link HomeConnectEventListener}.\n+     *\n+     * @param eventListener appliance event listener\n+     * @param immediate true when the unregistering of the event source has to be fast\n+     * @param completed true when the event source is known as already completed by the server\n+     */\n+    public synchronized void unregisterEventListener(HomeConnectEventListener eventListener, boolean immediate,\n+            boolean completed) {\n+        if (eventSourceConnections.containsKey(eventListener)) {\n+            @Nullable\n+            SseEventSource eventSource = eventSourceConnections.get(eventListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MjY2NA==", "bodyText": "See above. Suffix.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591892664", "createdAt": "2021-03-10T21:41:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzE0NA==", "bodyText": "See above. Could be removed. Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893144", "createdAt": "2021-03-10T21:42:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5MzU0NA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893544", "createdAt": "2021-03-10T21:42:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5Mzg4Mg==", "bodyText": "See above. Concrete type. Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591893882", "createdAt": "2021-03-10T21:43:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NTkwMQ==", "bodyText": "If I see correctly, this is run in a framework thread, which shouldn't be blocked by sleeps. You could submit an executor task with a delay.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591895901", "createdAt": "2021-03-10T21:47:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HomeConnectEventSourceListener.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static java.time.LocalDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.sse.InboundSseEvent;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.EventHandling;\n+import org.openhab.binding.homeconnect.internal.client.model.EventLevel;\n+import org.openhab.binding.homeconnect.internal.client.model.EventType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * Event source listener (Server-Sent-Events).\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Replace okhttp SSE by JAX-RS SSE\n+ *\n+ */\n+@NonNullByDefault\n+public class HomeConnectEventSourceListener {\n+    private static final String EMPTY_DATA = \"\\\"\\\"\";\n+    private static final int SSE_MONITOR_INITIAL_DELAY = 1;\n+    private static final int SSE_MONITOR_INTERVAL = 5; // in min\n+    private static final int SSE_MONITOR_BROKEN_CONNECTION_TIMEOUT = 3; // in min\n+\n+    private final String haId;\n+    private final HomeConnectEventListener eventListener;\n+    private final HomeConnectEventSourceClient client;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectEventSourceListener.class);\n+    private final JsonParser jsonParser;\n+    private final ScheduledFuture<?> eventSourceMonitorFuture;\n+    private final CircularQueue<Event> eventQueue;\n+\n+    private @Nullable LocalDateTime lastEventReceived;\n+\n+    public HomeConnectEventSourceListener(String haId, final HomeConnectEventListener eventListener,\n+            final HomeConnectEventSourceClient client, final ScheduledExecutorService scheduler,\n+            CircularQueue<Event> eventQueue) {\n+        this.haId = haId;\n+        this.eventListener = eventListener;\n+        this.client = client;\n+        this.eventQueue = eventQueue;\n+        jsonParser = new JsonParser();\n+\n+        eventSourceMonitorFuture = createMonitor(scheduler);\n+    }\n+\n+    public void onEvent(InboundSseEvent inboundEvent) {\n+        @Nullable\n+        String id = inboundEvent.getId();\n+        @Nullable\n+        String type = inboundEvent.getName();\n+        @Nullable\n+        String data = inboundEvent.readData();\n+\n+        lastEventReceived = now();\n+\n+        @Nullable\n+        EventType eventType = valueOfType(type);\n+        if (eventType != null) {\n+            mapEventSourceEventToEvent(haId, eventType, data).forEach(event -> {\n+                eventQueue.add(event);\n+                logger.debug(\"Received event ({}): {}\", haId, event);\n+                try {\n+                    eventListener.onEvent(event);\n+                } catch (Exception e) {\n+                    logger.error(\"Could not publish event to Listener!\", e);\n+                }\n+            });\n+        } else {\n+            logger.warn(\"Received unknown event source type! haId={}, id={}, type={}, data={}\", haId, id, type, data);\n+        }\n+    }\n+\n+    public void onComplete() {\n+        logger.debug(\"Event source listener channel closed ({}).\", haId);\n+\n+        client.unregisterEventListener(eventListener, true);\n+\n+        try {\n+            eventListener.onClosed();\n+        } catch (Exception e) {\n+            logger.error(\"Could not publish closed event to listener ({})!\", haId, e);\n+        }\n+        stopMonitor();\n+    }\n+\n+    public void onError(Throwable error) {\n+        @Nullable\n+        String throwableMessage = error.getMessage();\n+        String throwableClass = error.getClass().getName();\n+\n+        logger.debug(\"Event source listener connection failure occurred. haId={}, throwable={}, throwableMessage={}\",\n+                haId, throwableClass, throwableMessage);\n+\n+        client.unregisterEventListener(eventListener);\n+\n+        try {\n+            if (throwableMessage != null\n+                    && throwableMessage.contains(String.valueOf(HttpStatus.TOO_MANY_REQUESTS_429))) {\n+                logger.warn(\n+                        \"More than 10 active event monitoring channels was reached. Further event monitoring requests are blocked. haId={}\",\n+                        haId);\n+                eventListener.onRateLimitReached();\n+            } else {\n+                // The SSE connection is closed by the server every 24 hours.\n+                // When you try to reconnect, it often fails with a NotAuthorizedException (401) for the next few\n+                // seconds. So we wait few seconds before trying again.\n+                if (error instanceof NotAuthorizedException) {\n+                    logger.debug(\n+                            \"Event source listener connection failure due to unauthorized exception : wait 5 seconds... haId={}\",\n+                            haId);\n+                    try {\n+                        Thread.sleep(5000);\n+                    } catch (InterruptedException e1) {\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5NzgzOA==", "bodyText": "Is this bucket valid for all Things/accounts by intention, as it is static? I would expect the rate limiting only valid per account.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591897838", "createdAt": "2021-03-10T21:50:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ==", "bodyText": "If you need to access the logger in a static way, you can make it a static field. This should be debug or warn.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591898419", "createdAt": "2021-03-10T21:51:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5OTk3MQ==", "bodyText": "As you already set the exception's cause, you don't need to also add the message.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591899971", "createdAt": "2021-03-10T21:54:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());\n+            }\n+        }\n+        return request.send();\n+    }\n+\n+    public static String formatJsonBody(@Nullable String jsonString) {\n+        if (jsonString == null) {\n+            return \"\";\n+        }\n+        try {\n+            JsonObject json = JSON_PARSER.parse(jsonString).getAsJsonObject();\n+            return GSON.toJson(json);\n+        } catch (Exception e) {\n+            return jsonString;\n+        }\n+    }\n+\n+    public static String getAuthorizationHeader(OAuthClientService oAuthClientService)\n+            throws AuthorizationException, CommunicationException {\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            // refresh the token if it's about to expire\n+            if (accessTokenResponse != null\n+                    && accessTokenResponse.isExpired(LocalDateTime.now(), OAUTH_EXPIRE_BUFFER)) {\n+                LoggerFactory.getLogger(HttpHelper.class).debug(\"Requesting a refresh of the access token.\");\n+                accessTokenResponse = oAuthClientService.refreshToken();\n+            }\n+\n+            if (accessTokenResponse != null) {\n+                String lastToken = lastAccessToken;\n+                if (lastToken == null) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The used access token was created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                } else if (!lastToken.equals(accessTokenResponse.getAccessToken())) {\n+                    LoggerFactory.getLogger(HttpHelper.class).debug(\"The access token changed. New one created at {}\",\n+                            accessTokenResponse.getCreatedOn().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n+                }\n+                lastAccessToken = accessTokenResponse.getAccessToken();\n+                return BEARER + accessTokenResponse.getAccessToken();\n+            } else {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"No access token available! Fatal error.\");\n+                throw new AuthorizationException(\"No access token available!\");\n+            }\n+        } catch (IOException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new CommunicationException(errorMessage != null ? errorMessage : \"IOException\", e);\n+        } catch (OAuthException | OAuthResponseException e) {\n+            @Nullable\n+            String errorMessage = e.getMessage();\n+            throw new AuthorizationException(errorMessage != null ? errorMessage : \"oAuth exception\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMjUyNA==", "bodyText": "If you don't want to make it Instant, you could at least add the time suffix to the field name.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591902524", "createdAt": "2021-03-10T21:58:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/model/Token.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client.model;\n+\n+import java.util.Date;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Token model\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Token {\n+\n+    private final String accessToken;\n+    private final String refreshToken;\n+    private final long accessTokenExpiration;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2OTQ0NA=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwMzU4Mw==", "bodyText": "This could by null due to concurrency.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n          \n          \n            \n                private @Nullable HomeConnectBridgeHandler bridgeHandler;", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591903583", "createdAt": "2021-03-10T22:00:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDAxNA==", "bodyText": "This could be removed.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n          \n          \n            \n                public void setThingHandler(ThingHandler handler) {", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904014", "createdAt": "2021-03-10T22:01:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDQwNw==", "bodyText": "Why do you need to be Java 8 compatible?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904407", "createdAt": "2021-03-10T22:02:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final HomeConnectBridgeHandler bridgeHandler;\n+    private final Logger logger;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService} with the given\n+     * {@link org.openhab.core.thing.binding.BridgeHandler}.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public HomeConnectDiscoveryService(HomeConnectBridgeHandler bridgeHandler) {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+        this.bridgeHandler = bridgeHandler;\n+        logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (alreadyExists(appliance.getHaId())) {\n+                    logger.debug(\"Device {} ({}) already added as thing.\", appliance.getHaId(),\n+                            appliance.getType().toUpperCase());\n+                } else if (thingTypeUID != null && DISCOVERABLE_DEVICE_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                    logger.info(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+                    bridgeHandler.getThing().getThings().forEach(thing -> thing.getProperties().get(HA_ID));\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMDA0Nw=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNDc2NA==", "bodyText": "See above. Concrete type. Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591904764", "createdAt": "2021-03-10T22:02:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/discovery/HomeConnectDiscoveryService.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.discovery;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.BINDING_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.DISCOVERABLE_DEVICE_THING_TYPES_UIDS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COFFEE_MAKER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_COOKTOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DISHWASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_DRYER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_FRIDGE_FREEZER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_HOOD;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_OVEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.THING_TYPE_WASHER_DRYER;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDiscoveryService} is responsible for discovering new devices.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    private static final int SEARCH_TIME = 20;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDiscoveryService.class);\n+\n+    private @NonNullByDefault({}) HomeConnectBridgeHandler bridgeHandler;\n+\n+    /**\n+     * Construct an {@link HomeConnectDiscoveryService}.\n+     *\n+     */\n+    public HomeConnectDiscoveryService() {\n+        super(DISCOVERABLE_DEVICE_THING_TYPES_UIDS, SEARCH_TIME, true);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@NonNullByDefault({}) ThingHandler handler) {\n+        if (handler instanceof HomeConnectBridgeHandler) {\n+            this.bridgeHandler = (HomeConnectBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting device scan.\");\n+\n+        HomeConnectApiClient apiClient = bridgeHandler.getApiClient();\n+\n+        try {\n+            List<HomeAppliance> appliances = apiClient.getHomeAppliances();\n+            logger.debug(\"Scan found {} devices.\", appliances.size());\n+\n+            // add found devices\n+            for (HomeAppliance appliance : appliances) {\n+                @Nullable\n+                ThingTypeUID thingTypeUID = getThingTypeUID(appliance);\n+\n+                if (thingTypeUID != null) {\n+                    logger.debug(\"Found {} ({}).\", appliance.getHaId(), appliance.getType().toUpperCase());\n+\n+                    Map<String, Object> properties = new HashMap<>();\n+                    properties.put(HA_ID, appliance.getHaId());\n+                    String name = appliance.getBrand() + \" \" + appliance.getName() + \" (\" + appliance.getHaId() + \")\";\n+\n+                    DiscoveryResult discoveryResult = DiscoveryResultBuilder\n+                            .create(new ThingUID(BINDING_ID, appliance.getType(),\n+                                    bridgeHandler.getThing().getUID().getId(), appliance.getHaId()))\n+                            .withThingType(thingTypeUID).withProperties(properties).withRepresentationProperty(HA_ID)\n+                            .withBridge(bridgeHandler.getThing().getUID()).withLabel(name).build();\n+                    thingDiscovered(discoveryResult);\n+                } else {\n+                    logger.debug(\"Ignoring unsupported device {} of type {}.\", appliance.getHaId(),\n+                            appliance.getType());\n+                }\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTM2NQ==", "bodyText": "See above. Suffix.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905365", "createdAt": "2021-03-10T22:04:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905691", "createdAt": "2021-03-10T22:04:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTk2Mw==", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591905963", "createdAt": "2021-03-10T22:05:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzQxMQ==", "bodyText": "Actually this is handled by the framework. Any child Things are set to OFFLINE if the bridge is offline. This is done if the child Things are UNKNOWN or ONLINE.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907411", "createdAt": "2021-03-10T22:07:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNzc0MA==", "bodyText": "See above. Logging could be removed. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591907740", "createdAt": "2021-03-10T22:08:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw==", "bodyText": "You could add the message to updateStatus() as an argument, to display it in the UI. The log message can be removed, then. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591909783", "createdAt": "2021-03-10T22:11:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMDA3MQ==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591910071", "createdAt": "2021-03-10T22:12:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMjQ5OA==", "bodyText": "Are these checks necessary? If I see correctly, the Thing is set OFFLINE if there is no bridge or the bridge is offline. Then, the third check would be sufficient.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591912498", "createdAt": "2021-03-10T22:16:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxMzMxNA==", "bodyText": "Yes, debug.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591913314", "createdAt": "2021-03-10T22:18:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0MzM3MQ=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 545}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDE0Mw==", "bodyText": "In this case you could throw an unchecked exception to make things easier. But I won't insist on changing it.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914143", "createdAt": "2021-03-10T22:19:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc0NDI5OQ=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNDU2Ng==", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591914566", "createdAt": "2021-03-10T22:20:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 524}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNTg5Mg==", "bodyText": "What is the reason for catching RuntimeExceptions? Actually, these are handled by the framework.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591915892", "createdAt": "2021-03-10T22:23:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 709}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxNjI1NA==", "bodyText": "Can it be removed here, then?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591916254", "createdAt": "2021-03-10T22:23:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1370 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_BASIC_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_IDOS2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_SELECTED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_START;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.HA_ID;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_1_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_IDOS_2_DOSING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_SPIN_SPEED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_WASHER_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_DOOR_OPEN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_EVENT_PRESENT_STATE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_FINISHED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.CONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.DISCONNECTED;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.KEEP_ALIVE;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.SmartHomeUnits.PERCENT;\n+import static org.openhab.core.library.unit.SmartHomeUnits.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+import static org.openhab.core.thing.ThingStatus.ONLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateDescriptionFragmentBuilder;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final Map<ChannelUID, State> expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger;\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+        expiringStateMap = Collections.synchronizedMap(new PassiveExpiringMap<>(TimeUnit.SECONDS.toMillis(CACHE_TTL)));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (isBridgeOnline()) {\n+            refreshThingStatus(); // set ONLINE / OFFLINE\n+            updateSelectedProgramStateDescription();\n+            updateChannels();\n+            registerEventListener();\n+            scheduleOfflineMonitor1();\n+            scheduleOfflineMonitor2();\n+        } else {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        unregisterEventListener();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        super.bridgeStatusChanged(bridgeStatusInfo);\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+\n+        dispose();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        @Nullable\n+                        Bridge bridge = getBridge();\n+                        if (bridge != null) {\n+                            @Nullable\n+                            BridgeHandler bridgeHandler = bridge.getHandler();\n+                            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                                HomeConnectBridgeHandler homeConnectBridgeHandler = (HomeConnectBridgeHandler) bridgeHandler;\n+                                // workaround for api bug\n+                                // if simulator, program options have to be passed along with the desired program\n+                                // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                                if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                                    apiClient.startSelectedProgram(getThingHaId());\n+                                } else {\n+                                    @Nullable\n+                                    Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                                    if (selectedProgram != null) {\n+                                        apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.info(\"Start custom program. command={} haId={}\", command.toFullString(), getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.warn(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.warn(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.info(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.info(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.info(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        unregisterEventListener();\n+        refreshThingStatus();\n+        registerEventListener();\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduler.schedule(() -> {\n+            logger.debug(\"Try to register event listener again. haId={}\", getThingHaId());\n+            unregisterEventListener();\n+            registerEventListener();\n+        }, AbstractHomeConnectThingHandler.EVENT_LISTENER_CONNECT_RETRY_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.error(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        getEventSourceClient().ifPresent(client -> client.unregisterEventListener(this));\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                ArrayList<StateOption> stateOptions = new ArrayList<>();\n+                apiClient.get().getPrograms(getThingHaId())\n+                        .forEach(p -> stateOptions.add(new StateOption(p.getKey(), mapStringType(p.getKey()))));\n+\n+                @Nullable\n+                StateDescription stateDescription = StateDescriptionFragmentBuilder.create().withPattern(\"%s\")\n+                        .withReadOnly(stateOptions.isEmpty()).withOptions(stateOptions).build().toStateDescription();\n+\n+                if (stateDescription != null && !stateOptions.isEmpty()) {\n+                    getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(channel -> dynamicStateDescriptionProvider\n+                            .putStateDescriptions(channel.getUID().getAsString(), stateDescription));\n+                } else {\n+                    logger.debug(\"No state description available. haId={}\", getThingHaId());\n+                    removeSelectedProgramStateDescription();\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                channel -> dynamicStateDescriptionProvider.removeStateDescriptions(channel.getUID().getAsString()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.warn(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.warn(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                                                                                         // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.error(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.NULL));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1MDY0MQ=="}, "originalCommit": {"oid": "366b0044e000f523d11023f78481aeddc77cc058"}, "originalPosition": 779}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxODYxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n          \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n          \n          \n            \n                            OnOffType.from(!STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()))));", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591918616", "createdAt": "2021-03-10T22:28:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 835}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkxOTE2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return event -> getThingChannel(channelId).ifPresent(\n          \n          \n            \n                            channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n          \n          \n            \n                    return event -> getThingChannel(channelId)\n          \n          \n            \n                            .ifPresent(channel -> updateState(channel.getUID(), OnOffType.from(event.getValueAsBoolean())));", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591919167", "createdAt": "2021-03-10T22:29:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 840}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMDEzMA==", "bodyText": "See above. Use from(). Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591920130", "createdAt": "2021-03-10T22:31:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 997}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyMzY3Mg==", "bodyText": "Can you use isThingReadyToHandleCommand() here?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591923672", "createdAt": "2021-03-10T22:38:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 1230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNDk1Mg==", "bodyText": "Is there any difference between the two, beside the delay?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591924952", "createdAt": "2021-03-10T22:40:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.info(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"BridgeHandler not found. Cannot handle command without bridge. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(\n+            final ConcurrentHashMap<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final ConcurrentHashMap<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.warn(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (isBridgeOffline()) {\n+            logger.debug(\"BridgeHandler not found or offline. Stopping update of channel {}. thing={}, haId={}\",\n+                    channelUID, getThingLabel(), getThingHaId());\n+            return;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channel {}. haId={}\", getThing().getLabel(), channelUID,\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);\n+                } else {\n+                    logger.debug(\"Update status to ONLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(ONLINE);\n+                }\n+                accessible.set(true);\n+            } catch (CommunicationException | RuntimeException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}.\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+            } catch (AuthorizationException e) {\n+                logger.debug(\n+                        \"Update status to OFFLINE. Home Connect service is not reachable or a problem occurred!  thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Home Connect service is not reachable or a problem occurred! (\" + e.getMessage() + \").\");\n+                accessible.set(false);\n+                handleAuthenticationError(e);\n+            }\n+        });\n+        if (!apiClient.isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        }\n+    }\n+\n+    /**\n+     * Get home appliance id of Thing.\n+     *\n+     * @return home appliance id\n+     */\n+    public String getThingHaId() {\n+        return getThing().getConfiguration().get(HA_ID).toString();\n+    }\n+\n+    /**\n+     * Returns the human readable label for this thing.\n+     *\n+     * @return the human readable label\n+     */\n+    protected @Nullable String getThingLabel() {\n+        return getThing().getLabel();\n+    }\n+\n+    /**\n+     * Handle authentication exception.\n+     */\n+    protected void handleAuthenticationError(AuthorizationException exception) {\n+        if (isBridgeOnline()) {\n+            logger.debug(\n+                    \"Thing handler threw authentication exception --> clear credential storage thing={}, haId={} error={}\",\n+                    getThingLabel(), getThingHaId(), exception.getMessage());\n+\n+            getBridgeHandler().ifPresent(homeConnectBridgeHandler -> {\n+                try {\n+                    homeConnectBridgeHandler.getOAuthClientService().remove();\n+                    homeConnectBridgeHandler.reinitialize();\n+                } catch (OAuthException e) {\n+                    // client is already closed --> we can ignore it\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Get operation state of device.\n+     *\n+     * @return operation state string\n+     */\n+    protected @Nullable String getOperationState() {\n+        return operationState;\n+    }\n+\n+    protected EventHandler defaultElapsedProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultPowerStateEventHandler() {\n+        return event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultDoorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_DOOR_OPEN.equals(event.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED));\n+    }\n+\n+    protected EventHandler defaultOperationStateEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+\n+            if (STATE_OPERATION_FINISHED.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(100, PERCENT)));\n+                getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, SECOND)));\n+            } else if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), new QuantityType<>(0, PERCENT)));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+            } else if (STATE_OPERATION_READY.equals(event.getValue())) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultActiveProgramEventHandler() {\n+        return event -> {\n+            @Nullable\n+            String value = event.getValue();\n+            getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    value == null ? UnDefType.UNDEF : new StringType(mapStringType(value))));\n+            if (event.getValue() == null) {\n+                resetProgramStateChannels();\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultEventPresentStateEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(channel -> updateState(channel.getUID(),\n+                STATE_EVENT_PRESENT_STATE_OFF.equals(event.getValue()) ? OnOffType.OFF : OnOffType.ON));\n+    }\n+\n+    protected EventHandler defaultBooleanEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), event.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF));\n+    }\n+\n+    protected EventHandler defaultRemainingProgramTimeEventHandler() {\n+        return event -> getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND)));\n+    }\n+\n+    protected EventHandler defaultSelectedProgramStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue())));\n+    }\n+\n+    protected EventHandler defaultAmbientLightCustomColorStateEventHandler() {\n+        return event -> getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+            @Nullable\n+            String value = event.getValue();\n+            if (value != null) {\n+                updateState(channel.getUID(), mapColor(value));\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        });\n+    }\n+\n+    protected EventHandler updateProgramOptionsAndSelectedProgramStateEventHandler() {\n+        return event -> {\n+            defaultSelectedProgramStateEventHandler().handle(event);\n+\n+            // update available program options\n+            try {\n+                @Nullable\n+                String programKey = event.getValue();\n+                if (programKey != null) {\n+                    updateProgramOptionsStateDescriptions(programKey);\n+                }\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not update program options. {}\", e.getMessage());\n+            }\n+        };\n+    }\n+\n+    protected EventHandler defaultPercentEventHandler(String channelId) {\n+        return event -> getThingChannel(channelId).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), PERCENT)));\n+    }\n+\n+    protected ChannelUpdateHandler defaultDoorStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getDoorState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_DOOR_OPEN.equals(data.getValue()) ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultPowerStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getPowerState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    return STATE_POWER_ON.equals(data.getValue()) ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultAmbientLightChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getAmbientLightState(getThingHaId());\n+                if (data.getValue() != null) {\n+                    boolean enabled = data.getValueAsBoolean();\n+                    if (enabled) {\n+                        // brightness\n+                        Data brightnessData = apiClient.get().getAmbientLightBrightnessState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+\n+                        // color\n+                        Data colorData = apiClient.get().getAmbientLightColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_COLOR_STATE).ifPresent(\n+                                channel -> updateState(channel.getUID(), new StringType(colorData.getValue())));\n+\n+                        // custom color\n+                        Data customColorData = apiClient.get().getAmbientLightCustomColorState(getThingHaId());\n+                        getThingChannel(CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE).ifPresent(channel -> {\n+                            @Nullable\n+                            String value = customColorData.getValue();\n+                            if (value != null) {\n+                                updateState(channel.getUID(), mapColor(value));\n+                            } else {\n+                                updateState(channel.getUID(), UnDefType.UNDEF);\n+                            }\n+                        });\n+\n+                    }\n+                    return enabled ? OnOffType.ON : OnOffType.OFF;\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultNoOpUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, UnDefType.UNDEF);\n+    }\n+\n+    protected ChannelUpdateHandler defaultOperationStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                Data data = apiClient.get().getOperationState(getThingHaId());\n+\n+                @Nullable\n+                String value = data.getValue();\n+                if (value != null) {\n+                    operationState = data.getValue();\n+                    return new StringType(mapStringType(value));\n+                } else {\n+                    operationState = null;\n+                    return UnDefType.UNDEF;\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultLocalControlActiveStateChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isLocalControlActive(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultRemoteStartAllowanceChannelUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                return apiClient.get().isRemoteControlStartAllowed(getThingHaId()) ? OnOffType.ON : OnOffType.OFF;\n+            }\n+            return OnOffType.OFF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getSelectedProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    updateProgramOptionsStateDescriptions(program.getKey());\n+                    processProgramOptions(program.getOptions());\n+\n+                    return new StringType(program.getKey());\n+                } else {\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected ChannelUpdateHandler defaultActiveProgramStateUpdateHandler() {\n+        return (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+            if (apiClient.isPresent()) {\n+                @Nullable\n+                Program program = apiClient.get().getActiveProgram(getThingHaId());\n+\n+                if (program != null) {\n+                    processProgramOptions(program.getOptions());\n+                    return new StringType(mapStringType(program.getKey()));\n+                } else {\n+                    resetProgramStateChannels();\n+                    return UnDefType.UNDEF;\n+                }\n+            }\n+            return UnDefType.UNDEF;\n+        }));\n+    }\n+\n+    protected void processProgramOptions(List<Option> options) {\n+        options.forEach(option -> {\n+            @Nullable\n+            String key = option.getKey();\n+            if (key != null) {\n+                switch (key) {\n+                    case OPTION_WASHER_TEMPERATURE:\n+                        getThingChannel(CHANNEL_WASHER_TEMPERATURE)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_SPIN_SPEED:\n+                        getThingChannel(CHANNEL_WASHER_SPIN_SPEED)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_1_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS1)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_WASHER_IDOS_2_DOSING_LEVEL:\n+                        getThingChannel(CHANNEL_WASHER_IDOS2)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_DRYER_DRYING_TARGET:\n+                        getThingChannel(CHANNEL_DRYER_DRYING_TARGET)\n+                                .ifPresent(channel -> updateState(channel.getUID(), new StringType(option.getValue())));\n+                        break;\n+                    case OPTION_HOOD_INTENSIVE_LEVEL:\n+                        @Nullable\n+                        String hoodIntensiveLevelValue = option.getValue();\n+                        if (hoodIntensiveLevelValue != null) {\n+                            getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodIntensiveLevelValue))));\n+                        }\n+                        break;\n+                    case OPTION_HOOD_VENTING_LEVEL:\n+                        @Nullable\n+                        String hoodVentingLevel = option.getValue();\n+                        if (hoodVentingLevel != null) {\n+                            getThingChannel(CHANNEL_HOOD_VENTING_LEVEL)\n+                                    .ifPresent(channel -> updateState(channel.getUID(),\n+                                            new StringType(mapStageStringType(hoodVentingLevel))));\n+                        }\n+                        break;\n+                    case OPTION_SETPOINT_TEMPERATURE:\n+                        getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), mapTemperature(option.getUnit()))));\n+                        break;\n+                    case OPTION_DURATION:\n+                        getThingChannel(CHANNEL_DURATION).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_REMAINING_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_REMAINING_PROGRAM_TIME_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_ELAPSED_PROGRAM_TIME:\n+                        getThingChannel(CHANNEL_ELAPSED_PROGRAM_TIME).ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(option.getValueAsInt(), SECOND)));\n+                        break;\n+                    case OPTION_PROGRAM_PROGRESS:\n+                        getThingChannel(CHANNEL_PROGRAM_PROGRESS_STATE)\n+                                .ifPresent(channel -> updateState(channel.getUID(),\n+                                        new QuantityType<>(option.getValueAsInt(), PERCENT)));\n+                        break;\n+                }\n+            }\n+        });\n+    }\n+\n+    protected String convertWasherTemperature(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.GC\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.Temperature.GC\", \"\") + \"\u00b0C\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.Temperature.Ul\")) {\n+            return mapStringType(value.replace(\"LaundryCare.Washer.EnumType.Temperature.Ul\", \"\"));\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected String convertWasherSpinSpeed(String value) {\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.RPM\", \"\") + \" RPM\";\n+        }\n+\n+        if (value.startsWith(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\")) {\n+            return value.replace(\"LaundryCare.Washer.EnumType.SpinSpeed.Ul\", \"\");\n+        }\n+\n+        return mapStringType(value);\n+    }\n+\n+    protected void updateProgramOptionsStateDescriptions(String programKey)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            List<AvailableProgramOption> availableProgramOptions = apiClient.get().getProgramOptions(getThingHaId(),\n+                    programKey);\n+\n+            Optional<Channel> channelSpinSpeed = getThingChannel(CHANNEL_WASHER_SPIN_SPEED);\n+            Optional<Channel> channelTemperature = getThingChannel(CHANNEL_WASHER_TEMPERATURE);\n+            Optional<Channel> channelDryingTarget = getThingChannel(CHANNEL_DRYER_DRYING_TARGET);\n+\n+            if (availableProgramOptions.isEmpty()) {\n+                channelSpinSpeed.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelTemperature.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+                channelDryingTarget.ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+            }\n+\n+            availableProgramOptions.forEach(option -> {\n+                switch (option.getKey()) {\n+                    case OPTION_WASHER_SPIN_SPEED: {\n+                        channelSpinSpeed\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherSpinSpeed)));\n+                        break;\n+                    }\n+                    case OPTION_WASHER_TEMPERATURE: {\n+                        channelTemperature\n+                                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(),\n+                                        createStateOptions(option, this::convertWasherTemperature)));\n+                        break;\n+                    }\n+                    case OPTION_DRYER_DRYING_TARGET: {\n+                        channelDryingTarget.ifPresent(channel -> dynamicStateDescriptionProvider\n+                                .setStateOptions(channel.getUID(), createStateOptions(option, this::mapStringType)));\n+                        break;\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    protected HomeConnectDynamicStateDescriptionProvider getDynamicStateDescriptionProvider() {\n+        return dynamicStateDescriptionProvider;\n+    }\n+\n+    private List<StateOption> createStateOptions(AvailableProgramOption option,\n+            Function<String, String> stateConverter) {\n+        return option.getAllowedValues().stream().map(av -> new StateOption(av, stateConverter.apply(av)))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor1() {\n+        this.reinitializationFuture1 = scheduler.schedule(() -> {\n+            if (isBridgeOnline() && isThingOffline()) {\n+                logger.debug(\"Offline monitor 1: Check if thing is ONLINE. thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId());\n+                refreshThingStatus();\n+                if (isThingOnline()) {\n+                    logger.debug(\"Offline monitor 1: Thing status changed to ONLINE. thing={}, haId={}\",\n+                            getThingLabel(), getThingHaId());\n+                    reinitialize();\n+                } else {\n+                    scheduleOfflineMonitor1();\n+                }\n+            } else {\n+                scheduleOfflineMonitor1();\n+            }\n+        }, AbstractHomeConnectThingHandler.OFFLINE_MONITOR_1_DELAY, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void stopOfflineMonitor1() {\n+        @Nullable\n+        ScheduledFuture<?> reinitializationFuture = this.reinitializationFuture1;\n+        if (reinitializationFuture != null) {\n+            reinitializationFuture.cancel(false);\n+            this.reinitializationFuture1 = null;\n+        }\n+    }\n+\n+    private synchronized void scheduleOfflineMonitor2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 1256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNTUxOQ==", "bodyText": "See above. Suffix.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591925519", "createdAt": "2021-03-10T22:41:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNjQ5OQ==", "bodyText": "Is there any reason for logging the OH version?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591926499", "createdAt": "2021-03-10T22:43:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyNzUzMA==", "bodyText": "These can be null if the user forgets to specify them with textual configuration.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591927530", "createdAt": "2021-03-10T22:45:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/configuration/ApiBridgeConfiguration.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link ApiBridgeConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiBridgeConfiguration {\n+\n+    private @NonNullByDefault({}) String clientId;\n+    private @NonNullByDefault({}) String clientSecret;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODIwOQ==", "bodyText": "See above. Could be removed. Please check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928209", "createdAt": "2021-03-10T22:47:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODUwMw==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928503", "createdAt": "2021-03-10T22:47:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyODkzMw==", "bodyText": "Maybe it should be made Nullable.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591928933", "createdAt": "2021-03-10T22:48:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.API_SIMULATOR_BASE_URL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_AUTHORIZE_PATH;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_SCOPE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OAUTH_TOKEN_PATH;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(oAuthClientService, config.isSimulator(), scheduler,\n+                eventHistory);\n+\n+        try {\n+            @Nullable\n+            AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+            if (accessTokenResponse == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                logger.info(\n+                        \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                        getThing().getLabel());\n+            } else {\n+                apiClient.getHomeAppliances();\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                | AuthorizationException e) {\n+            ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+            String infoMessage = String.format(\n+                    \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                    nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                    getThing().getLabel());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+            logger.info(\"{}\", infoMessage);\n+\n+            scheduleReinitialize();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE);\n+        stopReinitializer();\n+        cleanup();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwNDc5Mg=="}, "originalCommit": {"oid": "9747dacf2e2faa47e6bf8b2b7dc51bde9a659949"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkyOTIwMQ==", "bodyText": "See above, info and error.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591929201", "createdAt": "2021-03-10T22:49:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.Version;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        Version version = FrameworkUtil.getBundle(this.getClass()).getVersion();\n+        String openHabVersion = OpenHAB.getVersion();\n+        logger.debug(\"Initialize bridge {} (Bundle: {}, openHAB: {})\", getThing().getLabel(), version.toString(),\n+                openHabVersion);\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);\n+\n+                scheduleReinitialize();\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(true);\n+    }\n+\n+    public void reinitialize() {\n+        logger.debug(\"Reinitialize bridge {}\", getThing().getLabel());\n+        stopReinitializer();\n+        cleanup(false);\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (isModifyingCurrentConfig(configurationParameters)) {\n+            List<String> parameters = configurationParameters.entrySet().stream().map((entry) -> {\n+                if (CLIENT_ID.equals(entry.getKey()) || CLIENT_SECRET.equals(entry.getKey())) {\n+                    return entry.getKey() + \": ***\";\n+                }\n+                return entry.getKey() + \": \" + entry.getValue();\n+            }).collect(Collectors.toList());\n+\n+            logger.info(\"Update bridge configuration. bridge={}, parameters={}\", getThing().getLabel(), parameters);\n+\n+            validateConfigurationParameters(configurationParameters);\n+            Configuration configuration = editConfiguration();\n+            for (Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+                configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+            }\n+\n+            // invalidate oAuth credentials\n+            try {\n+                logger.info(\"Clear oAuth credential store. bridge={}\", getThing().getLabel());\n+                oAuthClientService.remove();\n+            } catch (OAuthException e) {\n+                logger.error(\"Could not clear oAuth credentials. bridge={}\", getThing().getLabel(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzIzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n          \n          \n            \n                private static final List<String> INACTIVE_STATE = List.of(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933236", "createdAt": "2021-03-10T22:56:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzMzc3Mw==", "bodyText": "The super type should be used where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n          \n          \n            \n                protected void configureChannelUpdateHandlers(Map<String, ChannelUpdateHandler> handlers) {", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591933773", "createdAt": "2021-03-10T22:57:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNDM3MA==", "bodyText": "You could handle these exceptions in the abstract class, as they seem to be repeated in each handler.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591934370", "createdAt": "2021-03-10T22:59:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectDryerHandler.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DRYER_DRYING_TARGET;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DRYER_DRYING_TARGET;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectDryerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a dryer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectDryerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectDryerHandler.class);\n+\n+    public HomeConnectDryerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE,\n+                updateProgramOptionsStateDescriptionsAndSelectedProgramStateUpdateHandler());\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_SELECTED_PROGRAM, updateProgramOptionsAndSelectedProgramStateEventHandler());\n+\n+        // register dryer specific event handlers\n+        handlers.put(EVENT_DRYER_DRYING_TARGET,\n+                event -> getThingChannel(CHANNEL_DRYER_DRYING_TARGET).ifPresent(channel -> updateState(channel.getUID(),\n+                        event.getValue() == null ? UnDefType.UNDEF : new StringType(event.getValue()))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            @Nullable\n+            String operationState = getOperationState();\n+\n+            // only handle these commands if operation state allows it\n+            if (operationState != null && INACTIVE_STATE.contains(operationState)) {\n+                // set drying target option\n+                if (command instanceof StringType && CHANNEL_DRYER_DRYING_TARGET.equals(channelUID.getId())) {\n+                    getApiClient().ifPresent(apiClient -> {\n+                        try {\n+                            apiClient.setProgramOptions(getThingHaId(), OPTION_DRYER_DRYING_TARGET,\n+                                    command.toFullString(), null, false, false);\n+                        } catch (ApplianceOfflineException e) {\n+                            logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                                    command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                            updateStatus(OFFLINE);\n+                            resetChannelsOnOfflineEvent();\n+                            resetProgramStateChannels();\n+                        } catch (CommunicationException e) {\n+                            logger.debug(\"Could not handle command {}. API communication problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+                        } catch (AuthorizationException e) {\n+                            logger.debug(\"Could not handle command {}. Authorization problem! haId={}, error={}\",\n+                                    command.toFullString(), getThingHaId(), e.getMessage());\n+\n+                            handleAuthenticationError(e);\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzNTA1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                                QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n          \n          \n            \n                                QuantityType<?> quantity = (QuantityType<?>) command;", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591935053", "createdAt": "2021-03-10T23:00:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzODAzMg==", "bodyText": "If the unit is Fahrenheit, it needs to be converted to celsius by calling quantity.toUnit(CELSIUS). Keep in mind that toUnit() can return null if the unit cannot be converted.\nWhat is the purpose of the else branch? Are there any other units (beside Kelvin) which can be converted to a temperature?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591938032", "createdAt": "2021-03-10T23:06:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectFridgeFreezerHandler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REFRIGERATOR_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FREEZER_SUPER_MODE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FRIDGE_SUPER_MODE;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectFridgeFreezerHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a fridge/freezer.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectFridgeFreezerHandler extends AbstractHomeConnectThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectFridgeFreezerHandler.class);\n+\n+    public HomeConnectFridgeFreezerHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+\n+        // register fridge/freezer specific handlers\n+        handlers.put(CHANNEL_FREEZER_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSetpointTemperature(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_REFRIGERATOR_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFridgeSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_FREEZER_SUPER_MODE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFreezerSuperMode(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            return data.getValueAsBoolean() ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_FREEZER_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_FREEZER_SUPER_MODE));\n+        handlers.put(EVENT_FRIDGE_SUPER_MODE, defaultBooleanEventHandler(CHANNEL_REFRIGERATOR_SUPER_MODE));\n+\n+        // register fridge/freezer specific event handlers\n+        handlers.put(EVENT_FREEZER_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_FREEZER_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_FRIDGE_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+            Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+            try {\n+                if (apiClient.isPresent() && command instanceof QuantityType\n+                        && (CHANNEL_REFRIGERATOR_SETPOINT_TEMPERATURE.equals(channelUID.getId())\n+                                || CHANNEL_FREEZER_SETPOINT_TEMPERATURE.equals(channelUID.getId()))) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                    String value;\n+                    String unit;\n+\n+                    if (quantity.getUnit().equals(SIUnits.CELSIUS)\n+                            || quantity.getUnit().equals(ImperialUnits.FAHRENHEIT)) {\n+                        unit = quantity.getUnit().toString();\n+                        value = String.valueOf(quantity.intValue());\n+                    } else {\n+                        logger.debug(\"Converting target setpoint temperature from {}{} to \u00b0C value. thing={}, haId={}\",\n+                                quantity.intValue(), quantity.getUnit().toString(), getThingLabel(), getThingHaId());\n+                        unit = \"\u00b0C\";\n+                        value = String.valueOf(\n+                                quantity.getUnit().getConverterToAny(SIUnits.CELSIUS).convert(quantity).intValue());\n+                        logger.debug(\"{}{}\", value, unit);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTMzNg==", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n          \n          \n            \n            import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939336", "createdAt": "2021-03-10T23:09:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkzOTY0OQ==", "bodyText": "See above. from()", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591939649", "createdAt": "2021-03-10T23:09:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MDUyMQ==", "bodyText": "This seems redundant tothe dishwasher. Can you re-use the code?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591940521", "createdAt": "2021-03-10T23:11:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectHoodHandler.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_ACTIONS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_LOCAL_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_STOP;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_3;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_4;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_5;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.COMMAND_VENTING_INTENSIVE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_AMBIENT_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_FUNCTIONAL_LIGHT_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_LOCAL_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_INTENSIVE_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_HOOD_VENTING_LEVEL;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_AUTOMATIC;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_DELAYED_SHUT_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.PROGRAM_HOOD_VENTING;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_01;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_02;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_03;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_04;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_FAN_STAGE_05;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_1;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_2;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STAGE_INTENSIVE_STAGE_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_AMBIENT_LIGHT_COLOR_CUSTOM_COLOR;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_OFF;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.core.library.unit.Units.PERCENT;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectHoodHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a hood.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectHoodHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final String START_VENTING_INTENSIVE_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.IntensiveLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private static final String START_VENTING_STAGE_PAYLOAD_TEMPLATE = \"\\n\" + \"{\\n\" + \"    \\\"data\\\": {\\n\"\n+            + \"        \\\"key\\\": \\\"Cooking.Common.Program.Hood.Venting\\\",\\n\" + \"        \\\"options\\\": [\\n\"\n+            + \"            {\\n\" + \"                \\\"key\\\": \\\"Cooking.Common.Option.Hood.VentingLevel\\\",\\n\"\n+            + \"                \\\"value\\\": \\\"%s\\\"\\n\" + \"            }\\n\" + \"        ]\\n\" + \"    }\\n\" + \"}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectHoodHandler.class);\n+\n+    public HomeConnectHoodHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE, defaultLocalControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_AMBIENT_LIGHT_STATE, defaultAmbientLightChannelUpdateHandler());\n+        handlers.put(CHANNEL_FUNCTIONAL_LIGHT_STATE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getFunctionalLightState(getThingHaId());\n+                        if (data.getValue() != null) {\n+                            boolean enabled = data.getValueAsBoolean();\n+                            if (enabled) {\n+                                Data brightnessData = apiClient.get().getFunctionalLightBrightnessState(getThingHaId());\n+                                getThingChannel(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE)\n+                                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                                new QuantityType<>(brightnessData.getValueAsInt(), PERCENT)));\n+                            }\n+                            return enabled ? OnOffType.ON : OnOffType.OFF;\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                })));\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_LOCAL_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_OPERATION_STATE, defaultOperationStateEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+        handlers.put(EVENT_POWER_STATE, defaultPowerStateEventHandler());\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_FUNCTIONAL_LIGHT_STATE));\n+        handlers.put(EVENT_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_STATE, defaultBooleanEventHandler(CHANNEL_AMBIENT_LIGHT_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_BRIGHTNESS_STATE,\n+                defaultPercentEventHandler(CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE));\n+        handlers.put(EVENT_AMBIENT_LIGHT_COLOR_STATE, defaultAmbientLightColorStateEventHandler());\n+        handlers.put(EVENT_AMBIENT_LIGHT_CUSTOM_COLOR_STATE, defaultAmbientLightCustomColorStateEventHandler());\n+\n+        // register hood specific SSE event handlers\n+        handlers.put(EVENT_HOOD_INTENSIVE_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_INTENSIVE_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodIntensiveLevel = event.getValue();\n+                    if (hoodIntensiveLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodIntensiveLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+        handlers.put(EVENT_HOOD_VENTING_LEVEL,\n+                event -> getThingChannel(CHANNEL_HOOD_VENTING_LEVEL).ifPresent(channel -> {\n+                    @Nullable\n+                    String hoodVentingLevel = event.getValue();\n+                    if (hoodVentingLevel != null) {\n+                        updateState(channel.getUID(), new StringType(mapStageStringType(hoodVentingLevel)));\n+                    } else {\n+                        updateState(channel.getUID(), UnDefType.UNDEF);\n+                    }\n+                }));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    if (command instanceof OnOffType) {\n+                        if (CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                            apiClient.setPowerState(getThingHaId(),\n+                                    OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_OFF);\n+                        } else if (CHANNEL_FUNCTIONAL_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setFunctionalLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        } else if (CHANNEL_AMBIENT_LIGHT_STATE.equals(channelUID.getId())) {\n+                            apiClient.setAmbientLightState(getThingHaId(), OnOffType.ON.equals(command));\n+                        }\n+                    }\n+\n+                    if (command instanceof QuantityType) {\n+                        if (CHANNEL_FUNCTIONAL_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {\n+                            Data functionalLightState = apiClient.getFunctionalLightState(getThingHaId());\n+                            if (!functionalLightState.getValueAsBoolean()) {\n+                                // turn on\n+                                apiClient.setFunctionalLightState(getThingHaId(), true);\n+                            }\n+                            int value = ((QuantityType<?>) command).intValue();\n+                            if (value < 10) {\n+                                value = 10;\n+                            } else if (value > 100) {\n+                                value = 100;\n+                            }\n+                            apiClient.setFunctionalLightBrightnessState(getThingHaId(), value);\n+                        } else if (CHANNEL_AMBIENT_LIGHT_BRIGHTNESS_STATE.equals(channelUID.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTQyNQ==", "bodyText": "This seems to be used quite often. You could make it a global constant.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941425", "createdAt": "2021-03-10T23:13:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MTcyNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591941724", "createdAt": "2021-03-10T23:14:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjExNQ==", "bodyText": "See above. Make wildcard. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942115", "createdAt": "2021-03-10T23:15:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0MjQ1Nw==", "bodyText": "This seems to be redundant to the FridgeFreeze handler.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591942457", "createdAt": "2021-03-10T23:15:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectOvenHandler.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ACTIVE_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_PROGRAM_PROGRESS_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMAINING_PROGRAM_TIME_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_CONTROL_ACTIVE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_REMOTE_START_ALLOWANCE_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SELECTED_PROGRAM_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.CHANNEL_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ACTIVE_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DOOR_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_ELAPSED_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OPERATION_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_OVEN_CAVITY_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_POWER_STATE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_PROGRAM_PROGRESS;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMAINING_PROGRAM_TIME;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_ACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_REMOTE_CONTROL_START_ALLOWED;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SELECTED_PROGRAM;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.EVENT_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_INACTIVE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPERATION_STATE_READY;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_DURATION;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.OPTION_SETPOINT_TEMPERATURE;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_OPERATION_RUN;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_ON;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.STATE_POWER_STANDBY;\n+import static org.openhab.core.library.unit.Units.SECOND;\n+import static org.openhab.core.thing.ThingStatus.OFFLINE;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.IncommensurableException;\n+import javax.measure.UnconvertibleException;\n+import javax.measure.quantity.Temperature;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectOvenHandler} is responsible for handling commands, which are\n+ * sent to one of the channels of a oven.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectOvenHandler extends AbstractHomeConnectThingHandler {\n+\n+    private static final List<String> INACTIVE_STATE = Arrays.asList(OPERATION_STATE_INACTIVE, OPERATION_STATE_READY);\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_INITIAL_DELAY = 30;\n+    private static final int CAVITY_TEMPERATURE_SCHEDULER_PERIOD = 90;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectOvenHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> cavityTemperatureFuture;\n+    private boolean manuallyUpdateCavityTemperature;\n+\n+    public HomeConnectOvenHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing, dynamicStateDescriptionProvider);\n+        manuallyUpdateCavityTemperature = true;\n+    }\n+\n+    @Override\n+    protected void configureChannelUpdateHandlers(ConcurrentHashMap<String, ChannelUpdateHandler> handlers) {\n+        // register default update handlers\n+        handlers.put(CHANNEL_OPERATION_STATE, defaultOperationStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_POWER_STATE, defaultPowerStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_DOOR_STATE, defaultDoorStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE, defaultRemoteControlActiveStateChannelUpdateHandler());\n+        handlers.put(CHANNEL_REMOTE_START_ALLOWANCE_STATE, defaultRemoteStartAllowanceChannelUpdateHandler());\n+        handlers.put(CHANNEL_SELECTED_PROGRAM_STATE, defaultSelectedProgramStateUpdateHandler());\n+        handlers.put(CHANNEL_ACTIVE_PROGRAM_STATE, defaultActiveProgramStateUpdateHandler());\n+\n+        // register oven specific update handlers\n+        handlers.put(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE,\n+                (channelUID, cache) -> updateState(channelUID, cache.putIfAbsentAndGet(channelUID, () -> {\n+                    Optional<HomeConnectApiClient> apiClient = getApiClient();\n+                    if (apiClient.isPresent()) {\n+                        Data data = apiClient.get().getCurrentCavityTemperature(getThingHaId());\n+                        return new QuantityType<>(data.getValueAsInt(), mapTemperature(data.getUnit()));\n+                    }\n+                    return UnDefType.UNDEF;\n+                })));\n+        handlers.put(CHANNEL_SETPOINT_TEMPERATURE, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+        handlers.put(CHANNEL_DURATION, (channelUID, cache) -> {\n+            Optional<Channel> channel = getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE);\n+            if (channel.isPresent()) {\n+                defaultSelectedProgramStateUpdateHandler().handle(channel.get().getUID(), cache);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void configureEventHandlers(ConcurrentHashMap<String, EventHandler> handlers) {\n+        // register default SSE event handlers\n+        handlers.put(EVENT_DOOR_STATE, defaultDoorStateEventHandler());\n+        handlers.put(EVENT_REMOTE_CONTROL_ACTIVE, defaultBooleanEventHandler(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE));\n+        handlers.put(EVENT_REMOTE_CONTROL_START_ALLOWED,\n+                defaultBooleanEventHandler(CHANNEL_REMOTE_START_ALLOWANCE_STATE));\n+        handlers.put(EVENT_SELECTED_PROGRAM, defaultSelectedProgramStateEventHandler());\n+        handlers.put(EVENT_REMAINING_PROGRAM_TIME, defaultRemainingProgramTimeEventHandler());\n+        handlers.put(EVENT_PROGRAM_PROGRESS, defaultPercentEventHandler(CHANNEL_PROGRAM_PROGRESS_STATE));\n+        handlers.put(EVENT_ELAPSED_PROGRAM_TIME, defaultElapsedProgramTimeEventHandler());\n+        handlers.put(EVENT_ACTIVE_PROGRAM, defaultActiveProgramEventHandler());\n+\n+        // register oven specific SSE event handlers\n+        handlers.put(EVENT_OPERATION_STATE, event -> {\n+            defaultOperationStateEventHandler().handle(event);\n+            if (STATE_OPERATION_RUN.equals(event.getValue())) {\n+                manuallyUpdateCavityTemperature = true;\n+            }\n+        });\n+        handlers.put(EVENT_POWER_STATE, event -> {\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(),\n+                    STATE_POWER_ON.equals(event.getValue()) ? OnOffType.ON : OnOffType.OFF));\n+\n+            if (STATE_POWER_ON.equals(event.getValue())) {\n+                updateChannels();\n+            } else {\n+                resetProgramStateChannels();\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                        .ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_ACTIVE_PROGRAM_STATE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_SETPOINT_TEMPERATURE).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+                getThingChannel(CHANNEL_DURATION).ifPresent(c -> updateState(c.getUID(), UnDefType.UNDEF));\n+            }\n+        });\n+\n+        handlers.put(EVENT_OVEN_CAVITY_TEMPERATURE, event -> {\n+            manuallyUpdateCavityTemperature = false;\n+            getThingChannel(CHANNEL_OVEN_CURRENT_CAVITY_TEMPERATURE).ifPresent(channel -> updateState(channel.getUID(),\n+                    new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit()))));\n+        });\n+\n+        handlers.put(EVENT_SETPOINT_TEMPERATURE,\n+                event -> getThingChannel(CHANNEL_SETPOINT_TEMPERATURE)\n+                        .ifPresent(channel -> updateState(channel.getUID(),\n+                                new QuantityType<>(event.getValueAsInt(), mapTemperature(event.getUnit())))));\n+        handlers.put(EVENT_DURATION, event -> getThingChannel(CHANNEL_DURATION).ifPresent(\n+                channel -> updateState(channel.getUID(), new QuantityType<>(event.getValueAsInt(), SECOND))));\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            super.handleCommand(channelUID, command);\n+\n+            getApiClient().ifPresent(apiClient -> {\n+                try {\n+                    // turn coffee maker on and standby\n+                    if (command instanceof OnOffType && CHANNEL_POWER_STATE.equals(channelUID.getId())) {\n+                        apiClient.setPowerState(getThingHaId(),\n+                                OnOffType.ON.equals(command) ? STATE_POWER_ON : STATE_POWER_STANDBY);\n+                    }\n+\n+                    @Nullable\n+                    String operationState = getOperationState();\n+                    if (operationState != null && INACTIVE_STATE.contains(operationState)\n+                            && command instanceof QuantityType) {\n+                        // set setpoint temperature\n+                        if (CHANNEL_SETPOINT_TEMPERATURE.equals(channelUID.getId())) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            QuantityType<Temperature> quantity = ((QuantityType<Temperature>) command);\n+\n+                            try {\n+                                String value;\n+                                String unit;\n+\n+                                if (quantity.getUnit().equals(SIUnits.CELSIUS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NDg2Mg==", "bodyText": "See above. Logging to error.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591944862", "createdAt": "2021-03-10T23:21:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTE0Ng==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945146", "createdAt": "2021-03-10T23:21:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0NTM0NQ==", "bodyText": "See above. Handled by the framework.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591945345", "createdAt": "2021-03-10T23:22:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk0ODIwNw==", "bodyText": "You could make this a method to be able to re-use it. Then, you get also rid of the curly brackets at the cases.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591948207", "createdAt": "2021-03-10T23:24:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/servlet/HomeConnectServlet.java", "diffHunk": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.servlet;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.time.ZonedDateTime.now;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.handler.AbstractHomeConnectThingHandler;\n+import org.openhab.binding.homeconnect.internal.handler.HomeConnectBridgeHandler;\n+import org.openhab.core.OpenHAB;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ServiceScope;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.thymeleaf.TemplateEngine;\n+import org.thymeleaf.context.WebContext;\n+import org.thymeleaf.extras.java8time.dialect.Java8TimeDialect;\n+import org.thymeleaf.templatemode.TemplateMode;\n+import org.thymeleaf.templateresolver.ServletContextTemplateResolver;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ *\n+ * Home Connect servlet.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial Contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HomeConnectServlet.class, scope = ServiceScope.SINGLETON, immediate = true)\n+public class HomeConnectServlet extends HttpServlet {\n+\n+    private static final String SLASH = \"/\";\n+    private static final String SERVLET_NAME = \"homeconnect\";\n+    private static final String SERVLET_PATH = SLASH + SERVLET_NAME;\n+    private static final String ASSETS_PATH = SERVLET_PATH + \"/asset\";\n+    private static final String ROOT_PATH = SLASH;\n+    private static final String APPLIANCES_PATH = \"/appliances\";\n+    private static final String REQUEST_LOG_PATH = \"/log/requests\";\n+    private static final String EVENT_LOG_PATH = \"/log/events\";\n+    private static final String REQUEST_COUNT_PATH = \"/requests\";\n+    private static final String DEFAULT_CONTENT_TYPE = \"text/html; charset=UTF-8\";\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_EXPORT = \"export\";\n+    private static final String PARAM_ACTION = \"action\";\n+    private static final String PARAM_BRIDGE_ID = \"bridgeId\";\n+    private static final String PARAM_THING_ID = \"thingId\";\n+    private static final String PARAM_PATH = \"path\";\n+    private static final String ACTION_AUTHORIZE = \"authorize\";\n+    private static final String ACTION_CLEAR_CREDENTIALS = \"clearCredentials\";\n+    private static final String ACTION_SHOW_DETAILS = \"show-details\";\n+    private static final String ACTION_ALL_PROGRAMS = \"all-programs\";\n+    private static final String ACTION_AVAILABLE_PROGRAMS = \"available-programs\";\n+    private static final String ACTION_SELECTED_PROGRAM = \"selected-program\";\n+    private static final String ACTION_ACTIVE_PROGRAM = \"active-program\";\n+    private static final String ACTION_OPERATION_STATE = \"operation-state\";\n+    private static final String ACTION_POWER_STATE = \"power-state\";\n+    private static final String ACTION_DOOR_STATE = \"door-state\";\n+    private static final String ACTION_REMOTE_START_ALLOWED = \"remote-control-start-allowed\";\n+    private static final String ACTION_REMOTE_CONTROL_ACTIVE = \"remote-control-active\";\n+    private static final String ACTION_PUT_RAW = \"put-raw\";\n+    private static final String ACTION_GET_RAW = \"get-raw\";\n+    private static final DateTimeFormatter FILE_EXPORT_DTF = DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm\");\n+    private static final long serialVersionUID = -2449763690208703307L;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectServlet.class);\n+    private final HttpService httpService;\n+    private final TemplateEngine templateEngine;\n+    private final Set<HomeConnectBridgeHandler> bridgeHandlers;\n+    private final Gson gson;\n+\n+    @Activate\n+    public HomeConnectServlet(@Reference HttpService httpService) {\n+        bridgeHandlers = new CopyOnWriteArraySet<>();\n+        gson = new GsonBuilder().registerTypeAdapter(ZonedDateTime.class, (JsonSerializer<ZonedDateTime>) (src,\n+                typeOfSrc, context) -> new JsonPrimitive(src.format(DateTimeFormatter.ISO_DATE_TIME))).create();\n+        this.httpService = httpService;\n+\n+        // register servlet\n+        try {\n+            logger.info(\"Initialize Home Connect configuration servlet ({})\", SERVLET_PATH);\n+            httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+            httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+        } catch (NamespaceException e) {\n+            try {\n+                httpService.unregister(SERVLET_PATH);\n+                httpService.unregister(ASSETS_PATH);\n+                httpService.registerServlet(SERVLET_PATH, this, null, httpService.createDefaultHttpContext());\n+                httpService.registerResources(ASSETS_PATH, \"assets\", null);\n+            } catch (ServletException | NamespaceException ex) {\n+                logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, ex);\n+            }\n+        } catch (ServletException e) {\n+            logger.error(\"Could not register Home Connect servlet! ({})\", SERVLET_PATH, e);\n+        }\n+\n+        // setup template engine\n+        ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(getServletContext());\n+        templateResolver.setTemplateMode(TemplateMode.HTML);\n+        templateResolver.setPrefix(\"/templates/\");\n+        templateResolver.setSuffix(\".html\");\n+        templateResolver.setCacheable(true);\n+        templateEngine = new TemplateEngine();\n+        templateEngine.addDialect(new Java8TimeDialect());\n+        templateEngine.setTemplateResolver(templateResolver);\n+    }\n+\n+    @Deactivate\n+    protected void dispose() {\n+        try {\n+            logger.info(\"Unregister Home Connect configuration servlet ({}).\", SERVLET_PATH);\n+            httpService.unregister(SERVLET_PATH);\n+            httpService.unregister(ASSETS_PATH);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Could not unregister Home Connect servlet. Failed wth {}\", e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(DEFAULT_CONTENT_TYPE);\n+        response.setCharacterEncoding(UTF_8.name());\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            @Nullable\n+            String code = request.getParameter(PARAM_CODE);\n+            @Nullable\n+            String state = request.getParameter(PARAM_STATE);\n+            if (code != null && state != null && !code.trim().isEmpty() && !state.trim().isEmpty()) {\n+                getBridgeAuthenticationPage(request, response, code, state);\n+            } else {\n+                getBridgesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_COUNT_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (action != null && bridgeId != null && !action.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getApiRequestsPerSecondCsv(response, bridgeId);\n+            } else {\n+                getRequestCountPage(request, response);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            if (action != null && thingId != null && !action.trim().isEmpty() && !thingId.trim().isEmpty()) {\n+                processApplianceActions(response, action, thingId);\n+            } else {\n+                getAppliancesPage(request, response);\n+            }\n+        } else if (pathMatches(path, REQUEST_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getRequestLogExport(response, bridgeId);\n+            } else {\n+                getRequestLogPage(request, response);\n+            }\n+        } else if (pathMatches(path, EVENT_LOG_PATH)) {\n+            @Nullable\n+            String export = request.getParameter(PARAM_EXPORT);\n+            @Nullable\n+            String bridgeId = request.getParameter(PARAM_BRIDGE_ID);\n+            if (export != null && bridgeId != null && !export.trim().isEmpty() && !bridgeId.trim().isEmpty()) {\n+                getEventLogExport(response, bridgeId);\n+            } else {\n+                getEventLogPage(request, response);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws IOException {\n+        if (request == null || response == null) {\n+            return;\n+        }\n+        response.setContentType(\"text/html; charset=UTF-8\");\n+        response.setCharacterEncoding(\"UTF-8\");\n+\n+        String path = request.getPathInfo();\n+        if (path == null || path.isEmpty() || path.equals(ROOT_PATH)) {\n+            if (request.getParameter(PARAM_ACTION) != null && request.getParameter(PARAM_BRIDGE_ID) != null) {\n+                postBridgesPage(request, response);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else if (pathMatches(path, APPLIANCES_PATH)) {\n+            String requestPayload = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+            @Nullable\n+            String action = request.getParameter(PARAM_ACTION);\n+            @Nullable\n+            String thingId = request.getParameter(PARAM_THING_ID);\n+            @Nullable\n+            String targetPath = request.getParameter(PARAM_PATH);\n+\n+            if ((ACTION_PUT_RAW.equals(action) || ACTION_GET_RAW.equals(action)) && thingId != null\n+                    && targetPath != null && action != null) {\n+                processRawApplianceActions(response, action, thingId, targetPath, requestPayload);\n+            } else {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+            }\n+        } else {\n+            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n+        }\n+    }\n+\n+    /**\n+     * Add Home Connect bridge handler to configuration servlet, to allow user to authenticate against Home Connect API.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void addBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.add(bridgeHandler);\n+    }\n+\n+    /**\n+     * Remove Home Connect bridge handler from configuration servlet.\n+     *\n+     * @param bridgeHandler bridge handler\n+     */\n+    public void removeBridgeHandler(HomeConnectBridgeHandler bridgeHandler) {\n+        bridgeHandlers.remove(bridgeHandler);\n+    }\n+\n+    private void getRequestCountPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        if (bridgeHandlers.isEmpty()) {\n+            getBridgesPage(request, response);\n+        } else {\n+            WebContext context = new WebContext(request, response, request.getServletContext());\n+            context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+            templateEngine.process(\"requests\", context, response.getWriter());\n+        }\n+    }\n+\n+    private void getApiRequestsPerSecondCsv(HttpServletResponse response, String bridgeId) throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandler(bridgeId);\n+        if (bridgeHandler.isPresent()) {\n+            response.setContentType(\"text/csv\");\n+            PrintWriter writer = response.getWriter();\n+\n+            writer.println(String.format(\"%s,%s\", \"time\", \"requests\"));\n+            bridgeHandler.get().getApiClient().getLatestApiRequests().forEach(apiRequest -> writer.println(\n+                    String.format(\"%s,%s\", apiRequest.getTime().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME), 1)));\n+        } else {\n+            response.sendError(HttpStatus.BAD_REQUEST_400, \"Unknown bridge\");\n+        }\n+    }\n+\n+    private void getAppliancesPage(HttpServletRequest request, HttpServletResponse response) throws IOException {\n+        WebContext context = new WebContext(request, response, request.getServletContext());\n+        context.setVariable(\"bridgeHandlers\", bridgeHandlers);\n+        templateEngine.process(\"appliances\", context, response.getWriter());\n+    }\n+\n+    private void processApplianceActions(HttpServletResponse response, String action, String thingId)\n+            throws IOException {\n+        Optional<HomeConnectBridgeHandler> bridgeHandler = getBridgeHandlerForThing(thingId);\n+        Optional<AbstractHomeConnectThingHandler> thingHandler = getThingHandler(thingId);\n+\n+        if (bridgeHandler.isPresent() && thingHandler.isPresent()) {\n+            try {\n+                response.setContentType(MediaType.APPLICATION_JSON);\n+                String haId = thingHandler.get().getThingHaId();\n+\n+                switch (action) {\n+                    case ACTION_SHOW_DETAILS: {\n+                        @Nullable\n+                        String actionResponse = bridgeHandler.get().getApiClient().getRaw(haId,\n+                                \"/api/homeappliances/\" + haId);\n+                        response.getWriter().write(actionResponse != null ? actionResponse : \"{}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1MzU5MQ==", "bodyText": "Could you be a bit more verbose, so that somebody who hasn't heard about it gets a clue what this is about?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591953591", "createdAt": "2021-03-10T23:29:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"homeconnect\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Home Connect Binding</name>\n+\t<description>This is the binding for Home Connect.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1Mzc1NA==", "bodyText": "Please remove this empty line.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591953754", "createdAt": "2021-03-10T23:30:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"homeconnect\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Home Connect Binding</name>\n+\t<description>This is the binding for Home Connect.</description>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1Mzk5MA==", "bodyText": "Words in labels should be capitalized (except prepositions and so on). See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591953990", "createdAt": "2021-03-10T23:30:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,676 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1NDcwMA==", "bodyText": "There are predefined system channel types. https://www.openhab.org/docs/developer/bindings/thing-xml.html#system-state-channel-types This could be system.power.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591954700", "createdAt": "2021-03-10T23:32:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,676 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1NjE2OQ==", "bodyText": "Can you fix the line break?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591956169", "createdAt": "2021-03-10T23:36:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,676 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_freezer\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Freezer super mode</label>\n+\t\t<description>This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the home appliance because of\n+\t\t\ta\n+\t\t\ttimeout.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1NjUwNA==", "bodyText": "Are the spaces intentional?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color1\"> Color 1</option>\n          \n          \n            \n            \t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color1\">Color 1</option>", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591956504", "createdAt": "2021-03-10T23:37:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,676 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_freezer\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Freezer super mode</label>\n+\t\t<description>This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the home appliance because of\n+\t\t\ta\n+\t\t\ttimeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"dryer_drying_target\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Drying target</label>\n+\t\t<description>Specifies the desired dryness setting.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_venting_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Venting level</label>\n+\t\t<description>Current venting level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_intensive_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Intensive level</label>\n+\t\t<description>Current venting intensive level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<description>Start hood program.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Functional light state</label>\n+\t\t<description>This setting describes the current functional light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Functional light brightness</label>\n+\t\t<description>This setting describes the brightness state of the functional light.</description>\n+\t\t<state readOnly=\"false\" min=\"10\" max=\"100\" step=\"1\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Ambient light state</label>\n+\t\t<description>This setting describes the current ambient light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Ambient light brightness</label>\n+\t\t<description>This setting describes the brightness state of the ambient light.</description>\n+\t\t<state readOnly=\"false\" min=\"10\" max=\"100\" step=\"1\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_color_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Ambient light color</label>\n+\t\t<description>This setting describes the color state of the ambient light.</description>\n+\t\t<state readOnly=\"false\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.CustomColor\">Custom Color</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color1\"> Color 1</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTk1NjY5NA==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r591956694", "createdAt": "2021-03-10T23:37:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,676 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"homeconnect\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Home Connect API Bridge -->\n+\t<bridge-type id=\"api_bridge\">\n+\t\t<label>Home Connect API</label>\n+\t\t<description>This bridge represents the gateway to the Home Connect API.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"clientId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client id</label>\n+\t\t\t\t<description>Application client id</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"clientSecret\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Client secret</label>\n+\t\t\t\t<description>Application client secret</description>\n+\t\t\t\t<context>password</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"simulator\" type=\"boolean\" required=\"true\">\n+\t\t\t\t<label>Use simulator environment</label>\n+\t\t\t\t<description>Use simulated environment at https://developer.home-connect.com/simulator/</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Dishwasher -->\n+\t<thing-type id=\"dishwasher\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dishwasher</label>\n+\t\t<description>Home Connect connected dishwasher (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Oven -->\n+\t<thing-type id=\"oven\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Oven</label>\n+\t\t<description>Home Connect connected oven (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature\" typeId=\"setpoint_temperature\"/>\n+\t\t\t<channel id=\"duration\" typeId=\"duration\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"oven_current_cavity_temperature\" typeId=\"oven_current_cavity_temperature\"/>\n+\t\t\t<channel id=\"elapsed_program_time\" typeId=\"elapsed_program_time\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer -->\n+\t<thing-type id=\"washer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer</label>\n+\t\t<description>Home Connect connected washing machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos1\" typeId=\"laundry_care_washer_idos1\"/>\n+\t\t\t<channel id=\"laundry_care_washer_idos2\" typeId=\"laundry_care_washer_idos2\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Washer dryer combination -->\n+\t<thing-type id=\"washerdryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Washer Dryer combination</label>\n+\t\t<description>Home Connect connected combined washer dryer appliance.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"laundry_care_washer_temperature\" typeId=\"laundry_care_washer_temperature\"/>\n+\t\t\t<channel id=\"laundry_care_washer_spin_speed\" typeId=\"laundry_care_washer_spin_speed\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Dryer -->\n+\t<thing-type id=\"dryer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Dryer</label>\n+\t\t<description>Home Connect connected dryer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"dryer_drying_target\" typeId=\"dryer_drying_target\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"remaining_program_time_state\" typeId=\"remaining_program_time_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Fridge Freezer -->\n+\t<thing-type id=\"fridgefreezer\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Refrigerator / Freezer</label>\n+\t\t<description>Home Connect connected refrigerator/freezer (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"door_state\" typeId=\"door_state\"/>\n+\t\t\t<channel id=\"setpoint_temperature_refrigerator\" typeId=\"setpoint_temperature_refrigerator\"/>\n+\t\t\t<channel id=\"super_mode_refrigerator\" typeId=\"super_mode_refrigerator\"/>\n+\t\t\t<channel id=\"setpoint_temperature_freezer\" typeId=\"setpoint_temperature_freezer\"/>\n+\t\t\t<channel id=\"super_mode_freezer\" typeId=\"super_mode_freezer\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Coffee Machine -->\n+\t<thing-type id=\"coffeemaker\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Coffee Machine</label>\n+\t\t<description>Home Connect connected coffee machine (e.g. Bosch or Siemens).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t\t<channel id=\"basic_actions_state\" typeId=\"basic_actions_state\"/>\n+\t\t\t<channel id=\"program_progress_state\" typeId=\"program_progress_state\"/>\n+\t\t\t<channel id=\"coffeemaker_drip_tray_full_state\" typeId=\"coffeemaker_drip_tray_full_state\"/>\n+\t\t\t<channel id=\"coffeemaker_water_tank_empty_state\" typeId=\"coffeemaker_water_tank_empty_state\"/>\n+\t\t\t<channel id=\"coffeemaker_bean_container_empty_state\" typeId=\"coffeemaker_bean_container_empty_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Hood -->\n+\t<thing-type id=\"hood\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Hood</label>\n+\t\t<description>Home Connect connected kitchen hood.</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_start_allowance_state\" typeId=\"remote_start_allowance_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"hood_venting_level\" typeId=\"hood_venting_level\"/>\n+\t\t\t<channel id=\"hood_intensive_level\" typeId=\"hood_intensive_level\"/>\n+\t\t\t<channel id=\"hood_program_state\" typeId=\"hood_program_state\"/>\n+\t\t\t<channel id=\"ambient_light_state\" typeId=\"ambient_light_state\"/>\n+\t\t\t<channel id=\"ambient_light_brightness_state\" typeId=\"ambient_light_brightness_state\"/>\n+\t\t\t<channel id=\"ambient_light_color_state\" typeId=\"ambient_light_color_state\"/>\n+\t\t\t<channel id=\"ambient_light_custom_color_state\" typeId=\"ambient_light_custom_color_state\"/>\n+\t\t\t<channel id=\"functional_light_state\" typeId=\"functional_light_state\"/>\n+\t\t\t<channel id=\"functional_light_brightness_state\" typeId=\"functional_light_brightness_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Cooktop -->\n+\t<thing-type id=\"hob\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"api_bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Cooktop</label>\n+\t\t<description>Home Connect connected kitchen cooktop (hob).</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"power_state\" typeId=\"power_state\"/>\n+\t\t\t<channel id=\"operation_state\" typeId=\"operation_state\"/>\n+\t\t\t<channel id=\"remote_control_active_state\" typeId=\"remote_control_active_state\"/>\n+\t\t\t<channel id=\"local_control_active_state\" typeId=\"local_control_active_state\"/>\n+\t\t\t<channel id=\"active_program_state\" typeId=\"active_program_state\"/>\n+\t\t\t<channel id=\"selected_program_state\" typeId=\"selected_program_state\"/>\n+\t\t</channels>\n+\t\t<representation-property>haId</representation-property>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"haId\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>haId</label>\n+\t\t\t\t<description>Unique identifier representing a specific home appliance.</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Channel types -->\n+\t<channel-type id=\"basic_actions_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"start\">Start program</option>\n+\t\t\t\t<option value=\"stop\">Stop program</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"power_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Power State</label>\n+\t\t<description>This setting describes the current power state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"local_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Local Control State</label>\n+\t\t<description>This status indicates whether the home appliance is currently manually controlled by the user operating\n+\t\t\tthe home appliance, e.g. opening the door or pressing a button.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_drip_tray_full_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Drip Tray Full</label>\n+\t\t<description>Is coffee maker drip tray full?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_water_tank_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Water Tank Empty</label>\n+\t\t<description>Is coffee maker water tank empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"coffeemaker_bean_container_empty_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Bean Container Empty</label>\n+\t\t<description>Is coffee maker bean container is empty?</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"door_state\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Door State</label>\n+\t\t<description>This status describes the door state of a home appliance. A status change is either triggered by the user\n+\t\t\toperating the home appliance locally (i.e. opening/closing door) or automatically by the home appliance (i.e. locking\n+\t\t\tthe door).</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"operation_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Operation State</label>\n+\t\t<description>This status describes the operation state of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_start_allowance_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Start Allowance State</label>\n+\t\t<description>This status indicates whether the remote program start is enabled. This can happen due to a programmatic\n+\t\t\tchange (only disabling), or manually by the user changing the flag locally on the home appliance, or automatically\n+\t\t\tafter a certain duration - usually 24 hours.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"remote_control_active_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Remote Control Activation State</label>\n+\t\t<description>This status indicates whether the allowance for remote controlling is enabled.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"active_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Active Program</label>\n+\t\t<description>This status describes the active program of the home appliance.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"selected_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Selected Program</label>\n+\t\t<description>This state describes the selected program of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"remaining_program_time_state\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Remaining program time</label>\n+\t\t<description>This status indicates the remaining program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"program_progress_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Progress State</label>\n+\t\t<description>This status describes the program progress of the home appliance.</description>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"oven_current_cavity_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Cavity Temperature</label>\n+\t\t<description>This status describes the oven cavity temperature of the home appliance.</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"elapsed_program_time\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Elapsed Program Time</label>\n+\t\t<description>This status describes the elapsed program time of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<description>This status describes the intended cooking compartment temperature of the home appliance.</description>\n+\t\t<state pattern=\"%.0f %unit%\" step=\"1\"/>\n+\t</channel-type>\n+\t<channel-type id=\"duration\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Selected duration</label>\n+\t\t<description>This status describes the duration of the program of the home appliance.</description>\n+\t\t<state pattern=\"%d %unit%\" step=\"60\" min=\"60\"/>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_temperature\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Washing Program Temperature</label>\n+\t\t<description>This status describes the temperature of the washing program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Cold\">Cold water</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC20\">20 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC30\">30 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC40\">40 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC50\">50 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC60\">60 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC70\">70 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC80\">80 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.GC90\">90 \u00b0C</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlCold\">Cold (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlWarm\">Warm (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlHot\">Hot (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.Temperature.UlExtraHot\">Extra hot (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_spin_speed\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Spin Speed</label>\n+\t\t<description>This status defines the spin speed of a washer program of the home appliance.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Off\">No spinning</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM400\">400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM600\">600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM800\">800 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1000\">1000 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1200\">1200 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1400\">1400 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.RPM1600\">1600 rpm</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.Auto\">Auto</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlNo\">No spinning (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlLow\">Low (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlMedium\">Medium (US/CA)</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.SpinSpeed.UlHigh\">High (US/CA)</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 1 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"laundry_care_washer_idos2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>i-Dos 2 dosing level</label>\n+\t\t<description>This status defines the i-Dos dosing level of a washer program of the home appliance. (If appliance\n+\t\t\tsupports i-Dos)</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Off\">Off</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Light\">Light</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Normal\">Normal</option>\n+\t\t\t\t<option value=\"LaundryCare.Washer.EnumType.IDosingLevel.Strong\">Strong</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_refrigerator\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Refrigerator temperature</label>\n+\t\t<description>Target temperature of the refrigerator compartment (Range depends on appliance - common range 2 to 8\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"setpoint_temperature_freezer\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Freezer temperature</label>\n+\t\t<description>Target temperature of the freezer compartment (Range depends on appliance - common range -16 to -24\u00b0C).</description>\n+\t\t<state step=\"1\" pattern=\"%.0f %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_refrigerator\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Refrigerator super mode</label>\n+\t\t<description>The setting has no impact on setpoint temperatures but will make the fridge compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the HA because of a timeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"super_mode_freezer\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Freezer super mode</label>\n+\t\t<description>This setting has no impact on setpoint temperatures but will make the freezer compartment cool to the\n+\t\t\tlowest possible temperature until it is disabled manually by the customer or by the home appliance because of\n+\t\t\ta\n+\t\t\ttimeout.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"dryer_drying_target\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Drying target</label>\n+\t\t<description>Specifies the desired dryness setting.</description>\n+\t\t<state readOnly=\"false\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_venting_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Venting level</label>\n+\t\t<description>Current venting level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_intensive_level\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Intensive level</label>\n+\t\t<description>Current venting intensive level of the hood.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\t<channel-type id=\"hood_program_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Program actions</label>\n+\t\t<description>Start hood program.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Functional light state</label>\n+\t\t<description>This setting describes the current functional light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"functional_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Functional light brightness</label>\n+\t\t<description>This setting describes the brightness state of the functional light.</description>\n+\t\t<state readOnly=\"false\" min=\"10\" max=\"100\" step=\"1\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_state\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Ambient light state</label>\n+\t\t<description>This setting describes the current ambient light state of the home appliance.</description>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_brightness_state\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Ambient light brightness</label>\n+\t\t<description>This setting describes the brightness state of the ambient light.</description>\n+\t\t<state readOnly=\"false\" min=\"10\" max=\"100\" step=\"1\" pattern=\"%d %unit%\"/>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_color_state\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Ambient light color</label>\n+\t\t<description>This setting describes the color state of the ambient light.</description>\n+\t\t<state readOnly=\"false\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.CustomColor\">Custom Color</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color1\"> Color 1</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color2\"> Color 2</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color3\"> Color 3</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color4\"> Color 4</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color5\"> Color 5</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color6\"> Color 6</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color7\"> Color 7</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color8\"> Color 8</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color9\"> Color 9</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color10\"> Color 10</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color11\"> Color 11</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color12\"> Color 12</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color13\"> Color 13</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color14\"> Color 14</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color15\"> Color 15</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color16\"> Color 16</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color17\"> Color 17</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color18\"> Color 18</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color19\"> Color 19</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color20\"> Color 20</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color21\"> Color 21</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color22\"> Color 22</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color23\"> Color 23</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color24\"> Color 24</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color25\"> Color 25</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color26\"> Color 26</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color27\"> Color 27</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color28\"> Color 28</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color29\"> Color 29</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color30\"> Color 30</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color31\"> Color 31</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color32\"> Color 32</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color33\"> Color 33</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color34\"> Color 34</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color35\"> Color 35</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color36\"> Color 36</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color37\"> Color 37</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color38\"> Color 38</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color39\"> Color 39</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color40\"> Color 40</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color41\"> Color 41</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color42\"> Color 42</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color43\"> Color 43</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color44\"> Color 44</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color45\"> Color 45</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color46\"> Color 46</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color47\"> Color 47</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color48\"> Color 48</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color49\"> Color 49</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color50\"> Color 50</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color51\"> Color 51</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color52\"> Color 52</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color53\"> Color 53</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color54\"> Color 54</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color55\"> Color 55</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color56\"> Color 56</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color57\"> Color 57</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color58\"> Color 58</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color59\"> Color 59</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color60\"> Color 60</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color61\"> Color 61</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color62\"> Color 62</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color63\"> Color 63</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color64\"> Color 64</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color65\"> Color 65</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color66\"> Color 66</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color67\"> Color 67</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color68\"> Color 68</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color69\"> Color 69</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color70\"> Color 70</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color71\"> Color 71</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color72\"> Color 72</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color73\"> Color 73</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color74\"> Color 74</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color75\"> Color 75</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color76\"> Color 76</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color77\"> Color 77</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color78\"> Color 78</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color79\"> Color 79</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color80\"> Color 80</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color81\"> Color 81</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color82\"> Color 82</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color83\"> Color 83</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color84\"> Color 84</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color85\"> Color 85</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color86\"> Color 86</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color87\"> Color 87</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color88\"> Color 88</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color89\"> Color 89</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color90\"> Color 90</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color91\"> Color 91</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color92\"> Color 92</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color93\"> Color 93</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color94\"> Color 94</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color95\"> Color 95</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color96\"> Color 96</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color97\"> Color 97</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color98\"> Color 98</option>\n+\t\t\t\t<option value=\"BSH.Common.EnumType.AmbientLightColor.Color99\"> Color 99</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"ambient_light_custom_color_state\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Ambient light custom color</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 668}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99a885c0f4f259799b926c24a5ce225be73d5402", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/99a885c0f4f259799b926c24a5ce225be73d5402", "committedDate": "2021-03-12T15:07:54Z", "message": "Revert \"Merge branch 'main' into 3.0.x-homeconnect-release\"\n\nThis reverts commit fbcd3c909ca3a62e5234d2dfb52c719e8514742b, reversing\nchanges made to a937ed466d3ed5dbd10d33141012342d8f76d892."}, "afterCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/61c803d47eb79e1579e7962736369b3c0d9dbd99", "committedDate": "2021-03-08T17:33:12Z", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNTg2MjMy", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-611586232", "createdAt": "2021-03-13T10:28:00Z", "commit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xM1QxMDoyODowMFrOI2OmcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xM1QxMDoyODowMFrOI2OmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzczMzIzMw==", "bodyText": "1:12 - 'Chart' is defined but never used. (no-unused-vars)\n25:27 - There should be no space after this paren. (space-in-parens)\n25:91 - Missing space before function parentheses. (space-before-function-paren)\n26:57 - A space is required after ','. (comma-spacing)\n26:62 - A space is required after ','. (comma-spacing)\n28:28 - Missing space before function parentheses. (space-before-function-paren)\n29:57 - A space is required after ','. (comma-spacing)\n29:62 - A space is required after ','. (comma-spacing)\n31:30 - Missing space before function parentheses. (space-before-function-paren)\n55:30 - Missing space before function parentheses. (space-before-function-paren)\n57:32 - There should be no space after this paren. (space-in-parens)\n58:1 - Expected indentation of 16 spaces but found 32. (indent)\n58:58 - Missing space before function parentheses. (space-before-function-paren)\n59:1 - Expected indentation of 20 spaces but found 16. (indent)\n59:61 - A space is required after ','. (comma-spacing)\n59:66 - A space is required after ','. (comma-spacing)\n60:1 - Expected indentation of 20 spaces but found 16. (indent)\n61:1 - Expected indentation of 16 spaces but found 12. (indent)\n62:32 - Missing space before function parentheses. (space-before-function-paren)\n63:61 - A space is required after ','. (comma-spacing)\n63:66 - A space is required after ','. (comma-spacing)\n66:34 - Missing space before function parentheses. (space-before-function-paren)\n90:30 - Missing space before function parentheses. (space-before-function-paren)\n92:32 - There should be no space after this paren. (space-in-parens)\n92:118 - Missing space before function parentheses. (space-before-function-paren)\n93:1 - Expected indentation of 16 spaces but found 20. (indent)\n93:65 - A space is required after ','. (comma-spacing)\n93:70 - A space is required after ','. (comma-spacing)\n94:1 - Expected indentation of 16 spaces but found 20. (indent)\n95:1 - Expected indentation of 12 spaces but found 16. (indent)\n96:32 - Missing space before function parentheses. (space-before-function-paren)\n97:61 - A space is required after ','. (comma-spacing)\n97:66 - A space is required after ','. (comma-spacing)\n100:34 - Missing space before function parentheses. (space-before-function-paren)\n163:38 - Missing space before function parentheses. (space-before-function-paren)\n167:26 - Missing space before function parentheses. (space-before-function-paren)\n173:29 - Missing space before function parentheses. (space-before-function-paren)\n179:24 - There should be no space after this paren. (space-in-parens)\n179:36 - There should be no space before this paren. (space-in-parens)\n180:24 - There should be no space after this paren. (space-in-parens)\n180:40 - There should be no space before this paren. (space-in-parens)\n182:25 - There should be no space after this paren. (space-in-parens)\n182:29 - A space is required after ','. (comma-spacing)\n182:36 - A space is required after ','. (comma-spacing)\n182:44 - A space is required after ','. (comma-spacing)\n182:62 - There should be no space before this paren. (space-in-parens)\n183:24 - There should be no space after this paren. (space-in-parens)\n183:62 - There should be no space before this paren. (space-in-parens)\n186:28 - Missing space before function parentheses. (space-before-function-paren)\n186:29 - There should be no space after this paren. (space-in-parens)\n186:68 - There should be no space before this paren. (space-in-parens)\n198:1 - Expected indentation of 16 spaces but found 27. (indent)\n199:1 - Expected indentation of 20 spaces but found 31. (indent)\n200:1 - Expected indentation of 24 spaces but found 35. (indent)\n201:1 - Expected indentation of 24 spaces but found 35. (indent)\n202:1 - Expected indentation of 24 spaces but found 35. (indent)\n203:1 - Expected indentation of 24 spaces but found 35. (indent)\n204:1 - Expected indentation of 20 spaces but found 31. (indent)\n205:1 - Expected indentation of 20 spaces but found 31. (indent)\n206:1 - Expected indentation of 24 spaces but found 35. (indent)\n207:1 - Expected indentation of 24 spaces but found 35. (indent)\n208:1 - Expected indentation of 20 spaces but found 31. (indent)\n209:1 - Expected indentation of 16 spaces but found 27. (indent)\n210:1 - Expected indentation of 16 spaces but found 27. (indent)\n211:1 - Expected indentation of 20 spaces but found 31. (indent)\n212:1 - Expected indentation of 20 spaces but found 31. (indent)\n213:1 - Expected indentation of 16 spaces but found 27. (indent)\n214:10 - Unnecessary semicolon. (no-extra-semi)", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r593733233", "createdAt": "2021-03-13T10:28:00Z", "author": {"login": "ghys"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/resources/assets/js/homeconnect.js", "diffHunk": "@@ -0,0 +1,218 @@\n+/* globals Chart:false, feather:false */\n+\n+(function () {\n+    'use strict'\n+\n+    feather.replace();\n+\n+    $(\".redirectUri\").text(window.location.href.substring(0, window.location.href.lastIndexOf('/homeconnect') + 12));\n+\n+    $('#apiDetailModal').on('show.bs.modal', function (event) {\n+        var button = $(event.relatedTarget);\n+        var thingId = button.data('thing-id');\n+        var action = button.data('api-action');\n+        var titleText = button.data('title');\n+        var modal = $(this);\n+        var title = modal.find('.modal-title');\n+        var subTitle = modal.find('.modal-subtitle');\n+        var responseBodyElement = modal.find('.modal-response-body');\n+\n+        responseBodyElement.text('Loading...');\n+        title.text(titleText);\n+        subTitle.text(thingId);\n+        modal.modal('handleUpdate');\n+\n+        let jqxhr = $.get( 'appliances?thingId=' + thingId + '&action=' + action, function(data) {\n+            responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+        });\n+        jqxhr.fail(function(data) {\n+            responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+        })\n+        jqxhr.always(function() {\n+            modal.modal('handleUpdate');\n+        });\n+    })\n+\n+    $('#rawCommandDetailModal').on('show.bs.modal', function (event) {\n+        var button = $(event.relatedTarget);\n+        var thingId = button.data('thing-id');\n+        var haId = button.data('ha-id');\n+\n+        var modal = $(this);\n+        var subTitle = modal.find('.modal-subtitle');\n+        var inputPath = modal.find('#raw-path');\n+        var inputBody = modal.find('#raw-request-body');\n+        var submit = modal.find('#raw-submit');\n+        var responseBodyElement = modal.find('.modal-response-body');\n+        var responseTitle = modal.find('.raw-response-header');\n+\n+        subTitle.text(thingId);\n+        responseBodyElement.text('');\n+        responseTitle.hide();\n+        inputPath.val('/api/homeappliances/' + haId + '/programs/active')\n+        modal.modal('handleUpdate');\n+\n+        submit.click(function() {\n+            responseBodyElement.text('Loading...');\n+            let jqxhr = $.post( 'appliances?thingId=' + thingId + '&action=put-raw&path=' + inputPath.val(),\n+                                inputBody.val(), function(data) {\n+                responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+                responseTitle.show();\n+            });\n+            jqxhr.fail(function(data) {\n+                responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+                responseTitle.show();\n+            })\n+            jqxhr.always(function() {\n+                modal.modal('handleUpdate');\n+            });\n+        });\n+    })\n+\n+    $('#rawGetDetailModal').on('show.bs.modal', function (event) {\n+        var button = $(event.relatedTarget);\n+        var thingId = button.data('thing-id');\n+        var haId = button.data('ha-id');\n+\n+        var modal = $(this);\n+        var subTitle = modal.find('.modal-subtitle');\n+        var inputPath = modal.find('#raw-get-path');\n+        var submit = modal.find('#raw-get-submit');\n+        var responseBodyElement = modal.find('.modal-response-body');\n+        var responseTitle = modal.find('.raw-response-header');\n+\n+        subTitle.text(thingId);\n+        responseBodyElement.text('');\n+        responseTitle.hide();\n+        inputPath.val('/api/homeappliances/' + haId + '/programs')\n+        modal.modal('handleUpdate');\n+\n+        submit.click(function() {\n+            responseBodyElement.text('Loading...');\n+            let jqxhr = $.post( 'appliances?thingId=' + thingId + '&action=get-raw&path=' + inputPath.val(), function(data) {\n+                    responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+                    responseTitle.show();\n+                });\n+            jqxhr.fail(function(data) {\n+                responseBodyElement.text(JSON.stringify(data,null,'\\t'));\n+                responseTitle.show();\n+            })\n+            jqxhr.always(function() {\n+                modal.modal('handleUpdate');\n+            });\n+        });\n+    })\n+\n+    $('#requestDetailModal').on('show.bs.modal', function (event) {\n+        var button = $(event.relatedTarget);\n+        var requestId = button.data('request-id');\n+        var request = requests.find(item => item.id == requestId);\n+        var requestHeader = request.homeConnectRequest.header;\n+        var requestBody = request.homeConnectRequest.body;\n+        var modal = $(this);\n+        var requestBodyElement = modal.find('.modal-request-body');\n+        var title = modal.find('.modal-title');\n+        var responseBodyElement = modal.find('.modal-response-body');\n+        var requestHeaderElement = modal.find('.modal-request-header');\n+        var responseHeaderElement = modal.find('.modal-response-header');\n+\n+        title.text(request.homeConnectRequest.method + ' ' + request.homeConnectRequest.url);\n+\n+        if (requestBody) {\n+            requestBodyElement.text(requestBody);\n+            requestBodyElement.removeClass('text-muted')\n+        } else {\n+            requestBodyElement.text('Empty request body');\n+            requestBodyElement.addClass('text-muted')\n+        }\n+\n+        if (request.homeConnectResponse && request.homeConnectResponse.body) {\n+            responseBodyElement.text(request.homeConnectResponse.body);\n+            responseBodyElement.removeClass('text-muted')\n+        } else {\n+            responseBodyElement.text('Empty response body');\n+            responseBodyElement.addClass('text-muted')\n+        }\n+\n+        responseHeaderElement.empty();\n+        if (request.homeConnectResponse && request.homeConnectResponse.header) {\n+            var responseHeader = request.homeConnectResponse.header;\n+            Object.keys(responseHeader).forEach(key => {\n+                console.log(`key=${key}  value=${responseHeader[key]}`);\n+                responseHeaderElement.append($(`<dt class=\"col-sm-4\">${key}</dt>`));\n+                responseHeaderElement.append($(`<dd class=\"col-sm-8 text-break\">${responseHeader[key]}</dd>`));\n+                responseHeaderElement.append($('<div class=\"w-100\"></div>'));\n+            });\n+        }\n+\n+        requestHeaderElement.empty();\n+        Object.keys(requestHeader).forEach(key => {\n+            console.log(`key=${key}  value=${requestHeader[key]}`);\n+            requestHeaderElement.append($(`<dt class=\"col-sm-4\">${key}</dt>`));\n+            requestHeaderElement.append($(`<dd class=\"col-sm-8 text-break\">${requestHeader[key]}</dd>`));\n+            requestHeaderElement.append($('<div class=\"w-100\"></div>'));\n+        });\n+\n+        modal.modal('handleUpdate');\n+    })\n+\n+    $('.reload-page').click(function () {\n+        location.reload();\n+    });\n+\n+    $('.request-chart').each(function(index, element) {\n+        var bridgeId = $(this).data('bridge-id');\n+        var chartElement = element;\n+\n+        function makeplot(bridgeId, chartElement) {\n+            Plotly.d3.csv('requests?bridgeId=' + bridgeId + '&action=request-csv', function (data) {\n+                processData(data, chartElement)\n+            });\n+        }\n+\n+        function processData(allRows, chartElement) {\n+            console.log(allRows);\n+            var x = [], y = [], standardDeviation = [];\n+\n+            for (var i = 0; i < allRows.length; i++) {\n+                var row = allRows[i];\n+                x.push( row['time'] );\n+                y.push( row['requests'] );\n+            }\n+            console.log( 'X',x, 'Y',y, 'SD',standardDeviation );\n+            makePlotly( x, y, standardDeviation, chartElement );\n+        }\n+\n+        function makePlotly( x, y, standard_deviation, chartElement ){\n+            var traces = [{\n+                x: x,\n+                y: y,\n+                type: 'histogram',\n+                histfunc: 'sum',\n+                xbins: {\n+                    size: 1000\n+                }\n+            }];\n+\n+            Plotly.newPlot(chartElement, traces,\n+                           {\n+                               xaxis: {\n+                                   rangemode: 'nonnegative',\n+                                   autorange: true,\n+                                   title: '',\n+                                   type: 'date'\n+                               },\n+                               yaxis: {\n+                                   title: 'requests',\n+                                   rangemode: 'nonnegative'\n+                               }\n+                           },\n+                           {\n+                               displayModeBar: false,\n+                               responsive: true\n+                           });\n+        };\n+\n+        makeplot(bridgeId, chartElement);\n+    });\n+}())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 218}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMxMzQyODUy", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-631342852", "createdAt": "2021-04-08T12:41:01Z", "commit": {"oid": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQzNjAzMDM2", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-643603036", "createdAt": "2021-04-23T19:26:23Z", "commit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxOToyNjoyM1rOJOwOPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yM1QxOTo0NDoxOFrOJOwvDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ0OTkxOQ==", "bodyText": "Does the error message suite the exception type? An InterruptedException is thrown when the current Thread is interrupted. E.g. when OH is shut down.\nBindings should only log to error if something severe happened, like the detection of a bug in your code. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThis method throws InterruptedException, but it is cought here.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619449919", "createdAt": "2021-04-23T19:26:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/client/HttpHelper.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.client;\n+\n+import static io.github.bucket4j.Bandwidth.classic;\n+import static io.github.bucket4j.Refill.intervally;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import io.github.bucket4j.Bucket;\n+import io.github.bucket4j.Bucket4j;\n+\n+/**\n+ * okHttp helper.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ * @author Laurent Garnier - Removed okhttp\n+ *\n+ */\n+@NonNullByDefault\n+public class HttpHelper {\n+    private static final String BEARER = \"Bearer \";\n+    private static final int OAUTH_EXPIRE_BUFFER = 10;\n+    private static final JsonParser JSON_PARSER = new JsonParser();\n+    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+    private static final Bucket BUCKET = Bucket4j.builder()\n+            // allows 50 tokens per minute (added 10 second buffer)\n+            .addLimit(classic(50, intervally(50, Duration.ofSeconds(70))).withInitialTokens(40))\n+            // but not often then 50 tokens per second\n+            .addLimit(classic(10, intervally(10, Duration.ofSeconds(1)))).build();\n+    private static @Nullable String lastAccessToken = null;\n+\n+    public static ContentResponse sendRequest(Request request)\n+            throws InterruptedException, TimeoutException, ExecutionException {\n+        if (HttpMethod.GET.name().equals(request.getMethod())) {\n+            try {\n+                BUCKET.asScheduler().consume(1);\n+            } catch (InterruptedException e) {\n+                LoggerFactory.getLogger(HttpHelper.class).error(\"Rate limiting error! error={}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTg5ODQxOQ=="}, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MTg1Ng==", "bodyText": "This is already logged by the framework and can therefore be removed. See the popular loggers table: https://www.openhab.org/docs/administration/logging.html#defining-what-to-log", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619451856", "createdAt": "2021-04-23T19:30:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwNTY5MQ=="}, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1MjM3MA==", "bodyText": "Can you comment on my comment?", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619452370", "createdAt": "2021-04-23T19:31:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1300 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL = 2; // in seconds\n+    private static final int OFFLINE_MONITOR_1_DELAY = 30; // in min\n+    private static final int OFFLINE_MONITOR_2_DELAY = 4; // in min\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY = 10; // in min\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            logger.debug(\"Update status to OFFLINE (BRIDGE_UNINITIALIZED). thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is offline ({}), skip initialization of thing handler. haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Dispose thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MTkwOTc4Mw=="}, "originalCommit": {"oid": "61c803d47eb79e1579e7962736369b3c0d9dbd99"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1NDU3MA==", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619454570", "createdAt": "2021-04-23T19:36:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -0,0 +1,1277 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static java.util.Collections.emptyList;\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+import static org.openhab.binding.homeconnect.internal.client.model.EventType.*;\n+import static org.openhab.core.library.unit.ImperialUnits.FAHRENHEIT;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.library.unit.Units.*;\n+import static org.openhab.core.thing.ThingStatus.*;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.ApplianceOfflineException;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.listener.HomeConnectEventListener;\n+import org.openhab.binding.homeconnect.internal.client.model.AvailableProgramOption;\n+import org.openhab.binding.homeconnect.internal.client.model.Data;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.client.model.HomeAppliance;\n+import org.openhab.binding.homeconnect.internal.client.model.Option;\n+import org.openhab.binding.homeconnect.internal.client.model.Program;\n+import org.openhab.binding.homeconnect.internal.handler.cache.ExpiringStateMap;\n+import org.openhab.binding.homeconnect.internal.type.HomeConnectDynamicStateDescriptionProvider;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.library.types.HSBType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.OpenClosedType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Channel;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.BridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AbstractHomeConnectThingHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class AbstractHomeConnectThingHandler extends BaseThingHandler implements HomeConnectEventListener {\n+\n+    private static final int CACHE_TTL_SEC = 2;\n+    private static final int OFFLINE_MONITOR_1_DELAY_MIN = 30;\n+    private static final int OFFLINE_MONITOR_2_DELAY_MIN = 4;\n+    private static final int EVENT_LISTENER_CONNECT_RETRY_DELAY_MIN = 10;\n+\n+    private @Nullable String operationState;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture1;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture2;\n+    private @Nullable ScheduledFuture<?> reinitializationFuture3;\n+    private boolean ignoreEventSourceClosedEvent;\n+\n+    private final ConcurrentHashMap<String, EventHandler> eventHandlers;\n+    private final ConcurrentHashMap<String, ChannelUpdateHandler> channelUpdateHandlers;\n+    private final HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ExpiringStateMap expiringStateMap;\n+    private final AtomicBoolean accessible;\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomeConnectThingHandler.class);\n+\n+    public AbstractHomeConnectThingHandler(Thing thing,\n+            HomeConnectDynamicStateDescriptionProvider dynamicStateDescriptionProvider) {\n+        super(thing);\n+        eventHandlers = new ConcurrentHashMap<>();\n+        channelUpdateHandlers = new ConcurrentHashMap<>();\n+        this.dynamicStateDescriptionProvider = dynamicStateDescriptionProvider;\n+        expiringStateMap = new ExpiringStateMap(Duration.ofSeconds(CACHE_TTL_SEC));\n+        accessible = new AtomicBoolean(false);\n+\n+        configureEventHandlers(eventHandlers);\n+        configureChannelUpdateHandlers(channelUpdateHandlers);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+\n+        if (!getBridgeHandler().isPresent()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            accessible.set(false);\n+        } else if (isBridgeOffline()) {\n+            updateStatus(OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            accessible.set(false);\n+        } else {\n+            updateStatus(UNKNOWN);\n+            scheduler.submit(() -> {\n+                refreshThingStatus(); // set ONLINE / OFFLINE\n+                updateSelectedProgramStateDescription();\n+                updateChannels();\n+                registerEventListener();\n+                scheduleOfflineMonitor1();\n+                scheduleOfflineMonitor2();\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener(true);\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} ({}). haId={}\", bridgeStatusInfo, getThingLabel(), getThingHaId());\n+        reinitialize();\n+    }\n+\n+    private void reinitialize() {\n+        logger.debug(\"Reinitialize thing handler ({}). haId={}\", getThingLabel(), getThingHaId());\n+        stopRetryRegistering();\n+        stopOfflineMonitor1();\n+        stopOfflineMonitor2();\n+        unregisterEventListener();\n+        initialize();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (isThingReadyToHandleCommand()) {\n+            logger.debug(\"Handle \\\"{}\\\" command ({}). haId={}\", command, channelUID.getId(), getThingHaId());\n+            try {\n+                Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();\n+\n+                if (command instanceof RefreshType) {\n+                    updateChannel(channelUID);\n+                } else if (command instanceof StringType && CHANNEL_BASIC_ACTIONS_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent() && getBridgeHandler().isPresent()) {\n+                    HomeConnectApiClient apiClient = homeConnectApiClient.get();\n+                    updateState(channelUID, new StringType(\"\"));\n+\n+                    if (COMMAND_START.equalsIgnoreCase(command.toFullString())) {\n+                        HomeConnectBridgeHandler homeConnectBridgeHandler = getBridgeHandler().get();\n+                        // workaround for api bug\n+                        // if simulator, program options have to be passed along with the desired program\n+                        // if non simulator, some options throw a \"SDK.Error.UnsupportedOption\" error\n+                        if (homeConnectBridgeHandler.getConfiguration().isSimulator()) {\n+                            apiClient.startSelectedProgram(getThingHaId());\n+                        } else {\n+                            @Nullable\n+                            Program selectedProgram = apiClient.getSelectedProgram(getThingHaId());\n+                            if (selectedProgram != null) {\n+                                apiClient.startProgram(getThingHaId(), selectedProgram.getKey());\n+                            }\n+                        }\n+                    } else if (COMMAND_STOP.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.stopProgram(getThingHaId());\n+                    } else if (COMMAND_SELECTED.equalsIgnoreCase(command.toFullString())) {\n+                        apiClient.getSelectedProgram(getThingHaId());\n+                    } else {\n+                        logger.debug(\"Start custom program. command={} haId={}\", command.toFullString(),\n+                                getThingHaId());\n+                        apiClient.startCustomProgram(getThingHaId(), command.toFullString());\n+                    }\n+                } else if (command instanceof StringType && CHANNEL_SELECTED_PROGRAM_STATE.equals(channelUID.getId())\n+                        && homeConnectApiClient.isPresent()) {\n+                    homeConnectApiClient.get().setSelectedProgram(getThingHaId(), command.toFullString());\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\"Could not handle command {}. Appliance offline. thing={}, haId={}, error={}\",\n+                        command.toFullString(), getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"Could not handle command {}. API communication problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Could not handle command {}. Authorization problem! error={}, haId={}\",\n+                        command.toFullString(), e.getMessage(), getThingHaId());\n+\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onEvent(Event event) {\n+        if (DISCONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received DISCONNECTED event. Set {} to OFFLINE. haId={}\", getThing().getLabel(),\n+                    getThingHaId());\n+            updateStatus(OFFLINE);\n+            resetChannelsOnOfflineEvent();\n+            resetProgramStateChannels();\n+        } else if (isThingOnline() && CONNECTED.equals(event.getType())) {\n+            logger.debug(\"Received CONNECTED event. Update power state channel. haId={}\", getThingHaId());\n+            getThingChannel(CHANNEL_POWER_STATE).ifPresent(c -> updateChannel(c.getUID()));\n+        } else if (isThingOffline() && !KEEP_ALIVE.equals(event.getType())) {\n+            updateStatus(ONLINE);\n+            logger.debug(\"Set {} to ONLINE and update channels. haId={}\", getThing().getLabel(), getThingHaId());\n+            updateChannels();\n+        }\n+\n+        @Nullable\n+        String key = event.getKey();\n+        if (EVENT_OPERATION_STATE.equals(key)) {\n+            operationState = event.getValue() == null ? null : event.getValue();\n+        }\n+\n+        if (key != null && eventHandlers.containsKey(key)) {\n+            @Nullable\n+            EventHandler eventHandler = eventHandlers.get(key);\n+            if (eventHandler != null) {\n+                eventHandler.handle(event);\n+            }\n+        }\n+\n+        accessible.set(true);\n+    }\n+\n+    @Override\n+    public void onClosed() {\n+        if (ignoreEventSourceClosedEvent) {\n+            logger.debug(\"Ignoring event source close event. thing={}, haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            unregisterEventListener();\n+            refreshThingStatus();\n+            registerEventListener();\n+        }\n+    }\n+\n+    @Override\n+    public void onRateLimitReached() {\n+        unregisterEventListener();\n+\n+        // retry registering\n+        scheduleRetryRegistering();\n+    }\n+\n+    /**\n+     * Register event listener.\n+     */\n+    protected void registerEventListener() {\n+        if (isBridgeOnline() && isThingAccessibleViaServerSentEvents()) {\n+            getEventSourceClient().ifPresent(client -> {\n+                try {\n+                    ignoreEventSourceClosedEvent = false;\n+                    client.registerEventListener(getThingHaId(), this);\n+                } catch (CommunicationException | AuthorizationException e) {\n+                    logger.warn(\"Could not open event source connection. thing={}, haId={}, error={}\", getThingLabel(),\n+                            getThingHaId(), e.getMessage());\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Unregister event listener.\n+     */\n+    protected void unregisterEventListener() {\n+        unregisterEventListener(false);\n+    }\n+\n+    private void unregisterEventListener(boolean immediate) {\n+        getEventSourceClient().ifPresent(client -> {\n+            ignoreEventSourceClosedEvent = true;\n+            client.unregisterEventListener(this, immediate, false);\n+        });\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectApiClient}.\n+     *\n+     * @return client instance\n+     */\n+    protected Optional<HomeConnectApiClient> getApiClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getApiClient);\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectEventSourceClient}.\n+     *\n+     * @return client instance if present\n+     */\n+    protected Optional<HomeConnectEventSourceClient> getEventSourceClient() {\n+        return getBridgeHandler().map(HomeConnectBridgeHandler::getEventSourceClient);\n+    }\n+\n+    /**\n+     * Update state description of selected program (Fetch programs via API).\n+     */\n+    protected void updateSelectedProgramStateDescription() {\n+        if (isBridgeOffline() || isThingOffline()) {\n+            return;\n+        }\n+\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+        if (apiClient.isPresent()) {\n+            try {\n+                List<StateOption> stateOptions = apiClient.get().getPrograms(getThingHaId()).stream()\n+                        .map(p -> new StateOption(p.getKey(), mapStringType(p.getKey()))).collect(Collectors.toList());\n+\n+                getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE).ifPresent(\n+                        channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), stateOptions));\n+            } catch (CommunicationException | ApplianceOfflineException | AuthorizationException e) {\n+                logger.debug(\"Could not fetch available programs. thing={}, haId={}, error={}\", getThingLabel(),\n+                        getThingHaId(), e.getMessage());\n+                removeSelectedProgramStateDescription();\n+            }\n+        } else {\n+            removeSelectedProgramStateDescription();\n+        }\n+    }\n+\n+    /**\n+     * Remove state description of selected program.\n+     */\n+    protected void removeSelectedProgramStateDescription() {\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> dynamicStateDescriptionProvider.setStateOptions(channel.getUID(), emptyList()));\n+    }\n+\n+    /**\n+     * Is thing ready to process commands. If bridge or thing itself is offline commands will be ignored.\n+     *\n+     * @return true if ready\n+     */\n+    protected boolean isThingReadyToHandleCommand() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge is OFFLINE. Ignore command. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        if (isThingOffline()) {\n+            logger.debug(\"{} is OFFLINE. Ignore command. haId={}\", getThing().getLabel(), getThingHaId());\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Checks if bridge is online and set.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isBridgeOnline() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        return bridge != null && ONLINE.equals(bridge.getStatus());\n+    }\n+\n+    /**\n+     * Checks if bridge is offline or not set.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isBridgeOffline() {\n+        return !isBridgeOnline();\n+    }\n+\n+    /**\n+     * Checks if thing is online.\n+     *\n+     * @return true if online\n+     */\n+    protected boolean isThingOnline() {\n+        return ONLINE.equals(getThing().getStatus());\n+    }\n+\n+    /**\n+     * Checks if thing is connected to the cloud and accessible via SSE.\n+     *\n+     * @return true if yes\n+     */\n+    public boolean isThingAccessibleViaServerSentEvents() {\n+        return accessible.get();\n+    }\n+\n+    /**\n+     * Checks if thing is offline.\n+     *\n+     * @return true if offline\n+     */\n+    protected boolean isThingOffline() {\n+        return !isThingOnline();\n+    }\n+\n+    /**\n+     * Get {@link HomeConnectBridgeHandler}.\n+     *\n+     * @return bridge handler\n+     */\n+    protected Optional<HomeConnectBridgeHandler> getBridgeHandler() {\n+        @Nullable\n+        Bridge bridge = getBridge();\n+        if (bridge != null) {\n+            @Nullable\n+            BridgeHandler bridgeHandler = bridge.getHandler();\n+            if (bridgeHandler instanceof HomeConnectBridgeHandler) {\n+                return Optional.of((HomeConnectBridgeHandler) bridgeHandler);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get thing channel by given channel id.\n+     *\n+     * @param channelId channel id\n+     * @return channel\n+     */\n+    protected Optional<Channel> getThingChannel(String channelId) {\n+        @Nullable\n+        Channel channel = getThing().getChannel(channelId);\n+        if (channel == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(channel);\n+        }\n+    }\n+\n+    /**\n+     * Configure channel update handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers channel update handlers\n+     */\n+    protected abstract void configureChannelUpdateHandlers(final Map<String, ChannelUpdateHandler> handlers);\n+\n+    /**\n+     * Configure event handlers. Classes which extend {@link AbstractHomeConnectThingHandler} must implement\n+     * this class and add handlers.\n+     *\n+     * @param handlers Server-Sent-Event handlers\n+     */\n+    protected abstract void configureEventHandlers(final Map<String, EventHandler> handlers);\n+\n+    /**\n+     * Update all channels via API.\n+     *\n+     */\n+    protected void updateChannels() {\n+        if (isBridgeOffline()) {\n+            logger.debug(\"Bridge handler not found or offline. Stopping update of channels. thing={}, haId={}\",\n+                    getThingLabel(), getThingHaId());\n+        } else if (isThingOffline()) {\n+            logger.debug(\"{} offline. Stopping update of channels. haId={}\", getThing().getLabel(), getThingHaId());\n+        } else {\n+            List<Channel> channels = getThing().getChannels();\n+            for (Channel channel : channels) {\n+                updateChannel(channel.getUID());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update Channel values via API.\n+     *\n+     * @param channelUID channel UID\n+     */\n+    protected void updateChannel(ChannelUID channelUID) {\n+        if (!getApiClient().isPresent()) {\n+            logger.error(\"Cannot update channel. No instance of api client found! thing={}, haId={}\", getThingLabel(),\n+                    getThingHaId());\n+            return;\n+        }\n+\n+        if (!isThingReadyToHandleCommand()) {\n+            return;\n+        }\n+\n+        if ((isLinked(channelUID) || CHANNEL_OPERATION_STATE.equals(channelUID.getId())) // always update operation\n+                // state channel\n+                && channelUpdateHandlers.containsKey(channelUID.getId())) {\n+            try {\n+                @Nullable\n+                ChannelUpdateHandler channelUpdateHandler = channelUpdateHandlers.get(channelUID.getId());\n+                if (channelUpdateHandler != null) {\n+                    channelUpdateHandler.handle(channelUID, expiringStateMap);\n+                }\n+            } catch (ApplianceOfflineException e) {\n+                logger.debug(\n+                        \"API communication problem while trying to update! Appliance offline. thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+                updateStatus(OFFLINE);\n+                resetChannelsOnOfflineEvent();\n+                resetProgramStateChannels();\n+            } catch (CommunicationException e) {\n+                logger.debug(\"API communication problem while trying to update! thing={}, haId={}, error={}\",\n+                        getThingLabel(), getThingHaId(), e.getMessage());\n+            } catch (AuthorizationException e) {\n+                logger.debug(\"Authentication problem while trying to update! thing={}, haId={}\", getThingLabel(),\n+                        getThingHaId(), e);\n+                handleAuthenticationError(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reset program related channels.\n+     */\n+    protected void resetProgramStateChannels() {\n+        logger.debug(\"Resetting active program channel states. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+    }\n+\n+    /**\n+     * Reset all channels on OFFLINE event.\n+     */\n+    protected void resetChannelsOnOfflineEvent() {\n+        logger.debug(\"Resetting channel states due to OFFLINE event. thing={}, haId={}\", getThingLabel(),\n+                getThingHaId());\n+        getThingChannel(CHANNEL_POWER_STATE).ifPresent(channel -> updateState(channel.getUID(), OnOffType.OFF));\n+        getThingChannel(CHANNEL_OPERATION_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_DOOR_STATE).ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_LOCAL_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_CONTROL_ACTIVE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_REMOTE_START_ALLOWANCE_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+        getThingChannel(CHANNEL_SELECTED_PROGRAM_STATE)\n+                .ifPresent(channel -> updateState(channel.getUID(), UnDefType.UNDEF));\n+    }\n+\n+    /**\n+     * Map Home Connect key and value names to label.\n+     * e.g. Dishcare.Dishwasher.Program.Eco50 --> Eco50 or BSH.Common.EnumType.OperationState.DelayedStart --> Delayed\n+     * Start\n+     *\n+     * @param type type\n+     * @return human readable label\n+     */\n+    protected String mapStringType(String type) {\n+        int index = type.lastIndexOf(\".\");\n+        if (index > 0 && type.length() > index) {\n+            String sub = type.substring(index + 1);\n+            StringBuilder sb = new StringBuilder();\n+            for (String word : sub.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\")) {\n+                sb.append(\" \");\n+                sb.append(word);\n+            }\n+            return sb.toString().trim();\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Map Home Connect stage value to label.\n+     * e.g. Cooking.Hood.EnumType.IntensiveStage.IntensiveStage1 --> 1\n+     *\n+     * @param stage stage\n+     * @return human readable label\n+     */\n+    protected String mapStageStringType(String stage) {\n+        switch (stage) {\n+            case STAGE_FAN_OFF:\n+            case STAGE_INTENSIVE_STAGE_OFF:\n+                stage = \"Off\";\n+                break;\n+            case STAGE_FAN_STAGE_01:\n+            case STAGE_INTENSIVE_STAGE_1:\n+                stage = \"1\";\n+                break;\n+            case STAGE_FAN_STAGE_02:\n+            case STAGE_INTENSIVE_STAGE_2:\n+                stage = \"2\";\n+                break;\n+            case STAGE_FAN_STAGE_03:\n+                stage = \"3\";\n+                break;\n+            case STAGE_FAN_STAGE_04:\n+                stage = \"4\";\n+                break;\n+            case STAGE_FAN_STAGE_05:\n+                stage = \"5\";\n+                break;\n+            default:\n+                stage = mapStringType(stage);\n+        }\n+\n+        return stage;\n+    }\n+\n+    /**\n+     * Map unit string (returned by home connect api) to Unit\n+     *\n+     * @param unit String eg. \"\u00b0C\"\n+     * @return Unit\n+     */\n+    protected Unit<Temperature> mapTemperature(@Nullable String unit) {\n+        if (unit == null) {\n+            return CELSIUS;\n+        } else if (unit.endsWith(\"C\")) {\n+            return CELSIUS;\n+        } else {\n+            return FAHRENHEIT;\n+        }\n+    }\n+\n+    /**\n+     * Map hex representation of color to HSB type.\n+     *\n+     * @param colorCode color code e.g. #001122\n+     * @return HSB type\n+     */\n+    protected HSBType mapColor(String colorCode) {\n+        HSBType color = HSBType.WHITE;\n+\n+        if (colorCode.length() == 7) {\n+            int r = Integer.valueOf(colorCode.substring(1, 3), 16);\n+            int g = Integer.valueOf(colorCode.substring(3, 5), 16);\n+            int b = Integer.valueOf(colorCode.substring(5, 7), 16);\n+            color = HSBType.fromRGB(r, g, b);\n+        }\n+        return color;\n+    }\n+\n+    /**\n+     * Map HSB color type to hex representation.\n+     *\n+     * @param color HSB color\n+     * @return color code e.g. #001122\n+     */\n+    protected String mapColor(HSBType color) {\n+        String redValue = String.format(\"%02X\", (int) (color.getRed().floatValue() * 2.55));\n+        String greenValue = String.format(\"%02X\", (int) (color.getGreen().floatValue() * 2.55));\n+        String blueValue = String.format(\"%02X\", (int) (color.getBlue().floatValue() * 2.55));\n+        return \"#\" + redValue + greenValue + blueValue;\n+    }\n+\n+    /**\n+     * Check bridge status and refresh connection status of thing accordingly.\n+     */\n+    protected void refreshThingStatus() {\n+        Optional<HomeConnectApiClient> apiClient = getApiClient();\n+\n+        apiClient.ifPresent(client -> {\n+            try {\n+                HomeAppliance homeAppliance = client.getHomeAppliance(getThingHaId());\n+                if (!homeAppliance.isConnected()) {\n+                    logger.debug(\"Update status to OFFLINE. thing={}, haId={}\", getThingLabel(), getThingHaId());\n+                    updateStatus(OFFLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1Nzk1Nw==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded.\nThe log message could be removed, as the status update is already logged by the framework and displayed in the UI.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619457957", "createdAt": "2021-04-23T19:43:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQ1ODMxOA==", "bodyText": "See above. Remove log message.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r619458318", "createdAt": "2021-04-23T19:44:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/HomeConnectBridgeHandler.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.homeconnect.internal.handler;\n+\n+import static org.openhab.binding.homeconnect.internal.HomeConnectBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectApiClient;\n+import org.openhab.binding.homeconnect.internal.client.HomeConnectEventSourceClient;\n+import org.openhab.binding.homeconnect.internal.client.exception.AuthorizationException;\n+import org.openhab.binding.homeconnect.internal.client.exception.CommunicationException;\n+import org.openhab.binding.homeconnect.internal.client.model.ApiRequest;\n+import org.openhab.binding.homeconnect.internal.client.model.Event;\n+import org.openhab.binding.homeconnect.internal.configuration.ApiBridgeConfiguration;\n+import org.openhab.binding.homeconnect.internal.discovery.HomeConnectDiscoveryService;\n+import org.openhab.binding.homeconnect.internal.servlet.HomeConnectServlet;\n+import org.openhab.core.auth.client.oauth2.AccessTokenResponse;\n+import org.openhab.core.auth.client.oauth2.OAuthClientService;\n+import org.openhab.core.auth.client.oauth2.OAuthException;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.auth.client.oauth2.OAuthResponseException;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerCallback;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.osgi.service.jaxrs.client.SseEventSourceFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HomeConnectBridgeHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Jonas Br\u00fcstel - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HomeConnectBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REINITIALIZATION_DELAY_SEC = 120;\n+    private static final String CLIENT_SECRET = \"clientSecret\";\n+    private static final String CLIENT_ID = \"clientId\";\n+\n+    private final HttpClient httpClient;\n+    private final ClientBuilder clientBuilder;\n+    private final SseEventSourceFactory eventSourceFactory;\n+    private final OAuthFactory oAuthFactory;\n+    private final HomeConnectServlet homeConnectServlet;\n+    private final Logger logger = LoggerFactory.getLogger(HomeConnectBridgeHandler.class);\n+\n+    private @Nullable ScheduledFuture<?> reinitializationFuture;\n+    private @Nullable List<ApiRequest> apiRequestHistory;\n+    private @Nullable List<Event> eventHistory;\n+\n+    private @NonNullByDefault({}) OAuthClientService oAuthClientService;\n+    private @NonNullByDefault({}) String oAuthServiceHandleId;\n+    private @NonNullByDefault({}) HomeConnectApiClient apiClient;\n+    private @NonNullByDefault({}) HomeConnectEventSourceClient eventSourceClient;\n+\n+    public HomeConnectBridgeHandler(Bridge bridge, HttpClient httpClient, ClientBuilder clientBuilder,\n+            SseEventSourceFactory eventSourceFactory, OAuthFactory oAuthFactory,\n+            HomeConnectServlet homeConnectServlet) {\n+        super(bridge);\n+\n+        this.httpClient = httpClient;\n+        this.clientBuilder = clientBuilder;\n+        this.eventSourceFactory = eventSourceFactory;\n+        this.oAuthFactory = oAuthFactory;\n+        this.homeConnectServlet = homeConnectServlet;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // not used for bridge\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // let the bridge configuration servlet know about this handler\n+        homeConnectServlet.addBridgeHandler(this);\n+\n+        // create oAuth service\n+        ApiBridgeConfiguration config = getConfiguration();\n+        String tokenUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_TOKEN_PATH;\n+        String authorizeUrl = (config.isSimulator() ? API_SIMULATOR_BASE_URL : API_BASE_URL) + OAUTH_AUTHORIZE_PATH;\n+        String oAuthServiceHandleId = thing.getUID().getAsString() + (config.isSimulator() ? \"simulator\" : \"\");\n+\n+        oAuthClientService = oAuthFactory.createOAuthClientService(oAuthServiceHandleId, tokenUrl, authorizeUrl,\n+                config.getClientId(), config.getClientSecret(), OAUTH_SCOPE, true);\n+        this.oAuthServiceHandleId = oAuthServiceHandleId;\n+        logger.debug(\n+                \"Initialize oAuth client service. tokenUrl={}, authorizeUrl={}, oAuthServiceHandleId={}, scope={}, oAuthClientService={}\",\n+                tokenUrl, authorizeUrl, oAuthServiceHandleId, OAUTH_SCOPE, oAuthClientService);\n+\n+        // create api client\n+        apiClient = new HomeConnectApiClient(httpClient, oAuthClientService, config.isSimulator(), apiRequestHistory,\n+                config);\n+        eventSourceClient = new HomeConnectEventSourceClient(clientBuilder, eventSourceFactory, oAuthClientService,\n+                config.isSimulator(), scheduler, eventHistory);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(() -> {\n+            try {\n+                @Nullable\n+                AccessTokenResponse accessTokenResponse = oAuthClientService.getAccessTokenResponse();\n+\n+                if (accessTokenResponse == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect).\");\n+                    logger.info(\n+                            \"Configuration is pending. Please authenticate your account at http(s)://[YOUROPENHAB]:[YOURPORT]/homeconnect (e.g. http://192.168.178.100:8080/homeconnect). bridge={}\",\n+                            getThing().getLabel());\n+                } else {\n+                    apiClient.getHomeAppliances();\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (OAuthException | IOException | OAuthResponseException | CommunicationException\n+                    | AuthorizationException e) {\n+                ZonedDateTime nextReinitializeDateTime = ZonedDateTime.now().plusSeconds(REINITIALIZATION_DELAY_SEC);\n+\n+                String infoMessage = String.format(\n+                        \"Home Connect service is not reachable or a problem occurred! Retrying at %s (%s). bridge=%s\",\n+                        nextReinitializeDateTime.format(DateTimeFormatter.RFC_1123_DATE_TIME), e.getMessage(),\n+                        getThing().getLabel());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, infoMessage);\n+                logger.info(\"{}\", infoMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7f4e42318cbf007ef9d8ed6c5e9c82b40d69f35f", "committedDate": "2021-05-02T15:29:31Z", "message": "[homeconnect] Home Connect Binding initial contribution\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21f01062b30ff53fc6e59be90afc9556602eb9b0", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/21f01062b30ff53fc6e59be90afc9556602eb9b0", "committedDate": "2021-05-02T15:29:32Z", "message": "[homeconnect] Applied review feedback and changed copyright label\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba0589cba09faab8de11cba443adda6d175a3d74", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ba0589cba09faab8de11cba443adda6d175a3d74", "committedDate": "2021-05-02T15:29:32Z", "message": "[homeconnect] Applied review feedback and improved README\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/15ea75b12c9c11bac1803c32ed3c944cddc4f6e0", "committedDate": "2021-05-02T15:29:32Z", "message": "[homeconnect] Remove Okhttp dependency\n\nUse the Jetty HTTP client provided by the core framework\nUse JAX-RS SSE for SSE\n\nAlso remove dependency on org.apache.commons.lang.*\n\nFix: cancel any job when disposing thing handler\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1099fcfd28997a8c6ae2e223a4756d31d3869954", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/1099fcfd28997a8c6ae2e223a4756d31d3869954", "committedDate": "2021-05-02T15:29:32Z", "message": "Consider all review comments except the one relative to bucket4j\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/aa71ba75ee064eaa8ddb78766ef89f03eb45f378", "committedDate": "2021-05-02T15:29:32Z", "message": "Review comment: way to use bucket4j\n\nIncrease OAUTH_EXPIRE_BUFFER to 30 seconds\n\nSet the variable ignoreEventSourceClosedEvent to true at beginning of\nregisterEventListener\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eed8286d12f5010bcc42aa477b391df905d66e2", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/7eed8286d12f5010bcc42aa477b391df905d66e2", "committedDate": "2021-05-02T15:29:32Z", "message": "Add Cache-Control header to SSE request\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ec45b27481b628d8bdcea5409d1261a570b1ff8", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/8ec45b27481b628d8bdcea5409d1261a570b1ff8", "committedDate": "2021-05-02T15:29:33Z", "message": "Restore value 10 (seconds) for OAUTH_EXPIRY_BUFFER\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "896168f81c47ba82b07fe68304000593d2ea4dac", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/896168f81c47ba82b07fe68304000593d2ea4dac", "committedDate": "2021-05-02T15:29:33Z", "message": "SSE failure due to NotAuthorizedException: wait 5 seconds\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff91273022d4ed57870710cc497dde5b8eeb8e81", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/ff91273022d4ed57870710cc497dde5b8eeb8e81", "committedDate": "2021-05-02T15:29:33Z", "message": "Log something when the binding requests a refresh of the access token\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/c6f0d1726e979f766dbfa7ec4ea79d83c7ea5f5b", "committedDate": "2021-05-02T15:29:33Z", "message": "Log when the access token changed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37cdd410e8d47fdad0656c169e1c55e581c571e5", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/37cdd410e8d47fdad0656c169e1c55e581c571e5", "committedDate": "2021-05-02T15:29:33Z", "message": "Do not try to close the SSE connection when the server notified it as completed\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10225c77938c481e38def9f850bff48cf491e4ac", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/10225c77938c481e38def9f850bff48cf491e4ac", "committedDate": "2021-05-02T15:29:33Z", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f9bda8c8bed3e47613d38c3a0fd191cb3969722b", "committedDate": "2021-05-02T15:29:33Z", "message": "Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fb5481ca70f94d6add9a04adad11396f8b68fbd", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0fb5481ca70f94d6add9a04adad11396f8b68fbd", "committedDate": "2021-05-02T15:29:34Z", "message": "Fixed bucket4j bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "551429a3597bcf6ca7036b97e90eacc83172a219", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/551429a3597bcf6ca7036b97e90eacc83172a219", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Removed Plotly charts\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9a4d58f8319873184904d2d549f613b90fbceb2", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e9a4d58f8319873184904d2d549f613b90fbceb2", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Fixed compile warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e38efe08f75eac1bdd5ac326257456ffdb11043b", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e38efe08f75eac1bdd5ac326257456ffdb11043b", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Revered gson changes\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3de2f9d0e6706e9e436d355c781f6e046f3f0576", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3de2f9d0e6706e9e436d355c781f6e046f3f0576", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d451257d6baa89a89d41871deaeda021caf9a018", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d451257d6baa89a89d41871deaeda021caf9a018", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Refactored and optimized general and light related command handling\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3a31018244d13b5390d13f13ff3f2cb77f722e3", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a3a31018244d13b5390d13f13ff3f2cb77f722e3", "committedDate": "2021-05-02T15:29:34Z", "message": "[homeconnect] Moved temperature command handling to abstract class and use channel type 'system.power' instead of custom type\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "committedDate": "2021-05-02T15:29:35Z", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1e98c03c5b22b3467c0d3d25af6400dad6dd2a5d", "committedDate": "2021-04-02T13:32:30Z", "message": "[homeconnect] Revered gson changes\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}, "afterCommit": {"oid": "1364ae8bcdef364f4b2f6193b87d48f62428eae0", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1364ae8bcdef364f4b2f6193b87d48f62428eae0", "committedDate": "2021-05-02T15:29:35Z", "message": "[homeconnect] Applied review feedback\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMDk0NTg4", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-651094588", "createdAt": "2021-05-04T10:33:12Z", "commit": {"oid": "3de2f9d0e6706e9e436d355c781f6e046f3f0576"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNFQxMDozMzoxM1rOJUsK0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0wNFQxMDozMzoxM1rOJUsK0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyNTY3NDk2MA==", "bodyText": "You already have the apiClient as parameter.", "url": "https://github.com/openhab/openhab-addons/pull/9187#discussion_r625674960", "createdAt": "2021-05-04T10:33:13Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.homeconnect/src/main/java/org/openhab/binding/homeconnect/internal/handler/AbstractHomeConnectThingHandler.java", "diffHunk": "@@ -157,51 +157,55 @@ private void reinitialize() {\n         initialize();\n     }\n \n+    protected void handleCommand(ChannelUID channelUID, Command command, HomeConnectApiClient apiClient)\n+            throws CommunicationException, AuthorizationException, ApplianceOfflineException {\n+        Optional<HomeConnectApiClient> homeConnectApiClient = getApiClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3de2f9d0e6706e9e436d355c781f6e046f3f0576"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86d863e36a92d405a8081f9fa00d57e900537373", "author": {"user": {"login": "lolodomo", "name": "lolodomo"}}, "url": "https://github.com/openhab/openhab-addons/commit/86d863e36a92d405a8081f9fa00d57e900537373", "committedDate": "2021-05-04T12:27:08Z", "message": "Fix for handleCommand\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec", "committedDate": "2021-05-04T14:44:14Z", "message": "Merge pull request #3 from lolodomo/homeconnect\n\nFix for handleCommand"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjUxMzQ2OTk4", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-651346998", "createdAt": "2021-05-04T15:03:25Z", "commit": {"oid": "55525c9ff82afae66ff5fb33e5d5d3f1d00c03ec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36c008fc19d232e795b09454da99de14c8ad1421", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/36c008fc19d232e795b09454da99de14c8ad1421", "committedDate": "2021-05-04T15:03:33Z", "message": "[homeconnect] Fixed warnings\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97eeb29e929257c5154ff19e0c810a3fff519c4a", "author": {"user": {"login": "bruestel", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/97eeb29e929257c5154ff19e0c810a3fff519c4a", "committedDate": "2021-05-06T09:55:24Z", "message": "[homeconnect] Workaround event listener bug\n\nSigned-off-by: Jonas Br\u00fcstel <jonas@bruestel.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4ODcyNjI0", "url": "https://github.com/openhab/openhab-addons/pull/9187#pullrequestreview-658872624", "createdAt": "2021-05-13T12:55:31Z", "commit": {"oid": "97eeb29e929257c5154ff19e0c810a3fff519c4a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3937, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}