{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5ODk0OTA4", "number": 7870, "title": "[mpd]: Music Player Daemon initial contribution", "bodyText": "Signed-off-by: Stefan Roellin stefan@roellin-baumann.ch\nThis binding controls Music Player Daemons (https://www.musicpd.org/) and is meant to replace the corresponding binding from openhab1-addons (https://www.openhab.org/addons/bindings/mpd1/)\nAlmost all functionality from the old binding is supported, except\n\nplaysong\nplaysongid\n\nHowever, the new implementation has actions, which allow to send arbitrary commands to a Music Player Daemon. With those actions, the missing functionality can be replaced easily and is much more flexible.\nExample with actions:\nrule \"turn on morning music\"\nwhen\n        Item morning_music changed to ON\nthen\n        val actions = getActions(\"mpd\",\"mpd:mpd:music\")\n        if(actions === null) {\n                logWarn(\"myLog\", \"actions is null\")\n                return\n        }\n\n        actions.sendCommand(\"clear\")\n        actions.sendCommand(\"load\", \"MorningMusic\");\n        actions.sendCommand(\"shuffle\");\n        actions.sendCommand(\"play\");\nend", "createdAt": "2020-06-07T09:14:41Z", "url": "https://github.com/openhab/openhab-addons/pull/7870", "merged": true, "mergeCommit": {"oid": "5d100e964fe3c210ab119502fb11d09388f09c80"}, "closed": true, "closedAt": "2020-08-21T09:57:38Z", "author": {"login": "stefanroellin"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxrSD6gBqjM1MTI3MTAxMTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBBzAxgFqTQ3MjM2MTg4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be01d7f1b212f37c1617050eea175eee884cbe0b", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/be01d7f1b212f37c1617050eea175eee884cbe0b", "committedDate": "2020-06-07T08:53:55Z", "message": "[mpd]: Music Player Daemon initial contribution\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}, "afterCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/7bf7e9a4687f65268a01daf9fa786b2a908fddf8", "committedDate": "2020-07-04T17:13:29Z", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDk2MjQx", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-445096241", "createdAt": "2020-07-08T20:14:51Z", "commit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDoxNDo1MlrOGu3q1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMDo0OToyMlrOGu4tyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5OTc2Ng==", "bodyText": "Can you mention the Thing Type ID?", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451799766", "createdAt": "2020-07-08T20:14:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/README.md", "diffHunk": "@@ -0,0 +1,106 @@\n+# MPD Binding\n+\n+[Music Player Daemon (MPD)](http://www.musicpd.org/) is a flexible, powerful, server-side application for playing music. Through plugins and libraries it can play a variety of sound files while being controlled by its network protocol. \n+\n+With the openHAB MPD binding you can control Music Player Daemons.\n+\n+\n+## Supported Things\n+\n+The Music Player Daemon is supported.\n+\n+## Discovery\n+\n+If zeroconf is enabled in the Music Player Daemon, it is discovered. Each Music Player daemon requires a unique zeroconf_name for correct discovery.\n+\n+\n+## Thing Configuration\n+\n+The thing requires the following configuration parameters:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5OTg5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | IP Address      | ipAddress    | Host name or IP address of the Music Player Daemon)                      | yes      |\n          \n          \n            \n            | IP Address      | ipAddress    | Host name or IP address of the Music Player Daemon                       | yes      |", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451799898", "createdAt": "2020-07-08T20:15:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/README.md", "diffHunk": "@@ -0,0 +1,106 @@\n+# MPD Binding\n+\n+[Music Player Daemon (MPD)](http://www.musicpd.org/) is a flexible, powerful, server-side application for playing music. Through plugins and libraries it can play a variety of sound files while being controlled by its network protocol. \n+\n+With the openHAB MPD binding you can control Music Player Daemons.\n+\n+\n+## Supported Things\n+\n+The Music Player Daemon is supported.\n+\n+## Discovery\n+\n+If zeroconf is enabled in the Music Player Daemon, it is discovered. Each Music Player daemon requires a unique zeroconf_name for correct discovery.\n+\n+\n+## Thing Configuration\n+\n+The thing requires the following configuration parameters:\n+\n+| Parameter Label | Parameter ID | Description                                                              | Required |\n+|-----------------|--------------|--------------------------------------------------------------------------|----------|\n+| IP Address      | ipAddress    | Host name or IP address of the Music Player Daemon)                      | yes      |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTg2MQ==", "bodyText": "Are you aware of this bug openhab/openhab-core#1265?\nIf you want, you could add a workaround like this:\nhttps://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ecobee/src/main/java/org/openhab/binding/ecobee/action/EcobeeActions.java#L89", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451801861", "createdAt": "2020-07-08T20:19:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    public static void sendCommand(@Nullable ThingActions actions, @Nullable String command,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzU0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (uid == null || host == null || \"\".equals(host)) {\n          \n          \n            \n                    if (uid == null || host == null || host.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803547", "createdAt": "2020-07-08T20:22:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMzc3Nw==", "bodyText": "Can you add a representation property?", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451803777", "createdAt": "2020-07-08T20:22:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || \"\".equals(host)) {\n+            return null;\n+        }\n+\n+        final Map<String, Object> properties = new HashMap<>(2);\n+        properties.put(MPDBindingConstants.PARAMETER_IPADDRESS, host);\n+        properties.put(MPDBindingConstants.PARAMETER_PORT, port);\n+\n+        String name = service.getName();\n+\n+        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(name)\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTMxOQ==", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently). You might want to move it to the end of this method.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805319", "createdAt": "2020-07-08T20:25:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNTYxNA==", "bodyText": "No harm in cancelling a task that is already cancelled. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451805614", "createdAt": "2020-07-08T20:26:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNjM2Ng==", "bodyText": "Syntactical sugar. Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);\n          \n          \n            \n                        this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451806366", "createdAt": "2020-07-08T20:27:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null && !future.isCancelled()) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(() -> doUpdateStatus(), 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(() -> doUpdateCurrentSong(), 100, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwOTU0MA==", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451809540", "createdAt": "2020-07-08T20:34:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMTYzNw==", "bodyText": "Thing.dispose() should return fast. Can't you just close the socket?", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451811637", "createdAt": "2020-07-08T20:38:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxMjc0MA==", "bodyText": "Do you ignore the exception by intention? Is it worth to log it?", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451812740", "createdAt": "2020-07-08T20:40:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNDM4Nw==", "bodyText": "If I see correctly, you need to store InputStreamReader to close it, too.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451814387", "createdAt": "2020-07-08T20:44:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        synchronized (pendingCommands) {\n+            pendingCommands.add(new MPDCommand(\"close\"));\n+            sendNoIdleIfInIdle();\n+            interrupt();\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", this.address, this.port);\n+        Socket socket = new Socket(this.address, this.port);\n+\n+        reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNTkzMQ==", "bodyText": "Is this expected to fail? Otherwise, you could log it.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451815931", "createdAt": "2020-07-08T20:47:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDSong.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing a song.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDSong {\n+    private final String filename;\n+    private final String album;\n+    private final String artist;\n+    private final String name;\n+    private final int song;\n+    private final int songId;\n+    private final String title;\n+    private final int track;\n+\n+    public MPDSong(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        filename = values.getOrDefault(\"file\", \"\");\n+        album = values.getOrDefault(\"Album\", \"\");\n+        artist = values.getOrDefault(\"Artist\", \"\");\n+        name = values.getOrDefault(\"Name\", \"\");\n+        song = parseInteger(values.getOrDefault(\"Pos\", \"0\"), 0);\n+        songId = parseInteger(values.getOrDefault(\"Id\", \"0\"), 0);\n+        title = values.getOrDefault(\"Title\", \"\");\n+        track = parseInteger(values.getOrDefault(\"Track\", \"-1\"), -1);\n+    }\n+\n+    public String getFilename() {\n+        return filename;\n+    }\n+\n+    public String getAlbum() {\n+        return album;\n+    }\n+\n+    public String getArtist() {\n+        return artist;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getSong() {\n+        return song;\n+    }\n+\n+    public int getSongId() {\n+        return songId;\n+    }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public int getTrack() {\n+        return track;\n+    }\n+\n+    private int parseInteger(String value, int aDefault) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjUzNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451816534", "createdAt": "2020-07-08T20:48:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDStatus.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for representing the status of a Music Player Daemon.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDStatus {\n+\n+    public enum State {\n+        PLAY,\n+        PAUSE,\n+        STOP\n+    }\n+\n+    private final State state;\n+    private final int volume;\n+\n+    public MPDStatus(MPDResponse response) {\n+        Map<String, String> values = MPDResponseParser.responseToMap(response);\n+        state = parseState(values.getOrDefault(\"state\", \"\"));\n+        volume = parseVolume(values.getOrDefault(\"volume\", \"0\"));\n+    }\n+\n+    public State getState() {\n+        return state;\n+    }\n+\n+    public int getVolume() {\n+        return volume;\n+    }\n+\n+    private State parseState(String value) {\n+        switch (value) {\n+            case \"play\":\n+                return State.PLAY;\n+            case \"pause\":\n+                return State.PAUSE;\n+            case \"stop\":\n+                return State.STOP;\n+        }\n+\n+        return State.STOP;\n+    }\n+\n+    private int parseVolume(String value) {\n+        try {\n+            return Integer.parseInt(value);\n+        } catch (NumberFormatException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxNjkwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.mpd.description = Das MPD Binding erlaubt Music Player Daemon zu kontrollieren.\n          \n          \n            \n            binding.mpd.description = Das MPD Binding erlaubt es Music Player Daemons zu steuern.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r451816907", "createdAt": "2020-07-08T20:49:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/resources/ESH-INF/i18n/mpd_de.properties", "diffHunk": "@@ -0,0 +1,28 @@\n+binding.mpd.name = MPD Binding\n+binding.mpd.description = Das MPD Binding erlaubt Music Player Daemon zu kontrollieren.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf7e9a4687f65268a01daf9fa786b2a908fddf8"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMDQzMjU2", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-451043256", "createdAt": "2020-07-18T08:57:43Z", "commit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwODo1Nzo0NFrOGzm7RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQwOTowODowNFrOGzm-yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODMyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");\n          \n          \n            \n                    throw new IllegalArgumentException(\"Actions is not an instance of MPDActions\");", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768325", "createdAt": "2020-07-18T08:57:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/action/MPDActions.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.action;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.mpd.internal.handler.MPDHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link @MPDActions} defines rule actions for the Music Player Daemon binding. *\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@ThingActionsScope(name = \"mpd\")\n+@NonNullByDefault\n+public class MPDActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDActions.class);\n+\n+    private @Nullable MPDHandler handler = null;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof MPDHandler) {\n+            this.handler = (MPDHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return handler;\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command,\n+            @ActionInput(name = \"parameter\") @Nullable String parameter) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    @RuleAction(label = \"MPD : Send command\", description = \"Send a command to the Music Player Daemon.\")\n+    public void sendCommand(@ActionInput(name = \"command\") @Nullable String command) {\n+        logger.debug(\"sendCommand called with {}\", command);\n+\n+        MPDHandler handler = this.handler;\n+        if (handler != null) {\n+            handler.sendCommand(command);\n+        } else {\n+            logger.warn(\"MPD Action service ThingHandler is null!\");\n+        }\n+    }\n+\n+    private static MPDActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(MPDActions.class.getName())) {\n+            if (actions instanceof MPDActions) {\n+                return (MPDActions) actions;\n+            } else {\n+                return (MPDActions) Proxy.newProxyInstance(MPDActions.class.getClassLoader(),\n+                        new Class[] { MPDActions.class }, (Object proxy, Method method, Object[] args) -> {\n+                            Method m = actions.getClass().getDeclaredMethod(method.getName(),\n+                                    method.getParameterTypes());\n+                            return m.invoke(actions, args);\n+                        });\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Actions is not an instance of EcobeeActions\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODM3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(2);\n          \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(3);", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768375", "createdAt": "2020-07-18T08:58:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/discovery/MPDDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.discovery;\n+\n+import java.net.Inet4Address;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.jmdns.ServiceInfo;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.mdns.MDNSDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Implementation of {@link MDNSDiscoveryParticipant} that will discover Music Player Daemons.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(immediate = true)\n+public class MPDDiscoveryParticipant implements MDNSDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(MPDBindingConstants.THING_TYPE_MPD);\n+    }\n+\n+    @Override\n+    public String getServiceType() {\n+        return \"_mpd._tcp.local.\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DiscoveryResult createResult(ServiceInfo service) {\n+        ThingUID uid = getThingUID(service);\n+        String host = getHostAddress(service);\n+        int port = service.getPort();\n+\n+        logger.debug(\"Music Player Daemon found on host {} port {}\", host, port);\n+\n+        if (uid == null || host == null || host.isEmpty()) {\n+            return null;\n+        }\n+\n+        String uniquePropVal = String.format(\"%s-%d\", host, port);\n+\n+        final Map<String, Object> properties = new HashMap<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODg0Mg==", "bodyText": "You might want to add the timeout parameter to join() in case the thread blocks for some reason.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768842", "createdAt": "2020-07-18T09:03:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2ODkyOA==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456768928", "createdAt": "2020-07-18T09:04:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTEyOQ==", "bodyText": "Named threads make debugging easier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n          \n          \n            \n                    super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769129", "createdAt": "2020-07-18T09:06:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2OTIyNA==", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } catch (IOException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            } catch (MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n          \n          \n            \n                            }\n          \n          \n            \n                            } catch (IOException | MPDException e) {\n          \n          \n            \n                                updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n          \n          \n            \n                            }", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r456769224", "createdAt": "2020-07-18T09:08:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT = 60000; // 60 seconds\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62425d3d7e497b6ecd049214055b9613dd5db5cd"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTA3MzUx", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-451107351", "createdAt": "2020-07-19T07:42:14Z", "commit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NzI4NTk2", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-465728596", "createdAt": "2020-08-12T09:06:07Z", "commit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTowNjowN1rOG_YicQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTozODowMFrOG_ZseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNTUwNQ==", "bodyText": "nice!", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469115505", "createdAt": "2020-08-12T09:06:07Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNjUzMA==", "bodyText": "Remark: This method-name could be slightly confusing because this class also has updateStatus which updates the thing status.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469116530", "createdAt": "2020-08-12T09:07:54Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/handler/MPDHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.handler;\n+\n+import static org.openhab.binding.mpd.internal.MPDBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.mpd.internal.MPDBindingConstants;\n+import org.openhab.binding.mpd.internal.MPDConfiguration;\n+import org.openhab.binding.mpd.internal.action.MPDActions;\n+import org.openhab.binding.mpd.internal.protocol.MPDConnection;\n+import org.openhab.binding.mpd.internal.protocol.MPDSong;\n+import org.openhab.binding.mpd.internal.protocol.MPDStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MPDHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDHandler extends BaseThingHandler implements MPDEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDHandler.class);\n+\n+    private Map<String, @Nullable State> stateMap = Collections.synchronizedMap(new HashMap<String, @Nullable State>());\n+\n+    private final MPDConnection connection;\n+    private int volume = 0;\n+\n+    private @Nullable ScheduledFuture<?> futureUpdateStatus;\n+    private @Nullable ScheduledFuture<?> futureUpdateCurrentSong;\n+\n+    public MPDHandler(Thing thing) {\n+        super(thing);\n+        connection = new MPDConnection(this);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            handleCommandRefresh(channelUID.getId());\n+        } else {\n+            handlePlayerCommand(channelUID.getId(), command);\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MPDConfiguration config = getConfigAs(MPDConfiguration.class);\n+        String uniquePropVal = String.format(\"%s-%d\", config.getIpAddress(), config.getPort());\n+        updateProperty(MPDBindingConstants.UNIQUE_ID, uniquePropVal);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connection.start(config.getIpAddress(), config.getPort(), config.getPassword());\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        future = this.futureUpdateCurrentSong;\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+\n+        connection.dispose();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MPDActions.class);\n+    }\n+\n+    /**\n+     * send a command to the music player daemon\n+     *\n+     * @param command command to send\n+     * @param parameter parameter of command\n+     */\n+    public void sendCommand(@Nullable String command, String... parameter) {\n+        if (command != null) {\n+            connection.sendCommand(command, parameter);\n+        } else {\n+            logger.warn(\"can't send null command\");\n+        }\n+    }\n+\n+    private void handleCommandRefresh(String channelId) {\n+        stateMap.remove(channelId);\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+            case CHANNEL_STOP:\n+            case CHANNEL_VOLUME:\n+                scheduleUpdateStatus();\n+                break;\n+            case CHANNEL_CURRENT_ALBUM:\n+            case CHANNEL_CURRENT_ARTIST:\n+            case CHANNEL_CURRENT_NAME:\n+            case CHANNEL_CURRENT_SONG:\n+            case CHANNEL_CURRENT_SONG_ID:\n+            case CHANNEL_CURRENT_TITLE:\n+            case CHANNEL_CURRENT_TRACK:\n+                scheduleUpdateCurrentSong();\n+                break;\n+        }\n+    }\n+\n+    private synchronized void scheduleUpdateStatus() {\n+        logger.debug(\"scheduleUpdateStatus\");\n+        ScheduledFuture<?> future = this.futureUpdateStatus;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateStatus = scheduler.schedule(this::doUpdateStatus, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateStatus() {\n+        connection.updateStatus();\n+    }\n+\n+    private synchronized void scheduleUpdateCurrentSong() {\n+        logger.debug(\"scheduleUpdateCurrentSong\");\n+        ScheduledFuture<?> future = this.futureUpdateCurrentSong;\n+        if (future == null || future.isCancelled() || future.isDone()) {\n+            this.futureUpdateCurrentSong = scheduler.schedule(this::doUpdateCurrentSong, 100, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    private void doUpdateCurrentSong() {\n+        connection.updateCurrentSong();\n+    }\n+\n+    private void handlePlayerCommand(String channelId, Command command) {\n+        switch (channelId) {\n+            case CHANNEL_CONTROL:\n+                handleCommandControl(command);\n+                break;\n+            case CHANNEL_STOP:\n+                handleCommandStop(command);\n+                break;\n+            case CHANNEL_VOLUME:\n+                handleCommandVolume(command);\n+                break;\n+        }\n+    }\n+\n+    private void handleCommandControl(Command command) {\n+        if (command instanceof PlayPauseType) {\n+            if (command == PlayPauseType.PLAY) {\n+                connection.play();\n+            } else if (command == PlayPauseType.PAUSE) {\n+                connection.pause();\n+            }\n+        } else if (command instanceof NextPreviousType) {\n+            if (command == NextPreviousType.NEXT) {\n+                connection.playNext();\n+            } else if (command == NextPreviousType.PREVIOUS) {\n+                connection.playPrevious();\n+            }\n+        } else {\n+            // Rewind and Fast Forward are currently not implemented by the binding\n+            logger.debug(\"Control command {} is not supported\", command);\n+        }\n+    }\n+\n+    private void handleCommandStop(Command command) {\n+        if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                connection.stop();\n+            } else if (command == OnOffType.OFF) {\n+                connection.play();\n+            }\n+        } else {\n+            logger.debug(\"Stop Command {} is not supported\", command);\n+            return;\n+        }\n+    }\n+\n+    private void handleCommandVolume(Command command) {\n+        int newValue = 0;\n+        if (command instanceof IncreaseDecreaseType) {\n+            if (command == IncreaseDecreaseType.INCREASE) {\n+                newValue = Math.min(100, volume + 1);\n+            } else if (command == IncreaseDecreaseType.DECREASE) {\n+                newValue = Math.max(0, volume - 1);\n+            }\n+        } else if (command instanceof OnOffType) {\n+            if (command == OnOffType.ON) {\n+                newValue = 100;\n+            } else if (command == OnOffType.OFF) {\n+                newValue = 0;\n+            }\n+        } else if (command instanceof DecimalType) {\n+            newValue = ((DecimalType) command).intValue();\n+        } else if (command instanceof PercentType) {\n+            newValue = ((PercentType) command).intValue();\n+        } else {\n+            logger.debug(\"Command {} is not supported to change volume\", command);\n+            return;\n+        }\n+\n+        connection.setVolume(newValue);\n+    }\n+\n+    private void updateChannel(String channelID, State state) {\n+        State previousState = stateMap.put(channelID, state);\n+        if (previousState == null || !previousState.equals(state)) {\n+            updateState(channelID, state);\n+        }\n+    }\n+\n+    @Override\n+    public void updateStatus(MPDStatus status) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNzYzNg==", "bodyText": "You could consider renaming e to ignore this makes the ignoring of the exception explicit and documented.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (InterruptedException e) {\n          \n          \n            \n                    } catch (InterruptedException ignore) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469117636", "createdAt": "2020-08-12T09:09:43Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExODIwNQ==", "bodyText": "Both fields could be final, it makes it more explicit that this class is immutable and helps to guard that in the future.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469118205", "createdAt": "2020-08-12T09:10:42Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class for encapsulating an MPD command\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class MPDCommand {\n+\n+    private String command;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTAwMQ==", "bodyText": "Consider marking this field final", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119001", "createdAt": "2020-08-12T09:12:07Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExOTQyMA==", "bodyText": "Consider renaming to ignore\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (InterruptedException e) {\n          \n          \n            \n                        } catch (InterruptedException ignore) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469119420", "createdAt": "2020-08-12T09:12:48Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnection.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.handler.MPDEventListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnection implements MPDResponseListener {\n+\n+    private static final int DISPOSE_TIMEOUT_MS = 1000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnection.class);\n+\n+    private @Nullable MPDConnectionThread connectionThread = null;\n+    private MPDEventListener listener;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public MPDConnection(MPDEventListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    /**\n+     * start the connection\n+     *\n+     * @param address the IP address of the music player daemon\n+     * @param port the TCP port to be used\n+     * @param password the password to connect to the music player daemon\n+     */\n+    public void start(String address, Integer port, String password) {\n+        if (connectionThread == null) {\n+            connectionThread = new MPDConnectionThread(this, address, port, password);\n+            connectionThread.start();\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        final MPDConnectionThread connectionThread = this.connectionThread;\n+        if (connectionThread != null) {\n+            connectionThread.dispose();\n+            connectionThread.interrupt();\n+            try {\n+                connectionThread.join(DISPOSE_TIMEOUT_MS);\n+            } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyMTAyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469121027", "createdAt": "2020-08-12T09:15:25Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNTEyOQ==", "bodyText": "It does not seem completely guaranteed to me that this is a configuration error, this could maybe just be a communication problem (daemon/host not running) however it is reported to the end-user as a configuration error with text \"could not connect\". Throwing it as an IOException could fix that.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"could not connect\");\n          \n          \n            \n                        throw new IOException (\"Failed to connect to \" + this.address \":\" + this.port);", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469125129", "createdAt": "2020-08-12T09:22:25Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyNzc2OQ==", "bodyText": "@Hilbrand recently suggested a more uniform naming of Threads, could you update the Thread-name, I'm really sorry that it conflicts a bit with @fwolter earlier comment:\n#8216", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469127769", "createdAt": "2020-08-12T09:26:51Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyODUzMw==", "bodyText": "Would it make sense to check to basic sanity of the configuration parameters before connecting? A malformed/empty host address or port is of course a configuration error.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469128533", "createdAt": "2020-08-12T09:28:10Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTU2OQ==", "bodyText": "This message is displayed to the end-user consider making it more user friendly for example by suggesting to validate the password.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new MPDException(\"could not authenticate\");\n          \n          \n            \n                            throw new MPDException(\"Could not authenticate, please validate your password\");", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129569", "createdAt": "2020-08-12T09:29:55Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEyOTc3NA==", "bodyText": "Position literals first in String comparisons - that way if the String is null you won't get a NullPointerException, it'll just return false. source: PMD", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469129774", "createdAt": "2020-08-12T09:30:15Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDAwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130009", "createdAt": "2020-08-12T09:30:39Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDE0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (IOException e) {\n          \n          \n            \n                        } catch (IOException ignore) {", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130142", "createdAt": "2020-08-12T09:30:51Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMDc4NA==", "bodyText": "Do you really need to close all of them? Will closing some of them not take a long the rest. E.g closing both the reader and inputStreamReader is AFAIK not needed.\nA quick peak in the javadoc suggested that closing the socket will do all the work at one.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469130784", "createdAt": "2020-08-12T09:32:01Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjQ3Mw==", "bodyText": "asLine is now always performed consider depending on toString instead then the logging framework will only call to toString when the content is actually being logged. If you cannot you might consider wrapping it in logger.isTraceEnabled()", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132473", "createdAt": "2020-08-12T09:34:46Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw==", "bodyText": "This ends up in the UI if I read correctly what can the user do about this? Did it lose the connection. Please update the message.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469132973", "createdAt": "2020-08-12T09:35:35Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());\n+        final DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            String line = command.asLine();\n+            byte[] bytes = line.getBytes(StandardCharsets.UTF_8);\n+            writer.write(bytes);\n+            writer.write('\\n');\n+        } else {\n+            throw new IOException(\"writer is null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzNDQ1Nw==", "bodyText": "Please validate other messages when. might end up in the UI because of the behaviour at https://github.com/openhab/openhab-addons/pull/7870/files#diff-eac6da5ab58546ad9466910baded0b5fR86", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r469134457", "createdAt": "2020-08-12T09:38:00Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.mpd.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.mpd.internal.MPDException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the music player daemon through a IP connection\n+ *\n+ * @author Stefan R\u00f6llin - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MPDConnectionThread extends Thread {\n+\n+    private static final int RECONNECTION_TIMEOUT_SEC = 60;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MPDConnectionThread.class);\n+\n+    private final MPDResponseListener listener;\n+\n+    private final String address;\n+    private final Integer port;\n+    private final String password;\n+\n+    private @Nullable Socket socket = null;\n+    private @Nullable InputStreamReader inputStreamReader = null;\n+    private @Nullable BufferedReader reader = null;\n+    private @Nullable DataOutputStream writer = null;\n+\n+    private final List<MPDCommand> pendingCommands = new ArrayList<>();\n+    private AtomicBoolean isInIdle = new AtomicBoolean(false);\n+    private AtomicBoolean disposed = new AtomicBoolean(false);\n+\n+    public MPDConnectionThread(MPDResponseListener listener, String address, Integer port, String password) {\n+        super(MPDConnectionThread.class.getSimpleName() + \" \" + address + \":\" + port);\n+\n+        this.listener = listener;\n+\n+        this.address = address;\n+        this.port = port;\n+        this.password = password;\n+        setDaemon(true);\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            while (!disposed.get()) {\n+                try {\n+                    synchronized (pendingCommands) {\n+                        pendingCommands.clear();\n+                        pendingCommands.add(new MPDCommand(\"status\"));\n+                        pendingCommands.add(new MPDCommand(\"currentsong\"));\n+                    }\n+\n+                    establishConnection();\n+                    updateThingStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+\n+                    processPendingCommands();\n+                } catch (IOException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                } catch (MPDException e) {\n+                    updateThingStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+                }\n+\n+                isInIdle.set(false);\n+                closeSocket();\n+\n+                if (!disposed.get()) {\n+                    sleep(RECONNECTION_TIMEOUT_SEC * 1000);\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    /**\n+     * dispose the connection\n+     */\n+    public void dispose() {\n+        disposed.set(true);\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    /**\n+     * add a command to the pending commands queue\n+     *\n+     * @param command command to add\n+     */\n+    public void addCommand(MPDCommand command) {\n+        insertCommand(command, -1);\n+    }\n+\n+    private void insertCommand(MPDCommand command, int position) {\n+        logger.debug(\"insert command '{}' at position {}\", command.getCommand(), position);\n+        int index = position;\n+        synchronized (pendingCommands) {\n+            if (index < 0) {\n+                index = pendingCommands.size();\n+            }\n+            pendingCommands.add(index, command);\n+            sendNoIdleIfInIdle();\n+        }\n+    }\n+\n+    private void updateThingStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        if (!disposed.get()) {\n+            listener.updateThingStatus(status, statusDetail, description);\n+        }\n+    }\n+\n+    private void sendNoIdleIfInIdle() {\n+        if (isInIdle.compareAndSet(true, false)) {\n+            try {\n+                sendCommand(new MPDCommand(\"noidle\"));\n+            } catch (IOException e) {\n+                logger.debug(\"sendCommand(noidle) failed\");\n+            }\n+        }\n+    }\n+\n+    private void establishConnection() throws IOException, MPDException {\n+        openSocket();\n+\n+        MPDCommand currentCommand = new MPDCommand(\"connect\");\n+        MPDResponse response = readResponse(currentCommand);\n+\n+        if (!response.isOk()) {\n+            throw new MPDException(\"could not connect\");\n+        }\n+\n+        if (!password.isEmpty()) {\n+            currentCommand = new MPDCommand(\"password\", password);\n+            sendCommand(currentCommand);\n+            response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                throw new MPDException(\"could not authenticate\");\n+            }\n+        }\n+    }\n+\n+    private void openSocket() throws IOException {\n+        logger.debug(\"opening connection to {} port {}\", address, port);\n+        Socket socket = new Socket(address, port);\n+\n+        inputStreamReader = new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8);\n+        reader = new BufferedReader(inputStreamReader);\n+        writer = new DataOutputStream(socket.getOutputStream());\n+\n+        this.socket = socket;\n+    }\n+\n+    private void processPendingCommands() throws IOException {\n+        MPDCommand currentCommand;\n+\n+        while (!disposed.get()) {\n+            synchronized (pendingCommands) {\n+                if (!pendingCommands.isEmpty()) {\n+                    currentCommand = pendingCommands.remove(0);\n+                } else {\n+                    currentCommand = new MPDCommand(\"idle\");\n+                }\n+\n+                sendCommand(currentCommand);\n+                if (currentCommand.getCommand().equals(\"idle\")) {\n+                    isInIdle.set(true);\n+                }\n+            }\n+\n+            MPDResponse response = readResponse(currentCommand);\n+            if (!response.isOk()) {\n+                insertCommand(new MPDCommand(\"clearerror\"), 0);\n+            }\n+            listener.onResponse(response);\n+        }\n+    }\n+\n+    private void closeSocket() {\n+        logger.debug(\"Closing socket\");\n+        BufferedReader reader = this.reader;\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+            }\n+            this.reader = null;\n+        }\n+\n+        InputStreamReader inputStreamReader = this.inputStreamReader;\n+        if (inputStreamReader != null) {\n+            try {\n+                inputStreamReader.close();\n+            } catch (IOException e) {\n+            }\n+            this.inputStreamReader = null;\n+        }\n+\n+        DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+            }\n+            this.writer = null;\n+        }\n+\n+        Socket socket = this.socket;\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+            }\n+            this.socket = null;\n+        }\n+    }\n+\n+    private void sendCommand(MPDCommand command) throws IOException {\n+        logger.trace(\"send command '{}'\", command.asLine());\n+        final DataOutputStream writer = this.writer;\n+        if (writer != null) {\n+            String line = command.asLine();\n+            byte[] bytes = line.getBytes(StandardCharsets.UTF_8);\n+            writer.write(bytes);\n+            writer.write('\\n');\n+        } else {\n+            throw new IOException(\"writer is null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjk3Mw=="}, "originalCommit": {"oid": "3a26da84dba97d76a21a16002675f7c5bd5656df"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTUzNzYx", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-471553761", "createdAt": "2020-08-20T12:41:28Z", "commit": {"oid": "7963e82e0e0ee8511713e62eb5783450349eb090"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo0MToyOFrOHD-9Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo0MToyOFrOHD-9Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTIyNg==", "bodyText": "Very minor:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MPDException(\"Invalid parameter port\");\n          \n          \n            \n                        throw new MPDException(\"Invalid port parameter\");\n          \n      \n    \n    \n  \n\nOtherwise, it might suggest that the parameter port is invalid and should not be supplied.", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473939226", "createdAt": "2020-08-20T12:41:28Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -147,38 +146,45 @@ private void sendNoIdleIfInIdle() {\n             try {\n                 sendCommand(new MPDCommand(\"noidle\"));\n             } catch (IOException e) {\n-                logger.debug(\"sendCommand(noidle) failed\");\n+                logger.debug(\"sendCommand(noidle) failed\", e);\n             }\n         }\n     }\n \n-    private void establishConnection() throws IOException, MPDException {\n+    private void establishConnection() throws UnknownHostException, IOException, MPDException {\n         openSocket();\n \n         MPDCommand currentCommand = new MPDCommand(\"connect\");\n         MPDResponse response = readResponse(currentCommand);\n \n         if (!response.isOk()) {\n-            throw new MPDException(\"could not connect\");\n+            throw new MPDException(\"Failed to connect to \" + this.address + \":\" + this.port);\n         }\n \n         if (!password.isEmpty()) {\n             currentCommand = new MPDCommand(\"password\", password);\n             sendCommand(currentCommand);\n             response = readResponse(currentCommand);\n             if (!response.isOk()) {\n-                throw new MPDException(\"could not authenticate\");\n+                throw new MPDException(\"Could not authenticate, please validate your password\");\n             }\n         }\n     }\n \n-    private void openSocket() throws IOException {\n+    private void openSocket() throws UnknownHostException, IOException, MPDException {\n         logger.debug(\"opening connection to {} port {}\", address, port);\n+\n+        if (address.isEmpty()) {\n+            throw new MPDException(\"Missing parameter ipAddress\");\n+        }\n+        if (port < 1 || port > 65335) {\n+            throw new MPDException(\"Invalid parameter port\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7963e82e0e0ee8511713e62eb5783450349eb090"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxNTU1MDU3", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-471555057", "createdAt": "2020-08-20T12:43:21Z", "commit": {"oid": "7963e82e0e0ee8511713e62eb5783450349eb090"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo0MzoyMVrOHD_BFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo0MzoyMVrOHD_BFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDI0NA==", "bodyText": "It might make sense to fetch the socket.getOutputStream() here so that you don't have to fetch it twice or was there a specific reason to do it like this?", "url": "https://github.com/openhab/openhab-addons/pull/7870#discussion_r473940244", "createdAt": "2020-08-20T12:43:21Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.mpd/src/main/java/org/openhab/binding/mpd/internal/protocol/MPDConnectionThread.java", "diffHunk": "@@ -223,40 +229,32 @@ private void closeSocket() {\n         if (inputStreamReader != null) {\n             try {\n                 inputStreamReader.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.inputStreamReader = null;\n         }\n \n-        DataOutputStream writer = this.writer;\n-        if (writer != null) {\n-            try {\n-                writer.close();\n-            } catch (IOException e) {\n-            }\n-            this.writer = null;\n-        }\n-\n         Socket socket = this.socket;\n         if (socket != null) {\n             try {\n                 socket.close();\n-            } catch (IOException e) {\n+            } catch (IOException ignore) {\n             }\n             this.socket = null;\n         }\n     }\n \n     private void sendCommand(MPDCommand command) throws IOException {\n-        logger.trace(\"send command '{}'\", command.asLine());\n-        final DataOutputStream writer = this.writer;\n-        if (writer != null) {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"send command '{}'\", command.asLine());\n+        }\n+        final Socket socket = this.socket;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7963e82e0e0ee8511713e62eb5783450349eb090"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cccf21d363f6f75e6115d92dbd03cdc227e1a329", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/cccf21d363f6f75e6115d92dbd03cdc227e1a329", "committedDate": "2020-08-20T18:16:05Z", "message": "[mpd]: Music Player Daemon initial contribution\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "309214dfa0796498ef8a11b827549d7bbeab24a3", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/309214dfa0796498ef8a11b827549d7bbeab24a3", "committedDate": "2020-08-20T18:16:05Z", "message": "[mpd]: increase version to 2.5.7-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/d0bcd9a6e3758c85df961f834b84ce95c2cf91d1", "committedDate": "2020-08-20T18:16:05Z", "message": "[mpd]: reduce number of requests at startup\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/80c0bccd6ff8f1d42ddd427ce9014082ca437d20", "committedDate": "2020-08-20T18:16:05Z", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/d24cd4ce855321c69d347c9d1a1fbff6ce2e5388", "committedDate": "2020-08-20T18:16:05Z", "message": "fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f90431733dca95340b791a4cf6c893d24bee9e91", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/f90431733dca95340b791a4cf6c893d24bee9e91", "committedDate": "2020-08-20T18:16:05Z", "message": "[mpd]: fixes from review\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/0a85bbd6a3ee8a53156e8251efd06bf67bdfbda5", "committedDate": "2020-08-20T18:16:05Z", "message": "[mpd]: increase version to 2.5.8-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a178c21ce913b0ce53656483a28a7d6a6f5be45", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/3a178c21ce913b0ce53656483a28a7d6a6f5be45", "committedDate": "2020-08-20T18:29:34Z", "message": "[mpd]: make exception text more understandable\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f320b217ef531c1d3a38452e93b12ff4c1205b74", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/f320b217ef531c1d3a38452e93b12ff4c1205b74", "committedDate": "2020-08-20T19:38:53Z", "message": "[mpd]: do not write password to log file\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "committedDate": "2020-08-20T19:39:37Z", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8efbd1df77da6f7223042b468648c53652326cc9", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/8efbd1df77da6f7223042b468648c53652326cc9", "committedDate": "2020-08-19T18:49:14Z", "message": "[mpd]: increase version to 2.5.8-SNAPSHOT\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}, "afterCommit": {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6", "author": {"user": {"login": "stefanroellin", "name": "Stefan Roellin"}}, "url": "https://github.com/openhab/openhab-addons/commit/b257f624d1319c3f8a9360b5353a34bde75514c6", "committedDate": "2020-08-20T19:39:37Z", "message": "[mpd]: set thing to offline, if there is a permission problem\n\nSigned-off-by: Stefan Roellin <stefan@roellin-baumann.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMzYxODg0", "url": "https://github.com/openhab/openhab-addons/pull/7870#pullrequestreview-472361884", "createdAt": "2020-08-21T09:56:47Z", "commit": {"oid": "b257f624d1319c3f8a9360b5353a34bde75514c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 538, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}