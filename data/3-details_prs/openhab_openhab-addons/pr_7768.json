{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMzkzOTI2", "number": 7768, "title": "[tacmi] Initial push of OpenHAB 2 ported tacmi binding", "bodyText": "Signed-off-by: Christian Niessner github-marvkis@christian-niessner.de\nTA C.M.I. binding - ported legacy 1.xx addon to 2.xx\nHi. As I was helping a friend connecting his TA system with openhab we had some issues getting the old OpenHAB 1.xx addon to work and there have been some issues within the plugin itself I've started porting it to 2.xx.\nCurrently this binding should deliver all functionality as the 1.xx binding had with some additional bugfixing and removal of some limitations. Especially each output id should work and not only a few as the cave cat with bundled transfer of multiple values was solved by adding some internal caching so the binding is aware of the current values of the neighboring outputs and can send a complete set of updates.\nI've uploaded a pre-compiled jar file to here for testing: https://github.com/marvkis/openhab-addons-dist/raw/master/org.openhab.binding.tacmi-2.5.6-SNAPSHOT.jar\nAnd I've created a thread in the forum where the new version is announced and I asked for testing: https://community.openhab.org/t/tacmi-technische-alternative-ta-c-m-i-binding-upgrade-to-1-xx-2-xx/99416\nI've marked the PR as WIP as I have some further idea's for this plugin. Never the less it should provide full functionality as the 1.xx version plugin had, so it might be an idea to merge this one as replacement for the 1.xx plugin and add the new ideas later on.\nbtw: I've developed this plugin via VSC as OpenHAB in eclipse kills my quite old 2015 mb (non-pro) - and i'm not sure if all formatting rules are applied correctly. So when you see issues here please give me the right pointers what & how to fix it.\nThanks & Bye,\nChris", "createdAt": "2020-05-24T10:36:04Z", "url": "https://github.com/openhab/openhab-addons/pull/7768", "merged": true, "mergeCommit": {"oid": "623eb57f5ed6953734afc6873d0ff5d0abad01c1"}, "closed": true, "closedAt": "2020-09-11T12:51:33Z", "author": {"login": "marvkis"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc696OpABqjM2MTMzNjUwMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdH032HAFqTQ4Njc3NjI2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "434d40d8f663271b491cdf647c560ce097c41a2b", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/434d40d8f663271b491cdf647c560ce097c41a2b", "committedDate": "2020-05-24T15:59:01Z", "message": "[tacmi] executed `mvn spotless:apply` to fix formatting issues\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}, "afterCommit": {"oid": "20d8d39df532ff9f8287aa6780f4a38a9fa05389", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/20d8d39df532ff9f8287aa6780f4a38a9fa05389", "committedDate": "2020-08-02T13:57:05Z", "message": "[tacmi] initial WIP-Checkin of the \"Schema API Page\" variant"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20d8d39df532ff9f8287aa6780f4a38a9fa05389", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/20d8d39df532ff9f8287aa6780f4a38a9fa05389", "committedDate": "2020-08-02T13:57:05Z", "message": "[tacmi] initial WIP-Checkin of the \"Schema API Page\" variant"}, "afterCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "committedDate": "2020-08-02T18:09:10Z", "message": "[tacmi] added initial documentation for the new API Page thing\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjg2OTM1", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-460286935", "createdAt": "2020-08-03T19:31:38Z", "commit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 67, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxOTozMTozOFrOG7GFgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMDo1NTo1OVrOG7IcYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxODg4MQ==", "bodyText": "What is cacmi?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464618881", "createdAt": "2020-08-03T19:31:38Z", "author": {"login": "fwolter"}, "path": "CODEOWNERS", "diffHunk": "@@ -31,6 +31,7 @@\n /bundles/org.openhab.binding.bsblan/ @hypetsch\n /bundles/org.openhab.binding.bticinosmarther/ @MrRonfo\n /bundles/org.openhab.binding.buienradar/ @gedejong\n+/bundles/org.openhab.binding.cacmi/ @twendt @Wolfgang1966 @marvkis", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDY1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * Change values for controlable nodes\n          \n          \n            \n              * Change values for controllable nodes", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464620654", "createdAt": "2020-08-03T19:35:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMTAwNQ==", "bodyText": "Putting each sentence in a separate line makes reading the diffs easier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. \n          \n          \n            \n            Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464621005", "createdAt": "2020-08-03T19:36:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMjQ2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your OpenHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n          \n          \n            \n            Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your openHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464622468", "createdAt": "2020-08-03T19:39:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. \n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site. This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `. \n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel. The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique. Everything else till the final *:* will be used as channel description.\n+The type of the channel will be automatically determined by the type of the object added. The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2. This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for COE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your OpenHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMzIyMA==", "bodyText": "As PaperUI will be replaced in OH3, can you remove the reference to PaperUI?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464623220", "createdAt": "2020-08-03T19:41:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. \n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site. This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `. \n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel. The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique. Everything else till the final *:* will be used as channel description.\n+The type of the channel will be automatically determined by the type of the object added. The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2. This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for COE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your OpenHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites. This thing doesn't need the bridge. Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created. The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices. The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. schema API connection_ has to be manually configured, either through the (Paper) UI or via a thing-file. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyNDM0NQ==", "bodyText": "Can you mention the Thing Type IDs and add the config parameter to a table with parameter name, type, required/optional and description?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464624345", "createdAt": "2020-08-03T19:43:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. \n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site. This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `. \n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel. The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique. Everything else till the final *:* will be used as channel description.\n+The type of the channel will be automatically determined by the type of the object added. The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2. This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for COE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your OpenHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites. This thing doesn't need the bridge. Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created. The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices. The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. schema API connection_ has to be manually configured, either through the (Paper) UI or via a thing-file. \n+\n+It takes the C.M.I.'s IP-Address, login credentials, page ID of the API schema page and a refresh interval as configuration parameter. This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyNDg0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It takes the C.M.I.'s IP-Address and the CAN Node-ID from the defice behind the C.M.I. where the data is sent to / received for. The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n          \n          \n            \n            It takes the C.M.I.'s IP-Address and the CAN Node-ID from the device behind the C.M.I. where the data is sent to / received for. The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464624847", "createdAt": "2020-08-03T19:44:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,186 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative. Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus. These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controlable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to archive either the \"Schema API Page\" or the CoE way might be better. As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better. If you plan things mainly for user interaction the \"Schema API Page\" might be better. \n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site. This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `. \n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel. The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique. Everything else till the final *:* will be used as channel description.\n+The type of the channel will be automatically determined by the type of the object added. The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2. This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for COE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE). Here you will map your outputs that you configured in the previous step. This can be accomplished via the GUI on the CMI or via the coe.csv file. As the target device you need to put the IP of your OpenHAB server. Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites. This thing doesn't need the bridge. Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created. The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices. The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. schema API connection_ has to be manually configured, either through the (Paper) UI or via a thing-file. \n+\n+It takes the C.M.I.'s IP-Address, login credentials, page ID of the API schema page and a refresh interval as configuration parameter. This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured, either through the (Paper) UI or via a thing-file. \n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+It takes the C.M.I.'s IP-Address and the CAN Node-ID from the defice behind the C.M.I. where the data is sent to / received for. The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyNzQ0Mw==", "bodyText": "Please add the attoparser lib here.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464627443", "createdAt": "2020-08-03T19:50:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/NOTICE", "diffHunk": "@@ -0,0 +1,13 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyNzgwOA==", "bodyText": "The GitHub user name is not necessary here, as it is contained in CODEOWNERS.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464627808", "createdAt": "2020-08-03T19:51:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiBindingConstants.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+\n+/**\n+ * The {@link TACmiBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyODk4Nw==", "bodyText": "Annotating inner classes is not necessary. There is a bug in the checkstyle rules, which causes a false positive here.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464628987", "createdAt": "2020-08-03T19:54:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTM0Ng==", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629346", "createdAt": "2020-08-03T19:54:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTkwMA==", "bodyText": "Annotating local variables is not necessary, as the compiler is intelligent enough here.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629900", "createdAt": "2020-08-03T19:56:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTk4OQ==", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be warn.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629989", "createdAt": "2020-08-03T19:56:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDIyMQ==", "bodyText": "Logging to info should be used rarely. This could be debug or trace. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630221", "createdAt": "2020-08-03T19:56:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDMxMw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630313", "createdAt": "2020-08-03T19:57:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDc4MA==", "bodyText": "Can this message be replaced by using the debugger? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging Same for below", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630780", "createdAt": "2020-08-03T19:58:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMTM1Mw==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464631353", "createdAt": "2020-08-03T19:59:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMjcyMw==", "bodyText": "For periodic tasks, the OH scheduler should be used to save resources and for simplicity. See https://www.openhab.org/docs/developer/bindings/#polling-for-a-state", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464632723", "createdAt": "2020-08-03T20:02:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMjgzNA==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464632834", "createdAt": "2020-08-03T20:02:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMzMxNA==", "bodyText": "You could remove this log message, as it's already logged by the framework via updateStatus().", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464633314", "createdAt": "2020-08-03T20:03:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDQzNA==", "bodyText": "I can't find this issue. Can you provide a link?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634434", "createdAt": "2020-08-03T20:06:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDY5Nw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634697", "createdAt": "2020-08-03T20:06:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDg0Mg==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634842", "createdAt": "2020-08-03T20:07:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Handler disposed.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNTI0Nw==", "bodyText": "You might want to specify a timeout as a parameter to join(), in case the thread blocks for some reason.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464635247", "createdAt": "2020-08-03T20:08:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Handler disposed.\");\n+        @Nullable\n+        MonitorThread monitor = this.monitor;\n+        if (monitor != null) {\n+            monitor.interrupt();\n+            try {\n+                monitor.join();\n+            } catch (final InterruptedException e) {\n+                logger.info(\"Unexpected interrupt in monitor.join(): {}\", e.getMessage(), e);\n+            }\n+            this.monitor = null;\n+        }\n+        @Nullable\n+        ReceiveThread receiveThread = this.receiveThread;\n+        if (receiveThread != null)\n+            receiveThread.interrupt(); // just interrupt it so when the socketException throws it's flagged as\n+                                       // interrupted.\n+\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock != null && !sock.isClosed()) {\n+            sock.close();\n+            this.coeSocket = null;\n+        }\n+        if (receiveThread != null) {\n+            receiveThread.interrupt();\n+            try {\n+                receiveThread.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNTkyMw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464635923", "createdAt": "2020-08-03T20:09:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjIxNg==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636216", "createdAt": "2020-08-03T20:10:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjMzNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636337", "createdAt": "2020-08-03T20:10:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjY4Mw==", "bodyText": "initialize() should return fast. You can do this in a OH scheduler task. See above.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636683", "createdAt": "2020-08-03T20:11:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjk5OQ==", "bodyText": "See above. Same for the others.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636999", "createdAt": "2020-08-03T20:11:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNzE3Mw==", "bodyText": "See above. Same for the others.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464637173", "createdAt": "2020-08-03T20:12:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA==", "bodyText": "What's your intention by storing the cache on disk and not in RAM? As many OH instances run on raspberrys with SD cards, this could impact the flash's lifetime. OH provides classes to store cache in RAM.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464638030", "createdAt": "2020-08-03T20:14:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTk3Ng==", "bodyText": "Can you cache received values and provide those?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464639976", "createdAt": "2020-08-03T20:18:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTI2NQ==", "bodyText": "Can you use speaking variable names when using them over a larger amount of code lines?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641265", "createdAt": "2020-08-03T20:21:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTc4OQ==", "bodyText": "It seems a bit unreasonable to log the stack trace when the network fails.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641789", "createdAt": "2020-08-03T20:22:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTk5NQ==", "bodyText": "Super destructors should be called at the end of the concrete destructor.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641995", "createdAt": "2020-08-03T20:22:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjY2OQ==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464642669", "createdAt": "2020-08-03T20:24:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        final TACmiCoEBridgeHandler br = this.bridge;\n+        if (br != null)\n+            br.unregisterCMI(this);\n+        @Nullable\n+        final StateCacheUtils scu = this.stateCacheUtils;\n+        if (scu != null)\n+            scu.persistStates(podDatas.values());\n+    }\n+\n+    public boolean isFor(final InetAddress remoteAddress, final int node) {\n+        @Nullable\n+        final InetAddress cmia = this.cmiAddress;\n+        if (cmia == null)\n+            return false;\n+        return this.node == node && cmia.equals(remoteAddress);\n+    }\n+\n+    public void handleCoE(final Message message) {\n+        final ChannelTypeUID channelType = message.getType() == MessageType.D\n+                ? TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_IN_UID\n+                : TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_IN_UID;\n+        if (!this.online) {\n+            updateStatus(ThingStatus.ONLINE);\n+            this.online = true;\n+        }\n+        this.lastMessageRecvTS = System.currentTimeMillis();\n+        for (final Channel channel : thing.getChannels()) {\n+            if (!(channelType.equals(channel.getChannelTypeUID())))\n+                continue;\n+            final int output = ((Number) channel.getConfiguration().get(TACmiBindingConstants.CHANNEL_CONFIG_OUTPUT))\n+                    .intValue();\n+            if (!message.hasPortnumber(output))\n+                continue;\n+\n+            if (message.getType() == MessageType.A) {\n+                final AnalogValue value = ((AnalogMessage) message).getAnalogValue(output);\n+                logger.debug(\"Updating item {} / {} with state {}\", channel.getUID(), channel.getLabel(), value.value);\n+                updateState(channel.getUID(), new DecimalType(value.value));\n+            } else {\n+                final boolean state = ((DigitalMessage) message).getPortState(output);\n+                logger.debug(\"Updating item {} / {} with state {}\", channel.getUID(), channel.getLabel(), state);\n+                updateState(channel.getUID(), state ? OnOffType.ON : OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    public void monitor() {\n+        final long refTs = System.currentTimeMillis();\n+        if (online && refTs - this.lastMessageRecvTS > 900000) {\n+            // 30 sec no data - set thing to offline..\n+            this.online = false;\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"No update from C.M.I. for 15 min\");\n+        }\n+        for (final PodData pd : this.podDatas.values()) {\n+            if (pd == null) // Nullable check complains when this is missing...\n+                continue;\n+            @Nullable\n+            Message message = pd.message;\n+            if (message != null && refTs - pd.lastSent > 300000) {\n+                // reset every 300 secs...\n+                try {\n+                    @Nullable\n+                    final TACmiCoEBridgeHandler br = this.bridge;\n+                    @Nullable\n+                    final InetAddress cmia = this.cmiAddress;\n+                    if (br != null && cmia != null) {\n+                        br.sendData(message.getRaw(), cmia);\n+                        pd.lastSent = System.currentTimeMillis();\n+                    }\n+                } catch (final IOException e) {\n+                    logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mjk5Nw==", "bodyText": "Since we want to get rid of Apache Commons, can you replace this with native Java code? See #7722.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464642997", "createdAt": "2020-08-03T20:25:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiMeasureType.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This enum holds all the different measures and states available to be\n+ * retrieved by the TACmi binding, including the scale factors needed to convert the received values to the real\n+ * numbers.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum TACmiMeasureType {\n+    NONE(0, 1),\n+    TEMPERATURE(1, 10),\n+    UNKNOWN2(2, 1),\n+    UNKNOWN3(3, 1),\n+    SECONDS(4, 1),\n+    UNKNOWN5(5, 1),\n+    UNKNOWN6(6, 1),\n+    UNKNOWN7(7, 1),\n+    UNKNOWN8(8, 1),\n+    UNKNOWN9(9, 1),\n+    KILOWATT(10, 100),\n+    KILOWATTHOURS(11, 10),\n+    MEGAWATTHOURS(12, 1),\n+    UNKNOWN13(13, 1),\n+    UNKNOWN14(14, 1),\n+    UNKNOWN15(15, 1),\n+    UNKNOWN16(16, 1),\n+    UNKNOWN17(17, 1),\n+    UNKNOWN18(18, 1),\n+    UNKNOWN19(19, 1),\n+    UNKNOWN20(20, 1),\n+    UNKNOWN21(21, 1),\n+\n+    UNSUPPORTED(-1, 1);\n+\n+    private int typeval;\n+    private int offset;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TACmiMeasureType.class);\n+\n+    private TACmiMeasureType(int typeval, int offset) {\n+        this.typeval = typeval;\n+        this.offset = offset;\n+    }\n+\n+    public int getTypeValue() {\n+        return typeval;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    /**\n+     * Return the measure type for the specified name.\n+     *\n+     * @param measure\n+     * @return\n+     */\n+    public static TACmiMeasureType fromString(String measure) {\n+        if (!StringUtils.isEmpty(measure)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQxOQ==", "bodyText": "Is there a reason why the authors in this class are listed twice?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464643419", "createdAt": "2020-08-03T20:26:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogMessage.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Format of analog messages is as follows:\n+ *    1        2      3       4       5       6        7      8       9       10     11     12     13      14\n+ *    0        1      2       3       4       5        6      7       8        9     10     11     12      13\n+ * canNode 1|2|3|4 1.lower 1.upper 2.lower 2.upper 3.lower 3.upper 4.lower 4.upper 1.type 2.type 3.type 4.type\n+ *\n+ * possible values for type according to the documentation are 1 to 21.\n+ *\n+ * The documentation says for the types:\n+ *\n+ * 1: Degree Celsius\n+ * 2: Watts per square meter\n+ * 3: liters per hour\n+ * 4: seconds\n+ * 5: minutes\n+ * 6: liters per pulse\n+ * 7: Kelvin\n+ * 8: Percent\n+ * 9: Kilowatt\n+ * 10: Megawatthours\n+ * 11: Kilowatthours\n+ * 12: Volt\n+ * 13: Milliampere\n+ * 14: hours\n+ * 15: days\n+ * 16: pulses\n+ * 17: Kiloohm\n+ * 18: Kilometers per hour\n+ * 19: Hertz\n+ * 20: liters per minute\n+ * 21: bar\n+ *\n+ * However, reality shows that the documentation is partly not accurate. An UVR1611 device uses:\n+ *\n+ * 1: Degree Celsius\n+ * 4: Seconds\n+ * 10: Kilowatt\n+ * 11: Megawatthours\n+ * 12: Kilowatthours\n+ *\n+ * so we don't rely on the documentation.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ * @see TACmiMeasureType.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDIwOA==", "bodyText": "Loggers should only be final, not static. See https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644208", "createdAt": "2020-08-03T20:27:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogValue.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class handles analog values as used in the analog message.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class AnalogValue {\n+    public double value;\n+    public TACmiMeasureType measureType;\n+\n+    private static Logger logger = LoggerFactory.getLogger(AnalogValue.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDQ4Mw==", "bodyText": "Can this message be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644483", "createdAt": "2020-08-03T20:28:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/DigitalMessage.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+\n+/**\n+ * This class can be used to decode the digital values received in a messag and\n+ * also to create a new DigitalMessage used to send ON/OFF to an digital CAN\n+ * Input port\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class DigitalMessage extends Message {\n+\n+    public DigitalMessage(byte[] raw) {\n+        super(raw);\n+    }\n+\n+    /**\n+     * Create a new message to be sent to the CMI. It is only supported to use the\n+     * first port for each CAN node. This is due to the fact that all digital port\n+     * for the specific CAN node are send within a single message.\n+     */\n+    public DigitalMessage(byte canNode, byte podNr) {\n+        super(canNode, podNr);\n+        logger.debug(\"DigitalMessage: canNode: {}, podNumber: {}\", this.canNode, this.podNumber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDc2OQ==", "bodyText": "Loggers should be private.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644769", "createdAt": "2020-08-03T20:29:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/Message.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base message class handling generic functions.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public abstract class Message {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(Message.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk4Ng==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644986", "createdAt": "2020-08-03T20:29:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/Message.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base message class handling generic functions.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public abstract class Message {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(Message.class);\n+\n+    /**\n+     * ByteBuffer that stores the content of the message.\n+     */\n+    private ByteBuffer buffer;\n+\n+    /**\n+     * CAN Node number used in the message\n+     */\n+    public byte canNode;\n+\n+    /**\n+     * POD number used in the message\n+     */\n+    public byte podNumber;\n+\n+    /**\n+     * Initialize from the bytes of a received message\n+     *\n+     * @param raw\n+     */\n+    public Message(byte[] raw) {\n+        this.buffer = ByteBuffer.wrap(raw);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        this.canNode = buffer.get(0);\n+        this.podNumber = buffer.get(1);\n+    }\n+\n+    /**\n+     * Used to create a new message with the specified CAN node and POD number\n+     *\n+     * @param canNode\n+     * @param podNumber\n+     */\n+    public Message(int canNode, int podNumber) {\n+        this.buffer = ByteBuffer.allocate(14);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        setCanNode(canNode);\n+        setPodNumber(podNumber);\n+    }\n+\n+    public abstract void debug(Logger logger);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTM1OQ==", "bodyText": "Can you write these out?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464645359", "createdAt": "2020-08-03T20:30:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/MessageType.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+/**\n+ * This enumeration represents the different message types provided by the C.M.I COE protocol.\n+ * \n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum MessageType {\n+    A,\n+    D", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTU2NA==", "bodyText": "Enums should also be annotated with @NonNullByDefault.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464645564", "createdAt": "2020-08-03T20:30:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/MessageType.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+/**\n+ * This enumeration represents the different message types provided by the C.M.I COE protocol.\n+ * \n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum MessageType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjEyNg==", "bodyText": "Enum values should be all upper case.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646126", "createdAt": "2020-08-03T20:31:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjUxOA==", "bodyText": "Can you please annotate this class with @NonNullByDefault?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646518", "createdAt": "2020-08-03T20:32:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Njc4OQ==", "bodyText": "@NonNull is not necessary when annotating the class with @NonNullByDefault.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646789", "createdAt": "2020-08-03T20:33:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Nzc0NQ==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464647745", "createdAt": "2020-08-03T20:35:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Nzg4Mg==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464647882", "createdAt": "2020-08-03T20:35:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.Init && len == 1 && buffer[offset] == '\\n') {\n+            // single newline - ignore/drop it...\n+        } else {\n+            logger.info(\"Unexpected Text {}:{}: ({}) {} \", line, col, len, new String(buffer, offset, len));\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        // this.taCmiSchemaHandler.thingUpdated(thing);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODQ3Mg==", "bodyText": "Apache Commons. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464648472", "createdAt": "2020-08-03T20:36:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.Init && len == 1 && buffer[offset] == '\\n') {\n+            // single newline - ignore/drop it...\n+        } else {\n+            logger.info(\"Unexpected Text {}:{}: ({}) {} \", line, col, len, new String(buffer, offset, len));\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        // this.taCmiSchemaHandler.thingUpdated(thing);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently not retrieveable..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case Button:\n+                type = Type.SwitchButton;\n+                state = this.buttonValue == ButtonValue.On ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case ReadOnly:\n+            case FormValue:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.ReadOnlySwitch;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SwitchForm;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        BigDecimal bd = new BigDecimal(valParts[0]);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.info(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.ReadOnlyNumeric;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NumericForm;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.ReadOnlyState;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.StateForm;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case Unknown:\n+            case Ignore:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FormValue) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser());\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);\n+                this.configChanged = true;\n+                ChannelUID channelUID = new ChannelUID(this.taCmiSchemaHandler.getThing().getUID(), shortName);\n+                ChannelBuilder channelBuilder = ChannelBuilder.create(channelUID, channelType);\n+                channelBuilder.withLabel(description);\n+                if (ctuid != null) {\n+                    channelBuilder.withType(ctuid);\n+                } else if (cx2e != null) {\n+                    StateDescriptionFragmentBuilder sdb = StateDescriptionFragmentBuilder.create()\n+                            .withReadOnly(type.readOnly);\n+                    String itemType;\n+                    switch (cx2e.optionType) {\n+                        case Number:\n+                            itemType = \"Number\";\n+                            String min = cx2e.options.get(ChangerX2Entry.NUMBER_MIN);\n+                            if (StringUtils.isNotBlank(min)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTQ1OA==", "bodyText": "See above. and below.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464649458", "createdAt": "2020-08-03T20:38:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Entry.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link ChangerX2Entry} class contains mapping information for a changerX2 entry of\n+ * the API page element\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Entry {\n+\n+    public static final String NUMBER_MIN = \"min\";\n+    public static final String NUMBER_MAX = \"max\";\n+    public static final String NUMBER_STEP = \"step\";\n+\n+    static enum OptionType {\n+        Number,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTg0OQ==", "bodyText": "See above. Annotation.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464649849", "createdAt": "2020-08-03T20:39:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDE5NA==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650194", "createdAt": "2020-08-03T20:40:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        Input,\n+        InputData,\n+        Select,\n+        SelectOption,\n+        Unknown\n+    }\n+\n+    private @Nullable String curOptionId;\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private @NonNull Map<@NonNull String, @Nullable String> options;\n+\n+    public ChangerX2Parser() {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final String elementName, final Map<String, String> attributes,\n+            final boolean minimized, final int line, final int col) throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final String elementName, final Map<String, String> attributes, final int line,\n+            final int col) throws ParseException {\n+\n+        String id = attributes == null ? null : attributes.get(\"id\");\n+\n+        if (this.parserState == ParserState.Init && \"input\".equals(elementName) && \"changeadr\".equals(id)) {\n+            this.parserState = ParserState.Input;\n+            if (attributes == null) {\n+                this.address = null;\n+                this.addressFieldName = null;\n+            } else {\n+                this.addressFieldName = attributes.get(\"name\");\n+                this.address = attributes.get(\"value\");\n+            }\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"select\".equals(elementName)) {\n+            this.parserState = ParserState.Select;\n+            this.optionFieldName = attributes == null ? null : attributes.get(\"name\");\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"br\".equals(elementName)) {\n+            // ignored\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"input\".equals(elementName) && \"changeto\".equals(id)) {\n+            this.parserState = ParserState.InputData;\n+            if (attributes != null) {\n+                this.optionFieldName = attributes.get(\"name\");\n+                String type = attributes.get(\"type\");\n+                if (\"number\".equals(type)) {\n+                    this.optionType = OptionType.Number;\n+                    // we transfer the limits from the input elemnt...\n+                    this.options.put(ChangerX2Entry.NUMBER_MIN, attributes.get(ChangerX2Entry.NUMBER_MIN));\n+                    this.options.put(ChangerX2Entry.NUMBER_MAX, attributes.get(ChangerX2Entry.NUMBER_MAX));\n+                    this.options.put(ChangerX2Entry.NUMBER_STEP, attributes.get(ChangerX2Entry.NUMBER_STEP));\n+                } else {\n+                    logger.warn(\"Unhandled input field in {}:{}: {}\", line, col, attributes);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.Select && \"option\".equals(elementName)) {\n+            this.parserState = ParserState.SelectOption;\n+            this.optionType = OptionType.Select;\n+            this.curOptionValue = new StringBuilder();\n+            this.curOptionId = attributes == null ? null : attributes.get(\"value\");\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.Input && \"input\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+        } else if (this.parserState == ParserState.Select && \"select\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+        } else if (this.parserState == ParserState.SelectOption && \"option\".equals(elementName)) {\n+            this.parserState = ParserState.Select;\n+            StringBuilder sb = this.curOptionValue;\n+            String value = sb != null && sb.length() > 0 ? sb.toString().trim() : null;\n+            this.curOptionValue = null;\n+            String id = this.curOptionId;\n+            this.curOptionId = null;\n+            if (value != null) {\n+                if (id == null || !StringUtils.isNotBlank(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDQzNw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650437", "createdAt": "2020-08-03T20:40:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDg4Mg==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650882", "createdAt": "2020-08-03T20:41:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTAzNA==", "bodyText": "Apache Commons. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651034", "createdAt": "2020-08-03T20:42:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTE0MQ==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651141", "createdAt": "2020-08-03T20:42:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTc3OA==", "bodyText": "This should be scheduleWithFixedDelay. See https://www.openhab.org/docs/developer/guidelines.html#e-runtime-behavior Point 2.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651778", "createdAt": "2020-08-03T20:43:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MjUwMA==", "bodyText": "Can you decrease the timeout to e.g. 10 sec., as it will block the OH scheduler thread pool and will throw an exception after 15 sec.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464652500", "createdAt": "2020-08-03T20:45:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzAyNg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653026", "createdAt": "2020-08-03T20:46:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzA5MQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653091", "createdAt": "2020-08-03T20:46:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {\n+            logger.error(\"Error loading API Scheme: {} \", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzM3Ng==", "bodyText": "This can be done with OH's cache classes.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653376", "createdAt": "2020-08-03T20:46:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {\n+            logger.error(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO how to debounce this? we could trigger refreshData() but during startup\n+            // this issues lots of requests... :-/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NTM1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>This bridge opens the CoE-UDP Port 5441 on OpenHAB for communikation with \"Technsche Alternative C.M.I.\"</description>\n          \n          \n            \n            \t\t<description>This bridge opens the CoE-UDP Port 5441 on OpenHAB for communication with \"Technische Alternative C.M.I.\"</description>", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464655350", "createdAt": "2020-08-03T20:51:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/resources/ESH-INF/thing/bridge.xml", "diffHunk": "@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tacmi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"coe-bridge\">\n+\t\t<label>TA C.M.I. CoE Bridge</label>\n+\t\t<description>This bridge opens the CoE-UDP Port 5441 on OpenHAB for communikation with \"Technsche Alternative C.M.I.\"</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NjI0OQ==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>A digital channel sent from C.M.I. to OpenHAB</description>\n          \n          \n            \n            \t\t<description>A digital channel sent from C.M.I. to openHAB</description>", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464656249", "createdAt": "2020-08-03T20:53:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,163 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tacmi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"cmi\" extensible=\"coe-digital-in,coe-digital-out,coe-analog-in,coe-analog-out\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"coe-bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>TA C.M.I. CoE Connection</label>\n+\t\t<description>CoE Communication to the \"Technische Alternative C.M.I. Control and Monitoring Interface\"</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>CMI IP Address</label>\n+\t\t\t\t<description>Hostname of IP address of the CMI</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"node\" type=\"integer\" min=\"1\" max=\"62\" required=\"true\">\n+\t\t\t\t<label>Node</label>\n+\t\t\t\t<description>CoE / CAN Node number</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- CoE digital Channel Type -->\n+\t<channel-type id=\"coe-digital-in\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Input (C.M.I. -> OH)</label>\n+\t\t<description>A digital channel sent from C.M.I. to OpenHAB</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NjY1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t<option value=\"10\">kw (Kilowatt) </option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"11\">kwh (Kilowatt hours)</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"12\">mwh (Megawatt hours)</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"10\">kW (Kilowatt) </option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"11\">kWh (Kilowatt hours)</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"12\">MWh (Megawatt hours)</option>", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464656657", "createdAt": "2020-08-03T20:54:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,163 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tacmi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"cmi\" extensible=\"coe-digital-in,coe-digital-out,coe-analog-in,coe-analog-out\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"coe-bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>TA C.M.I. CoE Connection</label>\n+\t\t<description>CoE Communication to the \"Technische Alternative C.M.I. Control and Monitoring Interface\"</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>CMI IP Address</label>\n+\t\t\t\t<description>Hostname of IP address of the CMI</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"node\" type=\"integer\" min=\"1\" max=\"62\" required=\"true\">\n+\t\t\t\t<label>Node</label>\n+\t\t\t\t<description>CoE / CAN Node number</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- CoE digital Channel Type -->\n+\t<channel-type id=\"coe-digital-in\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Input (C.M.I. -> OH)</label>\n+\t\t<description>A digital channel sent from C.M.I. to OpenHAB</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-digital-out\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Output (OH -> C.M.I.)</label>\n+\t\t<description>A digital channel sent from OpenHAB to C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<!-- COA analog Channel Type -->\n+\t<channel-type id=\"coe-analog-in\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Input Channel (C.M.I. -> OH)</label>\n+\t\t<description>A Analog Channel received from the C.M.I.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-analog-out\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Output Channel (OH -> C.M.I.)</label>\n+\t\t<description>A Analog Channel sent to the C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"type\" type=\"integer\" min=\"0\" max=\"21\" required=\"true\">\n+\t\t\t\t<label>Measurement Type</label>\n+\t\t\t\t<description>Measurement type for this channel</description>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"0\">None</option>\n+\t\t\t\t\t<option value=\"1\">Temperature</option>\n+\t\t\t\t\t<option value=\"2\">Unknown 2</option>\n+\t\t\t\t\t<option value=\"3\">Unknown 3</option>\n+\t\t\t\t\t<option value=\"4\">Seconds</option>\n+\t\t\t\t\t<option value=\"5\">Unknown 5</option>\n+\t\t\t\t\t<option value=\"6\">Unknown 6</option>\n+\t\t\t\t\t<option value=\"7\">Unknown 7</option>\n+\t\t\t\t\t<option value=\"8\">Unknown 8</option>\n+\t\t\t\t\t<option value=\"9\">Unknown 9</option>\n+\t\t\t\t\t<option value=\"10\">kw (Kilowatt) </option>\n+\t\t\t\t\t<option value=\"11\">kwh (Kilowatt hours)</option>\n+\t\t\t\t\t<option value=\"12\">mwh (Megawatt hours)</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1Njc2Nw==", "bodyText": "Words in labels should be capitalized. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464656767", "createdAt": "2020-08-03T20:54:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,163 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tacmi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"cmi\" extensible=\"coe-digital-in,coe-digital-out,coe-analog-in,coe-analog-out\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"coe-bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>TA C.M.I. CoE Connection</label>\n+\t\t<description>CoE Communication to the \"Technische Alternative C.M.I. Control and Monitoring Interface\"</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>CMI IP Address</label>\n+\t\t\t\t<description>Hostname of IP address of the CMI</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"node\" type=\"integer\" min=\"1\" max=\"62\" required=\"true\">\n+\t\t\t\t<label>Node</label>\n+\t\t\t\t<description>CoE / CAN Node number</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- CoE digital Channel Type -->\n+\t<channel-type id=\"coe-digital-in\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Input (C.M.I. -> OH)</label>\n+\t\t<description>A digital channel sent from C.M.I. to OpenHAB</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-digital-out\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Output (OH -> C.M.I.)</label>\n+\t\t<description>A digital channel sent from OpenHAB to C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<!-- COA analog Channel Type -->\n+\t<channel-type id=\"coe-analog-in\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Input Channel (C.M.I. -> OH)</label>\n+\t\t<description>A Analog Channel received from the C.M.I.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-analog-out\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Output Channel (OH -> C.M.I.)</label>\n+\t\t<description>A Analog Channel sent to the C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"type\" type=\"integer\" min=\"0\" max=\"21\" required=\"true\">\n+\t\t\t\t<label>Measurement Type</label>\n+\t\t\t\t<description>Measurement type for this channel</description>\n+\t\t\t\t<options>\n+\t\t\t\t\t<option value=\"0\">None</option>\n+\t\t\t\t\t<option value=\"1\">Temperature</option>\n+\t\t\t\t\t<option value=\"2\">Unknown 2</option>\n+\t\t\t\t\t<option value=\"3\">Unknown 3</option>\n+\t\t\t\t\t<option value=\"4\">Seconds</option>\n+\t\t\t\t\t<option value=\"5\">Unknown 5</option>\n+\t\t\t\t\t<option value=\"6\">Unknown 6</option>\n+\t\t\t\t\t<option value=\"7\">Unknown 7</option>\n+\t\t\t\t\t<option value=\"8\">Unknown 8</option>\n+\t\t\t\t\t<option value=\"9\">Unknown 9</option>\n+\t\t\t\t\t<option value=\"10\">kw (Kilowatt) </option>\n+\t\t\t\t\t<option value=\"11\">kwh (Kilowatt hours)</option>\n+\t\t\t\t\t<option value=\"12\">mwh (Megawatt hours)</option>\n+\t\t\t\t\t<option value=\"13\">Unknown 13</option>\n+\t\t\t\t\t<option value=\"14\">Unknown 14</option>\n+\t\t\t\t\t<option value=\"15\">Unknown 15</option>\n+\t\t\t\t\t<option value=\"16\">Unknown 16</option>\n+\t\t\t\t\t<option value=\"17\">Unknown 17</option>\n+\t\t\t\t\t<option value=\"18\">Unknown 18</option>\n+\t\t\t\t\t<option value=\"19\">Unknown 19</option>\n+\t\t\t\t\t<option value=\"20\">Unknown 20</option>\n+\t\t\t\t\t<option value=\"21\">Unknown 21</option>\n+\t\t\t\t</options>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\n+\t<thing-type id=\"cmiSchema\" extensible=\"schema-switch-ro,schema-switch-rw,schema-numeric-ro,schema-state-ro\">\n+\t\t<label>TA C.M.I. schema API connection</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1NzUwNA==", "bodyText": "cacmi?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464657504", "createdAt": "2020-08-03T20:55:59Z", "author": {"login": "fwolter"}, "path": "bom/openhab-addons/pom.xml", "diffHunk": "@@ -144,6 +144,11 @@\n       <artifactId>org.openhab.binding.buienradar</artifactId>\n       <version>${project.version}</version>\n     </dependency>\n+    <dependency>\n+      <groupId>org.openhab.addons.bundles</groupId>\n+      <artifactId>org.openhab.binding.cacmi</artifactId>\n+      <version>${project.version}</version>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTE1MzY0", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-461115364", "createdAt": "2020-08-04T19:36:09Z", "commit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTozNjowOVrOG7uuzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo1OToxNVrOG7vcCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NDgxMg==", "bodyText": "Yes, this would be possible. But from my observations theses Refresh-Messages only occur during startup when we don't have data received from the TA equipment. TA only sends data periodically or on change, but there is no known way of polling current values.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465284812", "createdAt": "2020-08-04T19:36:09Z", "author": {"login": "marvkis"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTk3Ng=="}, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjU2NA==", "bodyText": "I didn't get it to work. Maybe you could give me a pointer into the right direction: There are callback-Methods with maps, like this method:\n    public void handleStandaloneElement(final @Nullable String elementName,\n            final @Nullable Map<String, @Nullable String> attributes, final boolean minimized, final int line, final int col)\n            throws ParseException {\n\nWhen I activate the @NonNullByDefault I get error messages like\n\nIllegal redefinition of parameter attributes, inherited method from AbstractSimpleMarkupHandler declares this parameter as 'Map<String,String>' (mismatching null constraints)\n\nWhen I get this solved I would love adding the @NonNullByDefault annotation", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465292564", "createdAt": "2020-08-04T19:51:43Z", "author": {"login": "marvkis"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjUxOA=="}, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mzg0Ng==", "bodyText": "Okay, I definitively have to have a look on the cache classes. I'm not aware of them.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465293846", "createdAt": "2020-08-04T19:54:15Z", "author": {"login": "marvkis"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {\n+            logger.error(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO how to debounce this? we could trigger refreshData() but during startup\n+            // this issues lots of requests... :-/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzM3Ng=="}, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjM5NQ==", "bodyText": "good question. Is from the original binding. Might be stale - I already removed a bunch of stale methods. Will dig into it...", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465296395", "createdAt": "2020-08-04T19:59:15Z", "author": {"login": "marvkis"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/Message.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base message class handling generic functions.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public abstract class Message {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(Message.class);\n+\n+    /**\n+     * ByteBuffer that stores the content of the message.\n+     */\n+    private ByteBuffer buffer;\n+\n+    /**\n+     * CAN Node number used in the message\n+     */\n+    public byte canNode;\n+\n+    /**\n+     * POD number used in the message\n+     */\n+    public byte podNumber;\n+\n+    /**\n+     * Initialize from the bytes of a received message\n+     *\n+     * @param raw\n+     */\n+    public Message(byte[] raw) {\n+        this.buffer = ByteBuffer.wrap(raw);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        this.canNode = buffer.get(0);\n+        this.podNumber = buffer.get(1);\n+    }\n+\n+    /**\n+     * Used to create a new message with the specified CAN node and POD number\n+     *\n+     * @param canNode\n+     * @param podNumber\n+     */\n+    public Message(int canNode, int podNumber) {\n+        this.buffer = ByteBuffer.allocate(14);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        setCanNode(canNode);\n+        setPodNumber(podNumber);\n+    }\n+\n+    public abstract void debug(Logger logger);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk4Ng=="}, "originalCommit": {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8"}, "originalPosition": 73}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "261a3da3987c3749d12f1ef79db35dfffd32238c", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/261a3da3987c3749d12f1ef79db35dfffd32238c", "committedDate": "2020-08-09T15:31:27Z", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}, "afterCommit": {"oid": "16574f01b7741b841f909d5587c3b7ede905aee6", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/16574f01b7741b841f909d5587c3b7ede905aee6", "committedDate": "2020-08-09T15:36:32Z", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8d9a30941fc3c40a9c47402546360fa7bdb6f66", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/a8d9a30941fc3c40a9c47402546360fa7bdb6f66", "committedDate": "2020-09-05T20:57:57Z", "message": "[tacmi] Initial push of OpenHAB 2 ported tacmi binding\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8ee35abafee339d844b7c917ff9ce7b99653ca", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/eb8ee35abafee339d844b7c917ff9ce7b99653ca", "committedDate": "2020-09-05T20:57:57Z", "message": "[tacmi] fixed travis errors & added some @NonNullByDefault\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe7360d26a2c357cae3548c186b72a03aa48cc03", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/fe7360d26a2c357cae3548c186b72a03aa48cc03", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] fixed further travis errors & warnings, especially Null handling stuff...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4977fc39c09766bb2f9036df578ee66d53a5f5a", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/f4977fc39c09766bb2f9036df578ee66d53a5f5a", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] fixed further travis errors & warnings, especially Null handling stuff...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "882889d4d4e25e420f5136dc867bae3e52d2f58c", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/882889d4d4e25e420f5136dc867bae3e52d2f58c", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] fixed a XML identing issue causing travis to fail..\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8dc115317627e463bfdec6a2510c99ea0c557f6", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/d8dc115317627e463bfdec6a2510c99ea0c557f6", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] executed `mvn spotless:apply` to fix formatting issues\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f84759065021e87eeee9a6ae5b4594744303a0b", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/1f84759065021e87eeee9a6ae5b4594744303a0b", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] initial WIP-Checkin of the \"Schema API Page\" variant\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60c69f29c8dc7b05e2287017bc9b6019257198b3", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/60c69f29c8dc7b05e2287017bc9b6019257198b3", "committedDate": "2020-09-05T20:57:58Z", "message": "[tacmi] added initial documentation for the new API Page thing\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "882c6fdefdd282518f491334a006b4f61cba2f92", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/882c6fdefdd282518f491334a006b4f61cba2f92", "committedDate": "2020-09-05T20:57:59Z", "message": "[tacmi] Apply suggestions from code review\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92171cd76e71650ec1adaed3e40484ca6a6017b4", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/92171cd76e71650ec1adaed3e40484ca6a6017b4", "committedDate": "2020-09-05T20:57:59Z", "message": "[tacmi] ApiPageParser - added new unit 'Hz'\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1c13cb7ae0d82ed9070b0a699fa4a04c26a9d22", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/d1c13cb7ae0d82ed9070b0a699fa4a04c26a9d22", "committedDate": "2020-09-05T20:57:59Z", "message": "[tacmi] Applied requested changes from code review - stright forward changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed8e26a5a922251c062620780230d6a324cbfb87", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/ed8e26a5a922251c062620780230d6a324cbfb87", "committedDate": "2020-09-05T20:57:59Z", "message": "[tacmi] Applied requested changes from code review - RefreshType for TACmiSchemaHandler\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "079a9169e19bd914980c52057ecb09dd7aa9de5f", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/079a9169e19bd914980c52057ecb09dd7aa9de5f", "committedDate": "2020-09-05T20:57:59Z", "message": "[tacmi] CoE communication: added thing config parameter 'persistInterval' to configure behavour of the integrated persistence service\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "040bd741d2f9f9e2f922971f1bed10c06b025709", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/040bd741d2f9f9e2f922971f1bed10c06b025709", "committedDate": "2020-09-05T20:58:00Z", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9498632c0ed5b79289539b564e50d0aedef1e9f", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/b9498632c0ed5b79289539b564e50d0aedef1e9f", "committedDate": "2020-09-05T20:58:00Z", "message": "[tacmi] Made @NonNullByDefault with ApiPageParser & ChangerX2Parser\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e2d5854ea4c494b00d5ad7f68bd2ca1d3a479a3", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/9e2d5854ea4c494b00d5ad7f68bd2ca1d3a479a3", "committedDate": "2020-09-05T20:58:00Z", "message": "[tacmi] schema thing: improved logging in ChangerX2Parser and suppressed some irrelevant loggings during startup\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68d8f04e21c7770385cb074eb106492b372aded2", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/68d8f04e21c7770385cb074eb106492b372aded2", "committedDate": "2020-09-05T20:58:00Z", "message": "[tacmi] CoE thing: removed persistence layer; channel configuration property for setting initial values for channel initialization; prevent sending of pod's having uninitialized values; some refactoring of coe related classes to .../tacmi/internal/coe/ to have a clear separation between schema and coe thing's\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40a6d5f04f6bb9240f49287f8fc19790016ae5b9", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/40a6d5f04f6bb9240f49287f8fc19790016ae5b9", "committedDate": "2020-09-05T20:58:00Z", "message": "[tacmi] Schema thing: Initial support for older pre-X2 devices\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddb472c601270370b7dc9c2d8041477833ec9337", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/ddb472c601270370b7dc9c2d8041477833ec9337", "committedDate": "2020-09-05T20:58:01Z", "message": "[tacmi] Improved documentation\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/d9bc1bd3fe058ae23694227ffb55051df030e9ab", "committedDate": "2020-09-05T21:00:03Z", "message": "[tacmi] upgraded to 2.5.9 and applied latest spotless rules\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16574f01b7741b841f909d5587c3b7ede905aee6", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/16574f01b7741b841f909d5587c3b7ede905aee6", "committedDate": "2020-08-09T15:36:32Z", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}, "afterCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/d9bc1bd3fe058ae23694227ffb55051df030e9ab", "committedDate": "2020-09-05T21:00:03Z", "message": "[tacmi] upgraded to 2.5.9 and applied latest spotless rules\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMTYyMDc4", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-483162078", "createdAt": "2020-09-06T17:55:20Z", "commit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxNzo1NToyMFrOHNq9WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxODowOToyMFrOHNrCTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzM2OQ==", "bodyText": "There's a new thread naming scheme. See #8216\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n          \n          \n            \n                        super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097369", "createdAt": "2020-09-06T17:55:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzQ0OQ==", "bodyText": "Logging to info should be used rarely. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097449", "createdAt": "2020-09-06T17:56:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYyNA==", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {\n          \n          \n            \n                    if (timeoutCheckFuture != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097624", "createdAt": "2020-09-06T17:58:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,\n+                                node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        // clean up the timeout check\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY3Ng==", "bodyText": "Logging to info", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097676", "createdAt": "2020-09-06T17:58:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,\n+                                node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        // clean up the timeout check\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {\n+            timeoutCheckFuture.cancel(true);\n+            this.timeoutCheckFuture = null;\n+        }\n+\n+        // clean up the receive thread\n+        ReceiveThread receiveThread = this.receiveThread;\n+        if (receiveThread != null) {\n+            receiveThread.interrupt(); // just interrupt it so when the socketException throws it's flagged as\n+                                       // interrupted.\n+        }\n+\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock != null && !sock.isClosed()) {\n+            sock.close();\n+            this.coeSocket = null;\n+        }\n+        if (receiveThread != null) {\n+            receiveThread.interrupt();\n+            try {\n+                // it should join quite quick as we already closed the socket which should have the receiver thread\n+                // caused to stop.\n+                receiveThread.join(250);\n+            } catch (final InterruptedException e) {\n+                logger.info(\"Unexpected interrupt in receiveThread.join(): {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (portNumber - 1) / 4 == podNumber - 1 ? true : false;\n          \n          \n            \n                    return (portNumber - 1) / 4 == podNumber - 1;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097952", "createdAt": "2020-09-06T18:01:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogMessage.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Format of analog messages is as follows:\n+ * 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n+ * 0 1 2 3 4 5 6 7 8 9 10 11 12 13\n+ * canNode 1|2|3|4 1.lower 1.upper 2.lower 2.upper 3.lower 3.upper 4.lower 4.upper 1.type 2.type 3.type 4.type\n+ *\n+ * possible values for type according to the documentation are 1 to 21.\n+ *\n+ * The documentation says for the types:\n+ *\n+ * 1: Degree Celsius\n+ * 2: Watts per square meter\n+ * 3: liters per hour\n+ * 4: seconds\n+ * 5: minutes\n+ * 6: liters per pulse\n+ * 7: Kelvin\n+ * 8: Percent\n+ * 9: Kilowatt\n+ * 10: Megawatthours\n+ * 11: Kilowatthours\n+ * 12: Volt\n+ * 13: Milliampere\n+ * 14: hours\n+ * 15: days\n+ * 16: pulses\n+ * 17: Kiloohm\n+ * 18: Kilometers per hour\n+ * 19: Hertz\n+ * 20: liters per minute\n+ * 21: bar\n+ *\n+ * However, reality shows that the documentation is partly not accurate. An UVR1611 device uses:\n+ *\n+ * 1: Degree Celsius\n+ * 4: Seconds\n+ * 10: Kilowatt\n+ * 11: Megawatthours\n+ * 12: Kilowatthours\n+ *\n+ * so we don't rely on the documentation.\n+ *\n+ * This class can be used to decode the analog values received in a message and\n+ * also to create a new AnalogMessage used to send analog values to an analog\n+ * CAN Input port. Creation of new message is not implemented so far.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class AnalogMessage extends Message {\n+\n+    /**\n+     * Used to parse the data received from the CMI.\n+     *\n+     * @param raw\n+     */\n+    public AnalogMessage(byte[] raw) {\n+        super(raw);\n+    }\n+\n+    /**\n+     * Create a new message to be sent to the CMI. It is only supported to use\n+     * the first port for each podNumber.\n+     */\n+    public AnalogMessage(byte canNode, byte podNumber) {\n+        super(canNode, podNumber);\n+    }\n+\n+    /**\n+     * Get the value for the specified port number.\n+     *\n+     * @param portNumber\n+     * @return\n+     */\n+    public AnalogValue getAnalogValue(int portNumber) {\n+        // Get the internal index for portNumber within the message\n+        int idx = (portNumber - 1) % 4;\n+        AnalogValue value = new AnalogValue(this.getValue(idx), getMeasureType(idx));\n+        return value;\n+    }\n+\n+    /**\n+     * Check if message contains a value for the specified port number. It\n+     * doesn't matter though if the port has a value of 0.\n+     *\n+     * @param portNumber\n+     * @return\n+     */\n+    @Override\n+    public boolean hasPortnumber(int portNumber) {\n+        return (portNumber - 1) / 4 == podNumber - 1 ? true : false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODA4Mg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098082", "createdAt": "2020-09-06T18:02:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODA5Mg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098092", "createdAt": "2020-09-06T18:03:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODExNg==", "bodyText": "See above and below", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098116", "createdAt": "2020-09-06T18:03:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODI3MQ==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098271", "createdAt": "2020-09-06T18:05:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 418}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODMyMQ==", "bodyText": "A parsing error shouldn't be logged as error. This could be warn.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098321", "createdAt": "2020-09-06T18:05:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1NQ==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098355", "createdAt": "2020-09-06T18:05:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);\n+                this.configChanged = true;\n+                ChannelUID channelUID = new ChannelUID(this.taCmiSchemaHandler.getThing().getUID(), shortName);\n+                ChannelBuilder channelBuilder = ChannelBuilder.create(channelUID, channelType);\n+                channelBuilder.withLabel(description);\n+                if (ctuid != null) {\n+                    channelBuilder.withType(ctuid);\n+                } else if (cx2e != null) {\n+                    StateDescriptionFragmentBuilder sdb = StateDescriptionFragmentBuilder.create()\n+                            .withReadOnly(type.readOnly);\n+                    String itemType;\n+                    switch (cx2e.optionType) {\n+                        case NUMBER:\n+                            itemType = \"Number\";\n+                            String min = cx2e.options.get(ChangerX2Entry.NUMBER_MIN);\n+                            if (min != null && !min.trim().isEmpty()) {\n+                                sdb.withMinimum(new BigDecimal(min));\n+                            }\n+                            String max = cx2e.options.get(ChangerX2Entry.NUMBER_MAX);\n+                            if (max != null && !max.trim().isEmpty()) {\n+                                sdb.withMaximum(new BigDecimal(max));\n+                            }\n+                            String step = cx2e.options.get(ChangerX2Entry.NUMBER_STEP);\n+                            if (step != null && !step.trim().isEmpty()) {\n+                                sdb.withStep(new BigDecimal(step));\n+                            }\n+                            break;\n+                        case SELECT:\n+                            itemType = \"String\";\n+                            for (Entry<String, @Nullable String> entry : cx2e.options.entrySet()) {\n+                                String val = entry.getValue();\n+                                if (val != null) {\n+                                    sdb.withOption(new StateOption(val, entry.getKey()));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            throw new IllegalStateException();\n+                    }\n+                    ChannelType ct = ChannelTypeBuilder\n+                            .state(new ChannelTypeUID(TACmiBindingConstants.BINDING_ID, shortName), shortName, itemType)\n+                            .withDescription(\"Auto-created for \" + shortName)\n+                            .withStateDescription(sdb.build().toStateDescription())\n+                            // .withCategory(\"CategoryName\") can we do something useful ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM4NQ==", "bodyText": "See above and below", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098385", "createdAt": "2020-09-06T18:06:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        INPUT,\n+        INPUT_DATA,\n+        SELECT,\n+        SELECT_OPTION,\n+        UNKNOWN\n+    }\n+\n+    private final String channelName;\n+    private @Nullable String curOptionId;\n+    private ParserState parserState = ParserState.INIT;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private Map<String, @Nullable String> options;\n+\n+    public ChangerX2Parser(String channelName) {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+        this.channelName = channelName;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final String elementName, final Map<String, String> attributes,\n+            final boolean minimized, final int line, final int col) throws ParseException {\n+\n+        logger.info(\"Error parsing options for {}: Unexpected StandaloneElement in {}{}: {} [{}]\", channelName, line,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODU1NA==", "bodyText": "Protocol errors shouldn't be logged to error. This could be warn. Also it seems unreasonable to log the stack trace when the network fails.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098554", "createdAt": "2020-09-06T18:08:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        // we want to trigger the initial refresh 'at once'\n+        this.scheduledFuture = scheduler.scheduleWithFixedDelay(this::refreshData, 0, config.pollInterval,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(10000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        String encoding = response.getEncoding();\n+        if (encoding == null || encoding.trim().isEmpty()) {\n+            // the C.M.I. dosn't sometime return a valid encoding - but it defaults to UTF-8 instead of ISO...\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // binding shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n+            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n+            // troubleshoot this\n+            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        final ApiPageEntry e = this.entries.get(channelUID.getId());\n+        if (command instanceof RefreshType) {\n+            if (e == null) {\n+                // This might be a race condition between the 'initial' poll / fetch not finished yet or the channel\n+                // might have been deleted in between. When the initial poll is still in progress, it will send an\n+                // update for the channel as soon as we have the data. If the channel got deleted, there is nothing we\n+                // can do.\n+                return;\n+            }\n+            // we have our ApiPageEntry which also holds our last known state - just update it.\n+            updateState(channelUID, e.getLastState());\n+            return;\n+        }\n+        if (e == null) {\n+            logger.warn(\"Got command for unknown channel {}: {}\", channelUID, command);\n+            return;\n+        }\n+        final Request reqUpdate;\n+        switch (e.type) {\n+            case SWITCH_BUTTON:\n+                reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + e.address + \"&changetox2=\"\n+                        + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                break;\n+            case SWITCH_FORM:\n+                ChangerX2Entry cx2e = e.changerX2Entry;\n+                if (cx2e != null) {\n+                    reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2e.address\n+                            + \"&changetox2=\" + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                    reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case STATE_FORM:\n+                ChangerX2Entry cx2sf = e.changerX2Entry;\n+                if (cx2sf != null) {\n+                    String val = cx2sf.options.get(((StringType) command).toFullString());\n+                    if (val != null) {\n+                        reqUpdate = prepareRequest(\n+                                buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2sf.address + \"&changetox2=\" + val));\n+                        reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                    } else {\n+                        logger.warn(\"Got unknown form command {} for channel {}; Valid commands are: {}\", command,\n+                                channelUID, cx2sf.options.keySet());\n+                        return;\n+                    }\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case READ_ONLY_NUMERIC:\n+            case READ_ONLY_STATE:\n+            case READ_ONLY_SWITCH:\n+                logger.warn(\"Got command for ReadOnly channel {}: {}\", channelUID, command);\n+                return;\n+            default:\n+                logger.warn(\"Got command for unhandled type {} channel {}: {}\", e.type, channelUID, command);\n+                return;\n+        }\n+        try {\n+            ContentResponse res = reqUpdate.send();\n+            if (res.getStatus() == 200) {\n+                // update ok, we update the state\n+                e.setLastState((State) command);\n+                updateState(channelUID, (State) command);\n+            } else {\n+                logger.error(\"Error sending update for {} = {}: {} {}\", channelUID, command, res.getStatus(),\n+                        res.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException ex) {\n+            logger.error(\"Error sending update for {} = {}: {}\", channelUID, command, ex.getMessage(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODYzNw==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098637", "createdAt": "2020-09-06T18:09:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        // we want to trigger the initial refresh 'at once'\n+        this.scheduledFuture = scheduler.scheduleWithFixedDelay(this::refreshData, 0, config.pollInterval,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(10000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        String encoding = response.getEncoding();\n+        if (encoding == null || encoding.trim().isEmpty()) {\n+            // the C.M.I. dosn't sometime return a valid encoding - but it defaults to UTF-8 instead of ISO...\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // binding shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n+            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n+            // troubleshoot this\n+            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        final ApiPageEntry e = this.entries.get(channelUID.getId());\n+        if (command instanceof RefreshType) {\n+            if (e == null) {\n+                // This might be a race condition between the 'initial' poll / fetch not finished yet or the channel\n+                // might have been deleted in between. When the initial poll is still in progress, it will send an\n+                // update for the channel as soon as we have the data. If the channel got deleted, there is nothing we\n+                // can do.\n+                return;\n+            }\n+            // we have our ApiPageEntry which also holds our last known state - just update it.\n+            updateState(channelUID, e.getLastState());\n+            return;\n+        }\n+        if (e == null) {\n+            logger.warn(\"Got command for unknown channel {}: {}\", channelUID, command);\n+            return;\n+        }\n+        final Request reqUpdate;\n+        switch (e.type) {\n+            case SWITCH_BUTTON:\n+                reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + e.address + \"&changetox2=\"\n+                        + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                break;\n+            case SWITCH_FORM:\n+                ChangerX2Entry cx2e = e.changerX2Entry;\n+                if (cx2e != null) {\n+                    reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2e.address\n+                            + \"&changetox2=\" + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                    reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case STATE_FORM:\n+                ChangerX2Entry cx2sf = e.changerX2Entry;\n+                if (cx2sf != null) {\n+                    String val = cx2sf.options.get(((StringType) command).toFullString());\n+                    if (val != null) {\n+                        reqUpdate = prepareRequest(\n+                                buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2sf.address + \"&changetox2=\" + val));\n+                        reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                    } else {\n+                        logger.warn(\"Got unknown form command {} for channel {}; Valid commands are: {}\", command,\n+                                channelUID, cx2sf.options.keySet());\n+                        return;\n+                    }\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case READ_ONLY_NUMERIC:\n+            case READ_ONLY_STATE:\n+            case READ_ONLY_SWITCH:\n+                logger.warn(\"Got command for ReadOnly channel {}: {}\", channelUID, command);\n+                return;\n+            default:\n+                logger.warn(\"Got command for unhandled type {} channel {}: {}\", e.type, channelUID, command);\n+                return;\n+        }\n+        try {\n+            ContentResponse res = reqUpdate.send();\n+            if (res.getStatus() == 200) {\n+                // update ok, we update the state\n+                e.setLastState((State) command);\n+                updateState(channelUID, (State) command);\n+            } else {\n+                logger.error(\"Error sending update for {} = {}: {} {}\", channelUID, command, res.getStatus(),\n+                        res.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException ex) {\n+            logger.error(\"Error sending update for {} = {}: {}\", channelUID, command, ex.getMessage(), ex);\n+        }\n+    }\n+\n+    // make it accessible for ApiPageParser\n+    @Override\n+    protected void updateState(final ChannelUID channelUID, final State state) {\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            try {\n+                scheduledFuture.cancel(true);\n+                this.scheduledFuture = null;\n+            } catch (final Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDE3NDg0", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-483417484", "createdAt": "2020-09-07T09:49:47Z", "commit": {"oid": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTo0OTo0N1rOHN4s4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTo1MzoxOFrOHN405g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjUyOQ==", "bodyText": "The name should not contain your binding name, but the string \"binding\".", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484322529", "createdAt": "2020-09-07T09:49:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread(String threadName) {\n+            super(threadName);\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.debug(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                remoteAddress, node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread(\n+                \"OH-\" + TACmiBindingConstants.BINDING_ID + \"-\" + getThing().getUID().getAsString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjkzMw==", "bodyText": "One left", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484322933", "createdAt": "2020-09-07T09:50:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,492 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.debug(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.debug(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.debug(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final ParseException | InterruptedException | TimeoutException | ExecutionException ex) {\n+                    logger.warn(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc"}, "originalPosition": 426}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNDU4Mg==", "bodyText": "Can you remove logging the stack trace when the network fails?", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484324582", "createdAt": "2020-09-07T09:53:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,492 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.debug(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.debug(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.debug(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final ParseException | InterruptedException | TimeoutException | ExecutionException ex) {\n+                    logger.warn(\"Error loading API Scheme: {} \", ex.getMessage(), ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc"}, "originalPosition": 422}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/fce64ebcc62e0e611dbd041f09bff65fc887d5dc", "committedDate": "2020-09-06T21:01:09Z", "message": "[tacmi] Additional changes from code review: Thread name, reduced logging output, Exception handling\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}, "afterCommit": {"oid": "ddf0e815f62324e12c8c713346660adfe713c715", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/ddf0e815f62324e12c8c713346660adfe713c715", "committedDate": "2020-09-07T19:48:13Z", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14893ca381e80f2640ec4474540d9939b2be687f", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/14893ca381e80f2640ec4474540d9939b2be687f", "committedDate": "2020-09-07T19:53:18Z", "message": "[tacmi] Apply suggestions from code review\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62894236718867a81a91bf41cc959e7b4f87ea44", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/62894236718867a81a91bf41cc959e7b4f87ea44", "committedDate": "2020-09-07T19:53:22Z", "message": "[tacmi] Additional changes from code review: Thread name, reduced logging output, Exception handling\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/5f5bbed3ae12730ac573fd71acfae486012a6a35", "committedDate": "2020-09-07T19:53:22Z", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddf0e815f62324e12c8c713346660adfe713c715", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/ddf0e815f62324e12c8c713346660adfe713c715", "committedDate": "2020-09-07T19:48:13Z", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}, "afterCommit": {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/5f5bbed3ae12730ac573fd71acfae486012a6a35", "committedDate": "2020-09-07T19:53:22Z", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Mzc2OTQ1", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-484376945", "createdAt": "2020-09-08T18:05:17Z", "commit": {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODowNToxN1rOHOoXLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODowNToxN1rOHOoXLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMzQwNA==", "bodyText": "You don't need to log this, as updateStatus() already does it.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485103404", "createdAt": "2020-09-08T18:05:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -185,10 +185,12 @@ private void refreshData() {\n             // binding shutdown is in progress\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n             this.online = false;\n-        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n-            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n-            // troubleshoot this\n-            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+        } catch (final ParseException | RuntimeException e) {\n+            logger.warn(\"Error parsing API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.HANDLER_INITIALIZING_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        } catch (final TimeoutException | ExecutionException e) {\n+            logger.warn(\"Error loading API Scheme: {} \", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "committedDate": "2020-09-08T20:43:32Z", "message": "[tacmi] Reduced logging output...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTA1Njgw", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-484505680", "createdAt": "2020-09-08T21:29:16Z", "commit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDk0MTY1", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-484494165", "createdAt": "2020-09-08T21:08:11Z", "commit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMTowODoxMVrOHOuEqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNToyNjo0MlrOHPM4sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5Njk3MA==", "bodyText": "Missing newline", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485196970", "createdAt": "2020-09-08T21:08:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/NOTICE", "diffHunk": "@@ -0,0 +1,20 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab-addons\n+\n+== Third-party Content\n+\n+attoparser\n+* License: Apache 2.0\n+* Project: https://www.attoparser.org\n+* Source:  https://github.com/attoparser/attoparser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODQyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n          \n          \n            \n            Multiple of these pages on different C.M.I.'s could be defined within a openHAB instance.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485198428", "createdAt": "2020-09-08T21:11:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODc0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n          \n          \n            \n            This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a openHAB instance.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485198748", "createdAt": "2020-09-08T21:12:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.\n          \n          \n            \n            But this also means for CoE-Messages from openHAB to TA C.M.I. we have to send multiple values at once.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485198955", "createdAt": "2020-09-08T21:12:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured.\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+| Parameter Label         | Parameter ID    | Description                                                                                                   | Accepted values        |\n+|-------------------------|-----------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host            | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Node                    | node            | The CoE / CAN Node number openHAB should represent                                                            | 1-64                   |\n+\n+The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n+\n+## Channels\n+\n+### TA C.M.I. schema API connection\n+\n+The channels provided by this thing depends on the configuration of the \"schema API page\".\n+All the channels are dynamically created to match it.\n+Also when the API Page is updated, the channels are also updated during the next refresh.\n+\n+### TA C.M.I. CoE Connection\n+\n+Some comments on the CoE Connection and channel configuration:\n+As you might already have taken notice when studying the TA's manual, there are always a multiple CoE-values updated within a single CoE-message.\n+This is a design decision made by TA.\n+But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTE3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The binding supports all 21 measure types that exist according to the TA documentation. Unfortunately, the documentation is not consistent here, so most of the types are supported only by generic names.\n          \n          \n            \n            The binding supports all 21 measure types that exist according to the TA documentation.\n          \n          \n            \n            Unfortunately, the documentation is not consistent here, so most of the types are supported only by generic names.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485199171", "createdAt": "2020-09-08T21:13:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured.\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+| Parameter Label         | Parameter ID    | Description                                                                                                   | Accepted values        |\n+|-------------------------|-----------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host            | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Node                    | node            | The CoE / CAN Node number openHAB should represent                                                            | 1-64                   |\n+\n+The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n+\n+## Channels\n+\n+### TA C.M.I. schema API connection\n+\n+The channels provided by this thing depends on the configuration of the \"schema API page\".\n+All the channels are dynamically created to match it.\n+Also when the API Page is updated, the channels are also updated during the next refresh.\n+\n+### TA C.M.I. CoE Connection\n+\n+Some comments on the CoE Connection and channel configuration:\n+As you might already have taken notice when studying the TA's manual, there are always a multiple CoE-values updated within a single CoE-message.\n+This is a design decision made by TA.\n+But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.\n+But due to OH's design there is no default restore of previous values out of the box.\n+So after OH startup the _output thing channels_ are either initialized with it's configured default value or flagged as 'unknown' until the first update on the channel happens.\n+You could either use some 'illegal' value as initial value and use _CoE Value Validation_ on the TA side to detect invalid values.\n+An other option would be to use only every 4th analog and 16th digital channel if you only need a few channels.\n+Additionally you could use [OH's persistence service](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) and it's option to [restore the item states](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) during OH startup.\n+As this only restores the item states you have to write a rule issuing _postUpdates_ on the items with the item's current value so the channel for the binding is updated.\n+\n+Supported channels for the CoE connection are:\n+\n+| Channel         | Type        | Description                                                          |\n+|-----------------|-------------|----------------------------------------------------------------------|\n+| coe-digital-in  | Switch (RO) | Digital input channel for digital state data received from the node  |\n+| coe-digital-out | Switch      | Digital output channel for digital state data sent to the node       |\n+| coe-analog-in   | Number (RO) | Analog input channel for numeric values received from the node       |\n+| coe-analog-out  | Number      | Analog output channel for numeric values sent to the node            |\n+\n+Each channel has it's own set of configuration parameters.\n+Here a list of possible parameters:\n+\n+Channel's `coe-digital-in` and `coe-analog-in`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                   |\n+\n+Channel `coe-digital-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | true (on) / false (off) |\n+\n+Channel `coe-analog-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Measurement Type        | type         | Measurement type for this channel (see table below)                                                           | 0-21                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | floating point numeric  |\n+\n+The binding supports all 21 measure types that exist according to the TA documentation. Unfortunately, the documentation is not consistent here, so most of the types are supported only by generic names.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMDE0Mg==", "bodyText": "Maybe move the row below to here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Any custom content here!\n          \n          \n            \n            ## Some additional hints and comments", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485200142", "createdAt": "2020-09-08T21:15:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured.\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+| Parameter Label         | Parameter ID    | Description                                                                                                   | Accepted values        |\n+|-------------------------|-----------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host            | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Node                    | node            | The CoE / CAN Node number openHAB should represent                                                            | 1-64                   |\n+\n+The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n+\n+## Channels\n+\n+### TA C.M.I. schema API connection\n+\n+The channels provided by this thing depends on the configuration of the \"schema API page\".\n+All the channels are dynamically created to match it.\n+Also when the API Page is updated, the channels are also updated during the next refresh.\n+\n+### TA C.M.I. CoE Connection\n+\n+Some comments on the CoE Connection and channel configuration:\n+As you might already have taken notice when studying the TA's manual, there are always a multiple CoE-values updated within a single CoE-message.\n+This is a design decision made by TA.\n+But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.\n+But due to OH's design there is no default restore of previous values out of the box.\n+So after OH startup the _output thing channels_ are either initialized with it's configured default value or flagged as 'unknown' until the first update on the channel happens.\n+You could either use some 'illegal' value as initial value and use _CoE Value Validation_ on the TA side to detect invalid values.\n+An other option would be to use only every 4th analog and 16th digital channel if you only need a few channels.\n+Additionally you could use [OH's persistence service](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) and it's option to [restore the item states](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) during OH startup.\n+As this only restores the item states you have to write a rule issuing _postUpdates_ on the items with the item's current value so the channel for the binding is updated.\n+\n+Supported channels for the CoE connection are:\n+\n+| Channel         | Type        | Description                                                          |\n+|-----------------|-------------|----------------------------------------------------------------------|\n+| coe-digital-in  | Switch (RO) | Digital input channel for digital state data received from the node  |\n+| coe-digital-out | Switch      | Digital output channel for digital state data sent to the node       |\n+| coe-analog-in   | Number (RO) | Analog input channel for numeric values received from the node       |\n+| coe-analog-out  | Number      | Analog output channel for numeric values sent to the node            |\n+\n+Each channel has it's own set of configuration parameters.\n+Here a list of possible parameters:\n+\n+Channel's `coe-digital-in` and `coe-analog-in`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                   |\n+\n+Channel `coe-digital-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | true (on) / false (off) |\n+\n+Channel `coe-analog-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Measurement Type        | type         | Measurement type for this channel (see table below)                                                           | 0-21                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | floating point numeric  |\n+\n+The binding supports all 21 measure types that exist according to the TA documentation. Unfortunately, the documentation is not consistent here, so most of the types are supported only by generic names.\n+The known measure types are:\n+\n+| id     | type          | description                                   |\n+|--------|---------------|-----------------------------------------------|\n+| 1      | Temperature   | Tempeature value. Value is multiplied by 0.1  |\n+| 2      | Unknown2      |                                               |\n+| 3      | Unknown3      |                                               |\n+| 4      | Seconds       |                                               |\n+| 5...9  | Unknown5..9   |                                               |\n+| 10     | Kilowatt      |                                               |\n+| 11     | Kilowatthours |                                               |\n+| 12     | Megawatthours |                                               |\n+| 13..21 | Unknown       |                                               |\n+\n+\n+## Full Example\n+\n+As there is no common configuration as everything depends on the configuration of the TA devices.\n+So we just can provide some samples providing the basics so you can build the configuration matching your system.\n+\n+Example of a _.thing_ file:\n+\n+```\n+Thing tacmi:cmiSchema:apiLab \"CMIApiPage\"@\"lab\" [ host=\"192.168.178.33\", username=\"user\", password=\"secret\", schemaId=4 ]\n+Bridge tacmi:coe-bridge:coe-bridge \"TA C.M.I. Bridge\"\n+{\n+\n+    Thing cmi cmiTest \"Test-CMI\"@\"lab\" [ host=\"192.168.178.33\", node=54 ] {\n+    Channels:\n+        Type coe-digital-in : digitalInput1 \"Digital input 1\" [ output=1 ]\n+        Type coe-digital-out : digitalOutput1 \"Digital output 1\" [ output=1, initialValue=true]\n+        Type coe-analog-in : analogInput1 \"Analog input 1\" [ output=1 ]\n+        Type coe-analog-out : analogOutput1 \"Analog output 1\" [ output=1, type=1, initialValue=22 ]\n+    }\n+\n+}\n+```\n+\n+Sample _.items_-File:\n+\n+```\n+# APIPage-items\n+Number TACMI_Api_tempCollector \"Collector temp [%.1f \u00b0C]\" <temperature> {channel=\"tacmi:cmiSchema:apiLab:tempCollector\"}\n+String TACMI_Api_hc1OperationMode \"Heating Curcuit 1 Operation Mode [%s]\" {channel=\"tacmi:cmiSchema:apiLab:hc1OperationMode\"}\n+\n+\n+# COE-items\n+Number TACMI_Analog_In_1     \"TA input value 1 [%.1f]\"  <temperature> {channel=\"tacmi:cmi:coe-bridge:cmiTest:analogInput1\"}\n+Number TACMI_Analog_Out_1    \"TA output value 1 [%.1f]\" <temperature> {channel=\"tacmi:cmi:coe-bridge:cmiTest:analogOutput1\"}\n+Switch TACMI_Digital_In_1    \"TA input switch 1 [%s]\"    {channel=\"tacmi:cmi:coe-bridge:cmiTest:digitalInput1\"}\n+Switch TACMI_Digital_Out_1   \"TA output switch 1 [%s]\"   {channel=\"tacmi:cmi:coe-bridge:cmiTest:digitalOutput1\"}\n+```\n+\n+Sample _.sitemap_ snipplet\n+\n+```\n+sitemap heatingTA label=\"heatingTA\"\n+{\n+    Text item=TACMI_Api_tempCollector\n+    Switch item=TACMI_Api_hc1OperationMode mappings=[\"Zeit/Auto\"=\"Auto\", \"Normal\"=\"Operating\", \"Abgesenkt\"=\"lowered\", \"Standby/Frostschutz\"=\"Standby\"]\n+\n+    Text item=TACMI_Analog_In_1\n+    Setpoint item=TACMI_Analog_Out_1 step=5 minValue=15 maxValue=45\n+    Switch item=TACMI_Digital_In_1\n+    Switch item=TACMI_Digital_Out_1\n+}\n+```\n+\n+## Any custom content here!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMTUwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n          \n          \n            \n            Also keep in mind: for the channel name we have to adhere to the openHAB channel name conventions - so just use letters and numbers without any special sings here.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485201500", "createdAt": "2020-09-08T21:18:07Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMjE3MQ==", "bodyText": "And replace the all usage of OH with openHAB.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485202171", "createdAt": "2020-09-08T21:19:33Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured.\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+| Parameter Label         | Parameter ID    | Description                                                                                                   | Accepted values        |\n+|-------------------------|-----------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host            | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Node                    | node            | The CoE / CAN Node number openHAB should represent                                                            | 1-64                   |\n+\n+The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n+\n+## Channels\n+\n+### TA C.M.I. schema API connection\n+\n+The channels provided by this thing depends on the configuration of the \"schema API page\".\n+All the channels are dynamically created to match it.\n+Also when the API Page is updated, the channels are also updated during the next refresh.\n+\n+### TA C.M.I. CoE Connection\n+\n+Some comments on the CoE Connection and channel configuration:\n+As you might already have taken notice when studying the TA's manual, there are always a multiple CoE-values updated within a single CoE-message.\n+This is a design decision made by TA.\n+But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5ODk1NQ=="}, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwMjc5OQ==", "bodyText": "This line can be removed. When in the context off all addon documentation it's a bit out-of-context.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485202799", "createdAt": "2020-09-08T21:20:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/README.md", "diffHunk": "@@ -0,0 +1,266 @@\n+# TA C.M.I. Binding\n+\n+This binding makes use of the CAN over Ethernet feature of the C.M.I. from Technische Alternative.\n+Since I only have the new UVR16x2, it has only been tested with this controller.\n+\n+The binding supports two ways to interact with the C.M.I. and all devices connected to the C.M.I. via the CAN bus.\n+These modes are:\n+\n+\n+Via a \"Schema API Page\"\n+  * Read values from output nodes\n+  * Change values for controllable nodes\n+\n+CoE (CAN over Ethernet) Connection\n+  * Receive data from analog CAN-outputs defined in TAPPS2\n+  * Receive data from digital CAN-outputs defined in TAPPS2\n+  * Send ON/OFF to digital CAN-inputs defined in TAPPS2\n+  * Send numeric values to analog CAN-inputs defined in TAPPS2\n+\n+\n+Depending on what you want to achieve, either the \"Schema API Page\" or the CoE way might be better.\n+As rough guidance: Anything you want to provide to the TA equipment it has to work / operate with the CoE might be better.\n+If you plan things mainly for user interaction the \"Schema API Page\" might be better.\n+\n+\n+## Prerequisites\n+\n+### Setting up the \"Schema API Page\"\n+\n+The \"Schema API page\" is a special schema page created via TA's *TA-Designer* application available as download on their web site.\n+This page just needs to exist and be deployed on the C.M.I. but it dosn't need to be linked by the other schema pages you are using to control your TA installation.\n+\n+All objects from this special 'API' page are automatically mapped as channels of this thing, so the labels of the objects on this page have to follow a specific schema.\n+\n+When adding objects to this page, the schema for the Object's *Pre-Text* field has to follow the schema `<channelName> <channel description>: `.\n+\n+Maybe this screenshot shows it best:\n+\n+![screenshot-channel-object-details](doc/images/channel-object-details.png)\n+\n+The Text from the *Pre-Text* will be used to define the channel.\n+The first word *tempCollector* (highlighted in the screenshot) will be used as channel name, so it has to be unique.\n+Everything else till the final *:* will be used as channel description.\n+Be sure to have at least 2 words in the *Pre-Text* as we need both - the channel name and a description.\n+The binding will log an error otherwise.\n+Also keep in mind: for the channel name we have to adhere to the OH channel name conventions - so just use letters and numbers without any special sings here.\n+The type of the channel will be automatically determined by the type of the object added.\n+Also don't forget the final colon - this is the separator between the label and the value.\n+Without the colon the parser couldn't build up a working channel for this value.\n+\n+The first sample is a sensor reading, but also the 'operation mode' of a heating circuit could be added:\n+\n+![screenshot-sample-with-heating-circuit](doc/images/sample-with-heating-circuit.png)\n+\n+In this screenshot you also see the schema page id - the parenthesized number on the bottom page overview, in this sample 4.\n+\n+### CoE Configuration\n+\n+#### Configure CAN outputs in TAPPS2\n+\n+You need to configure CAN outputs in your Functional data on the UVR16x2.\n+This can be done by using the TAPPS2 application from TA. Follow the user guide on how to do this.\n+\n+#### Configure your CMI for CoE\n+\n+Now follow the User Guide of the CMI on how to setup CAN over Ethernet (COE).\n+Here you will map your outputs that you configured in the previous step.\n+This can be accomplished via the GUI on the CMI or via the coe.csv file.\n+As the target device you need to put the IP of your openHAB server.\n+Don\u2019t forget to reboot the CMI after you uploaded the coe.csv file.\n+\n+## Supported Bridge and Things\n+\n+* TA C.M.I. schema API connection - Thing\n+\n+This thing reflecting one of our 'schema API page' as defined in the prerequisites.\n+This thing doesn't need the bridge.\n+Multiple of these pages on different C.M.I.'s could be defined within a OH instance.\n+\n+* TA C.M.I. CoE Bridge\n+\n+In order to get the CAN over Ethernet (COE) envionment working a `coe-bridge` has to be created.\n+The bridge itself opens the UDP port 5441 for communication with the C.M.I. devices.\n+The bridge could be used for multiple C.M.I. devices.\n+\n+* TA C.M.I. CoE Connection - Thing\n+\n+This thing reflects a connection to a node behind a specific C.M.I..\n+This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+## Discovery\n+\n+Autodiscovering is not supported. We have to define the things manually.\n+\n+## Thing Configuration\n+\n+### TA C.M.I. schema API connection\n+\n+The _TA C.M.I. Schema API Connection_ has to be manually configured.\n+\n+The thing has the following configuration parameters:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host         | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Username                | username     | Username for authentication on the C.M.I.                                                                     | string with username   |\n+| Password                | password     | Password for authentication on the C.M.I.                                                                     | string with password   |\n+| API Schema ID           | schemaId     | ID of the schema API page                                                                                     | 1-256                  |\n+| Poll Interval           | pollInterval | Poll interval (in seconds) how often to poll the API Page                                                     | 1-300; default 10      |\n+\n+This thing doesn't need a bridge. Multiple of these things for different C.M.I.'s could be defined within a OH instance.\n+\n+### TA C.M.I. CoE Connection\n+\n+The _TA C.M.I. CoE Connection_ has to be manually configured.\n+\n+This thing reflects a connection to a node behind a specific C.M.I.. This node could be every CAN-Capable device from TA which allows to define an CAN-Input.\n+\n+| Parameter Label         | Parameter ID    | Description                                                                                                   | Accepted values        |\n+|-------------------------|-----------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| C.M.I. IP Address       | host            | Host name or IP address of the C.M.I                                                                          | host name or ip        |\n+| Node                    | node            | The CoE / CAN Node number openHAB should represent                                                            | 1-64                   |\n+\n+The thing has no channels by default - they have to be added manually matching the configured inputs / outputs for the related CAN Node. Digital and Analog channels are supported. Please read TA's documentation related to the CAN-protocol - multiple analog (4) and digital (16) channels are combined so please be aware of this design limitation.\n+\n+## Channels\n+\n+### TA C.M.I. schema API connection\n+\n+The channels provided by this thing depends on the configuration of the \"schema API page\".\n+All the channels are dynamically created to match it.\n+Also when the API Page is updated, the channels are also updated during the next refresh.\n+\n+### TA C.M.I. CoE Connection\n+\n+Some comments on the CoE Connection and channel configuration:\n+As you might already have taken notice when studying the TA's manual, there are always a multiple CoE-values updated within a single CoE-message.\n+This is a design decision made by TA.\n+But this also means for CoE-Messages from OH to TA C.M.I. we have to send multiple values at once.\n+But due to OH's design there is no default restore of previous values out of the box.\n+So after OH startup the _output thing channels_ are either initialized with it's configured default value or flagged as 'unknown' until the first update on the channel happens.\n+You could either use some 'illegal' value as initial value and use _CoE Value Validation_ on the TA side to detect invalid values.\n+An other option would be to use only every 4th analog and 16th digital channel if you only need a few channels.\n+Additionally you could use [OH's persistence service](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) and it's option to [restore the item states](https://www.openhab.org/docs/configuration/persistence.html#restoring-item-states-on-restart) during OH startup.\n+As this only restores the item states you have to write a rule issuing _postUpdates_ on the items with the item's current value so the channel for the binding is updated.\n+\n+Supported channels for the CoE connection are:\n+\n+| Channel         | Type        | Description                                                          |\n+|-----------------|-------------|----------------------------------------------------------------------|\n+| coe-digital-in  | Switch (RO) | Digital input channel for digital state data received from the node  |\n+| coe-digital-out | Switch      | Digital output channel for digital state data sent to the node       |\n+| coe-analog-in   | Number (RO) | Analog input channel for numeric values received from the node       |\n+| coe-analog-out  | Number      | Analog output channel for numeric values sent to the node            |\n+\n+Each channel has it's own set of configuration parameters.\n+Here a list of possible parameters:\n+\n+Channel's `coe-digital-in` and `coe-analog-in`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values        |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                   |\n+\n+Channel `coe-digital-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | true (on) / false (off) |\n+\n+Channel `coe-analog-out`:\n+\n+| Parameter Label         | Parameter ID | Description                                                                                                   | Accepted values         |\n+|-------------------------|--------------|---------------------------------------------------------------------------------------------------------------|-------------------------|\n+| Output                  | output       | C.M.I. Network Output                                                                                         | 1-64                    |\n+| Measurement Type        | type         | Measurement type for this channel (see table below)                                                           | 0-21                    |\n+| Initial Value           | initialValue | Initial value to set after startup (optional, defaults to uninitialized)                                      | floating point numeric  |\n+\n+The binding supports all 21 measure types that exist according to the TA documentation. Unfortunately, the documentation is not consistent here, so most of the types are supported only by generic names.\n+The known measure types are:\n+\n+| id     | type          | description                                   |\n+|--------|---------------|-----------------------------------------------|\n+| 1      | Temperature   | Tempeature value. Value is multiplied by 0.1  |\n+| 2      | Unknown2      |                                               |\n+| 3      | Unknown3      |                                               |\n+| 4      | Seconds       |                                               |\n+| 5...9  | Unknown5..9   |                                               |\n+| 10     | Kilowatt      |                                               |\n+| 11     | Kilowatthours |                                               |\n+| 12     | Megawatthours |                                               |\n+| 13..21 | Unknown       |                                               |\n+\n+\n+## Full Example\n+\n+As there is no common configuration as everything depends on the configuration of the TA devices.\n+So we just can provide some samples providing the basics so you can build the configuration matching your system.\n+\n+Example of a _.thing_ file:\n+\n+```\n+Thing tacmi:cmiSchema:apiLab \"CMIApiPage\"@\"lab\" [ host=\"192.168.178.33\", username=\"user\", password=\"secret\", schemaId=4 ]\n+Bridge tacmi:coe-bridge:coe-bridge \"TA C.M.I. Bridge\"\n+{\n+\n+    Thing cmi cmiTest \"Test-CMI\"@\"lab\" [ host=\"192.168.178.33\", node=54 ] {\n+    Channels:\n+        Type coe-digital-in : digitalInput1 \"Digital input 1\" [ output=1 ]\n+        Type coe-digital-out : digitalOutput1 \"Digital output 1\" [ output=1, initialValue=true]\n+        Type coe-analog-in : analogInput1 \"Analog input 1\" [ output=1 ]\n+        Type coe-analog-out : analogOutput1 \"Analog output 1\" [ output=1, type=1, initialValue=22 ]\n+    }\n+\n+}\n+```\n+\n+Sample _.items_-File:\n+\n+```\n+# APIPage-items\n+Number TACMI_Api_tempCollector \"Collector temp [%.1f \u00b0C]\" <temperature> {channel=\"tacmi:cmiSchema:apiLab:tempCollector\"}\n+String TACMI_Api_hc1OperationMode \"Heating Curcuit 1 Operation Mode [%s]\" {channel=\"tacmi:cmiSchema:apiLab:hc1OperationMode\"}\n+\n+\n+# COE-items\n+Number TACMI_Analog_In_1     \"TA input value 1 [%.1f]\"  <temperature> {channel=\"tacmi:cmi:coe-bridge:cmiTest:analogInput1\"}\n+Number TACMI_Analog_Out_1    \"TA output value 1 [%.1f]\" <temperature> {channel=\"tacmi:cmi:coe-bridge:cmiTest:analogOutput1\"}\n+Switch TACMI_Digital_In_1    \"TA input switch 1 [%s]\"    {channel=\"tacmi:cmi:coe-bridge:cmiTest:digitalInput1\"}\n+Switch TACMI_Digital_Out_1   \"TA output switch 1 [%s]\"   {channel=\"tacmi:cmi:coe-bridge:cmiTest:digitalOutput1\"}\n+```\n+\n+Sample _.sitemap_ snipplet\n+\n+```\n+sitemap heatingTA label=\"heatingTA\"\n+{\n+    Text item=TACMI_Api_tempCollector\n+    Switch item=TACMI_Api_hc1OperationMode mappings=[\"Zeit/Auto\"=\"Auto\", \"Normal\"=\"Operating\", \"Abgesenkt\"=\"lowered\", \"Standby/Frostschutz\"=\"Standby\"]\n+\n+    Text item=TACMI_Analog_In_1\n+    Setpoint item=TACMI_Analog_Out_1 step=5 minValue=15 maxValue=45\n+    Switch item=TACMI_Digital_In_1\n+    Switch item=TACMI_Digital_Out_1\n+}\n+```\n+\n+## Any custom content here!\n+\n+Some additional hints and comments:\n+\n+You might already have noticed that some state information is in German.\n+As I have set the `Accept-Language`-Http-Header to `en` for all request and found no other way setting a language for the schema pages I assume it is a lack of internationalization in the C.M.I.\n+You could circumvent this by creating map files to map things properly to your language.\n+\n+If you want to see the possible options of a multi-state field you could open the *schema API page* with your web browser and click on the object.\n+A Popup with an option field will be shown showing all possible options, like in this screenshot:\n+\n+![screenshot-operation-mode-values](doc/images/operation-mode-values.png)\n+\n+Please be also aware that there are field having more 'state' values than options, i.E. a manual output override: It has 'Auto/On', 'Auto/Off', 'Manual/On', 'Manual/Off' as state, but only 'Auto', 'Manual/On' and 'Manual/Off' as updateable option.\n+You only set it to 'Auto' and the extension On/Off is added depending on the system's current state.\n+\n+\n+Finally - It would be great to hear from your projects and ideas / solutions!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzE5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class }, immediate = true)\n          \n          \n            \n            @Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class })", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485497195", "createdAt": "2020-09-09T10:09:53Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeProvider;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * Provides all ChannelTypes for the schema binding...\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class }, immediate = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzUxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HttpClient httpClient;\n          \n          \n            \n                private TACmiChannelTypeProvider channelTypeProvider;\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                private final TACmiChannelTypeProvider channelTypeProvider;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485497517", "createdAt": "2020-09-09T10:10:26Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.tacmi.internal.coe.TACmiCoEBridgeHandler;\n+import org.openhab.binding.tacmi.internal.coe.TACmiHandler;\n+import org.openhab.binding.tacmi.internal.schema.TACmiSchemaHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TACmiHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.tacmi\", service = ThingHandlerFactory.class)\n+public class TACmiHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n+            Stream.of(THING_TYPE_CMI, THING_TYPE_COE_BRIDGE, THING_TYPE_CMI_SCHEMA).collect(Collectors.toSet()));\n+\n+    private HttpClient httpClient;\n+    private TACmiChannelTypeProvider channelTypeProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5ODEwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int typeval;\n          \n          \n            \n                private int offset;\n          \n          \n            \n                private final int typeval;\n          \n          \n            \n                private final int offset;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485498101", "createdAt": "2020-09-09T10:11:29Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiMeasureType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This enum holds all the different measures and states available to be\n+ * retrieved by the TACmi binding, including the scale factors needed to convert the received values to the real\n+ * numbers.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public enum TACmiMeasureType {\n+    NONE(0, 1),\n+    TEMPERATURE(1, 10),\n+    UNKNOWN2(2, 1),\n+    UNKNOWN3(3, 1),\n+    SECONDS(4, 1),\n+    UNKNOWN5(5, 1),\n+    UNKNOWN6(6, 1),\n+    UNKNOWN7(7, 1),\n+    UNKNOWN8(8, 1),\n+    UNKNOWN9(9, 1),\n+    KILOWATT(10, 100),\n+    KILOWATTHOURS(11, 10),\n+    MEGAWATTHOURS(12, 1),\n+    UNKNOWN13(13, 1),\n+    UNKNOWN14(14, 1),\n+    UNKNOWN15(15, 1),\n+    UNKNOWN16(16, 1),\n+    UNKNOWN17(17, 1),\n+    UNKNOWN18(18, 1),\n+    UNKNOWN19(19, 1),\n+    UNKNOWN20(20, 1),\n+    UNKNOWN21(21, 1),\n+\n+    UNSUPPORTED(-1, 1);\n+\n+    private int typeval;\n+    private int offset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5OTY4MA==", "bodyText": "You can directly return here, and remove the local variable allInitialized:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            allInitialized = false;\n          \n          \n            \n                            return false;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485499680", "createdAt": "2020-09-09T10:14:16Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodDataOutgoing.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class carries all relevant data for the POD\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PodDataOutgoing extends PodData {\n+\n+    protected long lastSent;\n+    protected final ChannelUID[] channeUIDs;\n+    protected final boolean[] initialized;\n+    private boolean allValuesInitialized;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodDataOutgoing(PodIdentifier pi, byte node) {\n+        super(pi, node);\n+        boolean analog = pi.messageType == MessageType.ANALOG;\n+        int valueCount = analog ? 4 : 16;\n+        this.channeUIDs = new ChannelUID[valueCount];\n+        this.initialized = new boolean[valueCount];\n+        this.allValuesInitialized = false;\n+        this.message = analog ? new AnalogMessage(node, pi.podId) : new DigitalMessage(node, pi.podId);\n+        this.lastSent = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * checks if all (in use) values have been set to a value - used to prevent sending of unintended values via CoE\n+     */\n+    public boolean isAllValuesInitialized() {\n+        if (this.allValuesInitialized) {\n+            return true;\n+        }\n+        boolean allInitialized = true;\n+        for (int idx = 0; idx < this.initialized.length; idx++) {\n+            if (this.channeUIDs[idx] != null && !this.initialized[idx]) {\n+                allInitialized = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMDYwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int coePort = 5441;\n          \n          \n            \n                private static final int COE_PORT = 5441;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485500604", "createdAt": "2020-09-09T10:16:02Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMTgxMA==", "bodyText": "Probably most of the warn logs should be debug:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"No bridge commands defined.\");\n          \n          \n            \n                        logger.debug(\"No bridge commands defined.\");\n          \n      \n    \n    \n  \n\nSee https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485501810", "createdAt": "2020-09-09T10:18:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread(String threadName) {\n+            super(threadName);\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.debug(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                remoteAddress, node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread(\"OH-binding-\" + getThing().getUID().getAsString());\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjM5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected Message message;\n          \n          \n            \n                protected @Nullable Message message;", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485502397", "createdAt": "2020-09-09T10:19:30Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodData.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class carries all relevant data for the POD\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PodData {\n+    protected final byte podId;\n+    protected final MessageType messageType;\n+    @Nullable\n+    protected Message message;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTk4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(o instanceof PodIdentifier))\n          \n          \n            \n                        return false;\n          \n          \n            \n                    if (!(o instanceof PodIdentifier)) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485591987", "createdAt": "2020-09-09T13:01:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+            case DIGITAL:\n+                if (podId != 0 && podId != 9)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+        }\n+        this.podId = podId;\n+        this.outgoing = outgoing;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (this.messageType.ordinal() << 8) | podId | (outgoing ? 0x10000 : 0);\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object o) {\n+        if (!(o instanceof PodIdentifier))\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjIzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (podId < 0)\n          \n          \n            \n                        throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                    if (podId < 0) {\n          \n          \n            \n                        throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592238", "createdAt": "2020-09-09T13:01:33Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjQwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (podId < 1 || podId > 8)\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            if (podId < 1 || podId > 8) {\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            }", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592403", "createdAt": "2020-09-09T13:01:48Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjUxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (podId != 0 && podId != 9)\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            if (podId != 0 && podId != 9) {\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            }", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592519", "createdAt": "2020-09-09T13:02:00Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+            case DIGITAL:\n+                if (podId != 0 && podId != 9)\n+                    throw new ArrayIndexOutOfBoundsException(podId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NTIwNw==", "bodyText": "It should be either UNKNOWN or ONLINE with CONFIGURATION_PENDING See allowed combinations: https://www.openhab.org/docs/concepts/things.html#status-details", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485595207", "createdAt": "2020-09-09T13:05:54Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+        this.online = false;\n+\n+        scheduler.execute(this::initializeDetached);\n+    }\n+\n+    private void initializeDetached() {\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            // message logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI for '\" + config.host + \"'\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        this.podDatas.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            final ChannelTypeUID ct = chann.getChannelTypeUID();\n+            final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+            final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+            // for the analog out channel we have the measurement type. for the input\n+            // channel we take it from the C.M.I.\n+            final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    ? TACmiChannelConfigurationAnalog.class\n+                    : TACmiChannelConfigurationDigital.class;\n+            final TACmiChannelConfiguration channelConfig = chann.getConfiguration().as(ccClass);\n+            this.channelConfigByUID.put(chann.getUID(), channelConfig);\n+            final MessageType messageType = analog ? MessageType.ANALOG : MessageType.DIGITAL;\n+            final byte podId = this.getPodId(messageType, channelConfig.output);\n+            final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+            // initialize podData\n+            PodData pd = this.getPodData(pi);\n+            if (outgoing) {\n+                int outputIdx = getOutputIndex(channelConfig.output, analog);\n+                PodDataOutgoing podDataOutgoing = (PodDataOutgoing) pd;\n+                // we have to track value state for all outgoing channels to ensure we have valid values for all\n+                // channels in use before we send a message to the C.M.I. otherwise it could trigger some strange things\n+                // on TA side...\n+                boolean set = false;\n+                if (analog) {\n+                    TACmiChannelConfigurationAnalog ca = (TACmiChannelConfigurationAnalog) channelConfig;\n+                    Double initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        final TACmiMeasureType measureType = TACmiMeasureType.values()[ca.type];\n+                        final double val = initialValue.doubleValue() * measureType.getOffset();\n+                        @Nullable\n+                        Message message = pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setValue(outputIdx, (short) val, measureType.ordinal());\n+                            set = true;\n+                        }\n+                    }\n+                } else {\n+                    // digital...\n+                    TACmiChannelConfigurationDigital ca = (TACmiChannelConfigurationDigital) channelConfig;\n+                    Boolean initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        @Nullable\n+                        DigitalMessage message = (DigitalMessage) pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setPortState(outputIdx, initialValue);\n+                            set = true;\n+                        }\n+                    }\n+                }\n+                podDataOutgoing.channeUIDs[outputIdx] = chann.getUID();\n+                podDataOutgoing.initialized[outputIdx] = set;\n+            }\n+        }\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NTc3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"No Bridge configured!\");\n          \n      \n    \n    \n  \n\nSee https://www.openhab.org/docs/concepts/things.html#status-details", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485595772", "createdAt": "2020-09-09T13:06:45Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+        this.online = false;\n+\n+        scheduler.execute(this::initializeDetached);\n+    }\n+\n+    private void initializeDetached() {\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            // message logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI for '\" + config.host + \"'\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        this.podDatas.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            final ChannelTypeUID ct = chann.getChannelTypeUID();\n+            final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+            final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+            // for the analog out channel we have the measurement type. for the input\n+            // channel we take it from the C.M.I.\n+            final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    ? TACmiChannelConfigurationAnalog.class\n+                    : TACmiChannelConfigurationDigital.class;\n+            final TACmiChannelConfiguration channelConfig = chann.getConfiguration().as(ccClass);\n+            this.channelConfigByUID.put(chann.getUID(), channelConfig);\n+            final MessageType messageType = analog ? MessageType.ANALOG : MessageType.DIGITAL;\n+            final byte podId = this.getPodId(messageType, channelConfig.output);\n+            final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+            // initialize podData\n+            PodData pd = this.getPodData(pi);\n+            if (outgoing) {\n+                int outputIdx = getOutputIndex(channelConfig.output, analog);\n+                PodDataOutgoing podDataOutgoing = (PodDataOutgoing) pd;\n+                // we have to track value state for all outgoing channels to ensure we have valid values for all\n+                // channels in use before we send a message to the C.M.I. otherwise it could trigger some strange things\n+                // on TA side...\n+                boolean set = false;\n+                if (analog) {\n+                    TACmiChannelConfigurationAnalog ca = (TACmiChannelConfigurationAnalog) channelConfig;\n+                    Double initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        final TACmiMeasureType measureType = TACmiMeasureType.values()[ca.type];\n+                        final double val = initialValue.doubleValue() * measureType.getOffset();\n+                        @Nullable\n+                        Message message = pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setValue(outputIdx, (short) val, measureType.ordinal());\n+                            set = true;\n+                        }\n+                    }\n+                } else {\n+                    // digital...\n+                    TACmiChannelConfigurationDigital ca = (TACmiChannelConfigurationDigital) channelConfig;\n+                    Boolean initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        @Nullable\n+                        DigitalMessage message = (DigitalMessage) pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setPortState(outputIdx, initialValue);\n+                            set = true;\n+                        }\n+                    }\n+                }\n+                podDataOutgoing.channeUIDs[outputIdx] = chann.getUID();\n+                podDataOutgoing.initialized[outputIdx] = set;\n+            }\n+        }\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5Nzg0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN);", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485597846", "createdAt": "2020-09-09T13:09:48Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4Mjg1OA==", "bodyText": "NonNullByDefault should normally not be set on methods.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485682858", "createdAt": "2020-09-09T15:01:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        INPUT,\n+        INPUT_DATA,\n+        SELECT,\n+        SELECT_OPTION,\n+        UNKNOWN\n+    }\n+\n+    private final String channelName;\n+    private @Nullable String curOptionId;\n+    private ParserState parserState = ParserState.INIT;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private Map<String, @Nullable String> options;\n+\n+    public ChangerX2Parser(String channelName) {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+        this.channelName = channelName;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4NzIwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKOWN);", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485687208", "createdAt": "2020-09-09T15:07:03Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcwMTgwOA==", "bodyText": "Did you consider creating type specific channels for measurement type? Like a Number:Temperature channel for value 1 type channels. That way the user can use it as an actual temperature channel.", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485701808", "createdAt": "2020-09-09T15:26:42Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.tacmi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,172 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"tacmi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"cmi\" extensible=\"coe-digital-in,coe-digital-out,coe-analog-in,coe-analog-out\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"coe-bridge\"/>\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>TA C.M.I. CoE Connection</label>\n+\t\t<description>CoE Communication to the \"Technische Alternative C.M.I. Control and Monitoring Interface\"</description>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>C.M.I. IP Address</label>\n+\t\t\t\t<description>Host name of IP address of the CMI</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"node\" type=\"integer\" min=\"1\" max=\"62\" required=\"true\">\n+\t\t\t\t<label>Node</label>\n+\t\t\t\t<description>The CoE / CAN Node number openHAB should represent</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- CoE digital Channel Type -->\n+\t<channel-type id=\"coe-digital-in\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Input (C.M.I. -> OH)</label>\n+\t\t<description>A digital channel sent from C.M.I. to openHAB</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-digital-out\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Digital Output (OH -> C.M.I.)</label>\n+\t\t<description>A digital channel sent from OpenHAB to C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"initialValue\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Initial Value</label>\n+\t\t\t\t<description>Initial value to set after startup (optional, defaults to uninitialized)</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<!-- COA analog Channel Type -->\n+\t<channel-type id=\"coe-analog-in\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Input Channel (C.M.I. -> OH)</label>\n+\t\t<description>A Analog Channel received from the C.M.I.</description>\n+\t\t<state readOnly=\"true\"/>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>C.M.I. Network Output</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</channel-type>\n+\t<channel-type id=\"coe-analog-out\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Analog Output Channel (OH -> C.M.I.)</label>\n+\t\t<description>A Analog Channel sent to the C.M.I.</description>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"output\" type=\"integer\" min=\"1\" max=\"32\" required=\"true\">\n+\t\t\t\t<label>Output</label>\n+\t\t\t\t<description>Network Output</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"type\" type=\"integer\" min=\"0\" max=\"21\" required=\"true\">\n+\t\t\t\t<label>Measurement Type</label>\n+\t\t\t\t<description>Measurement type for this channel</description>\n+\t\t\t\t<options>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f5f9a1c66f08d3464d6c2a753ebbf10ce494f90", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/6f5f9a1c66f08d3464d6c2a753ebbf10ce494f90", "committedDate": "2020-09-09T19:29:42Z", "message": "[tacmi] Apply suggestions from code review: code formatting and some framework usage cleanups\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "222858f140a0dd9cda93655077aae946d0ea0e86", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/222858f140a0dd9cda93655077aae946d0ea0e86", "committedDate": "2020-09-09T19:30:04Z", "message": "[tacmi] TACmiHandler - improved thing states and transitions\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92eb6cfdea9f8402d194087bb091295fe684121d", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/92eb6cfdea9f8402d194087bb091295fe684121d", "committedDate": "2020-09-09T19:30:04Z", "message": "[tacmi] Additional cleanups & improvements from review\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a1f2274cfde918a28b9d408ccfdfda6a7850cfe", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/3a1f2274cfde918a28b9d408ccfdfda6a7850cfe", "committedDate": "2020-09-09T19:14:44Z", "message": "Apply suggestions from code review\r\n\r\nReadme.md updates and updateStatus\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>"}, "afterCommit": {"oid": "92eb6cfdea9f8402d194087bb091295fe684121d", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/92eb6cfdea9f8402d194087bb091295fe684121d", "committedDate": "2020-09-09T19:30:04Z", "message": "[tacmi] Additional cleanups & improvements from review\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd25457ac913a7324ee110588cb2b122581ed27a", "author": {"user": {"login": "marvkis", "name": "Christian Niessner"}}, "url": "https://github.com/openhab/openhab-addons/commit/cd25457ac913a7324ee110588cb2b122581ed27a", "committedDate": "2020-09-09T20:25:33Z", "message": "[tacmi] logging: changed some more loggings from warn to debug\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Nzc2MjY2", "url": "https://github.com/openhab/openhab-addons/pull/7768#pullrequestreview-486776266", "createdAt": "2020-09-11T12:50:46Z", "commit": {"oid": "cd25457ac913a7324ee110588cb2b122581ed27a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 405, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}