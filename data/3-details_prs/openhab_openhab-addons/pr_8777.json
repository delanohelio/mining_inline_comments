{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1Mjc2NTM3", "number": 8777, "title": "[velux] hub discovery; representation properties; socket lock up issues", "bodyText": "This PR implements a number of improvements to the Velux binding.\n1. The binding could not auto- discover Velux hubs\nA new VeluxBridgeFinder class has been added to discover Velux KLF200 hubs. Note: the Velux mDNS hub discovery is \"flaky\" under JmDNS, and there are issues with MDNSDiscoveryService, so this enhancement implements its own custom mDNS service resolver.\nThe ReadMe.md file has been updated to say that auto- discovery is supported on hubs.\n2. The binding had missing or wrong representation property names\nThe wrong representation property names meant that re-discovered Things were not properly being matched up with already discovered Things in the Inbox.\nThese errors and omissions have been corrected.\n3. The binding suffered from lock-ups in its TCP communication to the hub\nIf the binding went offline via a catastrophic failure, the Velux hub might be left with a large amount of un-sent (or un-acknowledged) data in its write buffer, and its side of the socket might get into a \"zombie\" state. This would prevent the binding from re-connecting again when the binding was restarted. Note: This seems to be a bug in the hub, which I have reported to Velux, but so far without response from them..\nThe following has been implemented:\n\nApplied a connect time out when the socket is created\nApplied a socket read timeout\nApplied a socket keepalive\nImplemented the Closeable interface in a number of places, so shutdown code gets called if the class instance gets destroyed.\n\nNote: These changes ameliorate the problem, but possibly do not completely eliminate it, since the underlying cause lies within the hub itself.\n4. The binding would block on read calls\nThe binding used blocking socket read calls to fetch data from the hub. This meant that the whole binding could sit in a blocked state for tens of seconds or until incoming data arrived.\nThe following has been implemented:\n\nImplemented read time outs (see item 3. above)\nImplemented an asynchronous message queue to decouple the binding upper levels from the lower level communication stack. There is now a separate thread that polls the socket and pushes messages onto the queue. And therefore the binding can now asynchronously pop the messages from the queue in its own separate thread(s).\nThe use of an asynchronous queue allows a Thread.sleep(500) call to be removed. Thus improving response time by 0.5 seconds per message.\n\n5. The binding wrongly used the available() method on its SSL socket\nA little-known \"feature\" of SSL sockets is that available()always returns 0 on them. So the binding's \"receive-only\" calls were never actually processing incoming messages, and the data would therefore backlog in the read buffer (see item 3. above) until the next \"send\" call could be made.\nThe asynchronous message queue (see item 4.) also solves this problem, since available() can now check for entries in the queue rather than (not) checking for data in the socket buffer. This could shorten response times by 10-50 seconds.\n6. The bridgeDirectCommunicate() method was not transparent\nWhile writing, testing and debugging the above changes, I felt the bridgeDirectCommunicate() method to be written in a hard to understand form, having two nested while() loops, labelled break statements, and multiple levels of continue and break statements. Furthermore the logger messages were hard for an outsider (like me) to understand.\nThe bridgeDirectCommunicate() method has been refactored to flatten the loop structure, simplify the functioning of break and continue statements, and clarify the logger messages.\n7. The task scheduler was not executing in the right order\nThe task scheduler was based on a multi- thread pool, but since the tasks were anyway constrained though the single IO socket pipeline, it meant that tasks would sometimes execute in the wrong order.\nThe task scheduler has been changed from a multi- thread pool to a single thread executor.\n8. The OH UI was not being updated fast enough\nThe UI would display the old position of actuators until the actuator had finally stopped moving in a new position.\nThe UI is now updated immediately to display the target position as soon as the actuator starts to move in that direction.\n9. User request: the remote reboot feature should be implemented\nSee this issue\nA ThingAction for remote reboot has been implemented.\n10. User request: the binding should indicate if windows are manually opened\nUsers on the community forum requested that when windows are manually opened, the binding should inform them. Furthermore, see this issue\nThe window position is now displayed as UNDEF when manually opened. And in the case that position is invalid, yet target position is valid, the window position is taken from the target position.\n11. If the user changed Configuration Parameters via PaperUI they were not saved\nChanges to Configuration Parameters are now saved.\n12. The GW_SET_NODE_VELOCITY_REQ/CFM command set has been removed from the API\nThe GW_SET_NODE_VELOCITY_REQ/CFM command set has been removed from the KLF200 API specification.\nThe code in the binding that would have called this command set, is not called. And the respective classes have been marked as deprecated. Nevertheless these classes have NOT been deleted from the binding 'just in case' the function might be added back again in a future API release.\n13. User request: Somfy actuators wrongly display undefined position\nSee this issue\nWherever possible if the current position is undefined, the actuator will display the target position instead. Furthermore the issue and a possible user work around are explained in the read me file.", "createdAt": "2020-10-17T12:47:09Z", "url": "https://github.com/openhab/openhab-addons/pull/8777", "merged": true, "mergeCommit": {"oid": "072113f51bbcf0ba93d500136b93dd15772ac681"}, "closed": true, "closedAt": "2020-12-01T17:05:52Z", "author": {"login": "andrewfg"}, "timelineItems": {"totalCount": 84, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYKjBHgFqTUyMTE5ODMxNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh9BMdgFqTU0MjExMDYzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTk4MzE1", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-521198315", "createdAt": "2020-11-01T07:08:43Z", "commit": {"oid": "9086f5224489718c37d5b307ac3b9f73fccef43e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6fd481c01db67167ecde976c374a30a7e08840b3", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/6fd481c01db67167ecde976c374a30a7e08840b3", "committedDate": "2020-11-04T21:31:56Z", "message": "[velux] uploaded latest jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}, "afterCommit": {"oid": "5cd31674012422df6e4f5040a3223b645672e723", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/5cd31674012422df6e4f5040a3223b645672e723", "committedDate": "2020-11-04T22:30:09Z", "message": "[velux] uploaded latest jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5cd31674012422df6e4f5040a3223b645672e723", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/5cd31674012422df6e4f5040a3223b645672e723", "committedDate": "2020-11-04T22:30:09Z", "message": "[velux] uploaded latest jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}, "afterCommit": {"oid": "4a8c8552d66a9e340da283b6e7e0df821d62919f", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/4a8c8552d66a9e340da283b6e7e0df821d62919f", "committedDate": "2020-11-04T22:58:14Z", "message": "[velux] faster synch of actuator changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea00ed9386a2a2ed6e032c0595e2714f230da698", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/ea00ed9386a2a2ed6e032c0595e2714f230da698", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] set explicit timeouts & keepalives on socket\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a478a7372269cd3b21e41b85aeecd66f731be13", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0a478a7372269cd3b21e41b85aeecd66f731be13", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] implement mdns service\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf0963c983beca47ecb59529b61a59dc0f5f8746", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/cf0963c983beca47ecb59529b61a59dc0f5f8746", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] tweak mdns-sd service\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7180ee34fddaa44da7b700c1fab5d7e34b4d9e59", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/7180ee34fddaa44da7b700c1fab5d7e34b4d9e59", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] wip for mdns discovery\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dac4b62c8741001d684f4b247aa2f9553febee3", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0dac4b62c8741001d684f4b247aa2f9553febee3", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] fix representation property names\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30697fe5bb16f3a671babc8f228819ac92648928", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/30697fe5bb16f3a671babc8f228819ac92648928", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] fix representation properties\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21de8eafc53b8fd44d593a75a0d3c71bb718c0d3", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/21de8eafc53b8fd44d593a75a0d3c71bb718c0d3", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] finalize mdns\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0605697ced22f6b2ae1fafb39279c9757694e988", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0605697ced22f6b2ae1fafb39279c9757694e988", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] spotless\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc8039371559fa43b66cf9a252ea97e19e193305", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/cc8039371559fa43b66cf9a252ea97e19e193305", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] use both mDNS and regular DNS to resolve ip addresses\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0227521420a677826d98587a46e4d2dd4646d9e", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/d0227521420a677826d98587a46e4d2dd4646d9e", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] code style\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd662cecd2101fc8dd21c55a7f271f464308b4fc", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/cd662cecd2101fc8dd21c55a7f271f464308b4fc", "committedDate": "2020-11-04T23:14:50Z", "message": "[velux] complete class rewrite using asynchronous polling thread\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7076baa040229cb9136e4edc0e9a3ae5f1ea4384", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/7076baa040229cb9136e4edc0e9a3ae5f1ea4384", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] refactor bridgeDirectCommunicate to simplify looping\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca2bd90334ab5b72b9800f0bae6ee03dc1bb2ba5", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/ca2bd90334ab5b72b9800f0bae6ee03dc1bb2ba5", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] asynchronous polling means Thread.sleep no longer needed\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c23bb33e0d046ef422198fe90d56bac84b0ea84", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/1c23bb33e0d046ef422198fe90d56bac84b0ea84", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] modified to use asynchronous polling\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "063c12f64e0b5b1acd0a27530bc06e9bcb5fa0f1", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/063c12f64e0b5b1acd0a27530bc06e9bcb5fa0f1", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] add auto discovery to ReadMe.md\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "860f8c805974a004d60a5187da90ac80a77998fe", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/860f8c805974a004d60a5187da90ac80a77998fe", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] implement closeable\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60c7a6ed4d540ad1d895e1857e30d9531a953754", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/60c7a6ed4d540ad1d895e1857e30d9531a953754", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] logging tweaks\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cf104774f51ddb0d08bfa79c3d6c487246b0fd1", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/3cf104774f51ddb0d08bfa79c3d6c487246b0fd1", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] faster synch of actuator changes\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31004875c36563eb14f4481ad056d4de17dfe0fe", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/31004875c36563eb14f4481ad056d4de17dfe0fe", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] latest jar upload\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c512683c4cbb8931fd4ee5f8a3fb063a5059a50f", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/c512683c4cbb8931fd4ee5f8a3fb063a5059a50f", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] comms tweaks\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b650fec400c298260058cfd2f30b6b87fd0ae8e", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/9b650fec400c298260058cfd2f30b6b87fd0ae8e", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] faster update of channels\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f82b374308687d8bf4ad6deab39e1123eb1fa70", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0f82b374308687d8bf4ad6deab39e1123eb1fa70", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] upload latest jar file\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff22dadb26489730602207b8c90871998db681b", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/8ff22dadb26489730602207b8c90871998db681b", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] fix mdns discovery\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7278eb3fb8b9b141d79183f4202756b54a3bcf4", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7278eb3fb8b9b141d79183f4202756b54a3bcf4", "committedDate": "2020-11-04T23:14:51Z", "message": "[velux] tweaked logging\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7659dfb17265313a28a0e696ff32f299e854cb0", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7659dfb17265313a28a0e696ff32f299e854cb0", "committedDate": "2020-11-04T23:14:52Z", "message": "[velux] upload latest jar file\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d44e919822d6f4a37294a898c4561fc20b52414", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0d44e919822d6f4a37294a898c4561fc20b52414", "committedDate": "2020-11-04T23:14:52Z", "message": "[velux] use single thread executor instead of thread pool\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9ac8aab54713b17ac9c1e787afe42c03d4df559", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/f9ac8aab54713b17ac9c1e787afe42c03d4df559", "committedDate": "2020-11-04T23:14:52Z", "message": "[velux] faster synch of actuator changes\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a8c8552d66a9e340da283b6e7e0df821d62919f", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/4a8c8552d66a9e340da283b6e7e0df821d62919f", "committedDate": "2020-11-04T22:58:14Z", "message": "[velux] faster synch of actuator changes"}, "afterCommit": {"oid": "f9ac8aab54713b17ac9c1e787afe42c03d4df559", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/f9ac8aab54713b17ac9c1e787afe42c03d4df559", "committedDate": "2020-11-04T23:14:52Z", "message": "[velux] faster synch of actuator changes\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ef30f3f3c0ae530c0072956bf2eeeb9acf9973f", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/4ef30f3f3c0ae530c0072956bf2eeeb9acf9973f", "committedDate": "2020-11-05T00:01:28Z", "message": "[velux] shut down task executor\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4083f06acf573d82f7fa579e8e1141031f2101dd", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/4083f06acf573d82f7fa579e8e1141031f2101dd", "committedDate": "2020-11-06T18:07:04Z", "message": "[velux] read me\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "964d3fda03027c2c41c68f4f1b0dde41a221d125", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/964d3fda03027c2c41c68f4f1b0dde41a221d125", "committedDate": "2020-11-06T18:07:46Z", "message": "[velux] fix configuration checks\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d4340056f576210cfb951c54ef36851f87aac02", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/2d4340056f576210cfb951c54ef36851f87aac02", "committedDate": "2020-11-06T18:08:14Z", "message": "[velux] java doc\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a8d42aa4fb1932709555349d2a9c6c6f3e884d6", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/8a8d42aa4fb1932709555349d2a9c6c6f3e884d6", "committedDate": "2020-11-06T18:08:37Z", "message": "[velux] lower logger level\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c6f93632bbfee6c77511314dc021d7b1ede3637", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/3c6f93632bbfee6c77511314dc021d7b1ede3637", "committedDate": "2020-11-06T18:09:12Z", "message": "[velux] remove comment\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ed28940c62de80a1f850701ed45c96481b10c30", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/7ed28940c62de80a1f850701ed45c96481b10c30", "committedDate": "2020-11-06T18:10:14Z", "message": "[velux] changes in refresh code\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bcfa770e7d674236a59d6c13c42fbfafcc2f516", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/3bcfa770e7d674236a59d6c13c42fbfafcc2f516", "committedDate": "2020-11-10T14:53:42Z", "message": "[velux] fix bug in enum\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5155456def00740d4b7f35255ef0343162cedbae", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/5155456def00740d4b7f35255ef0343162cedbae", "committedDate": "2020-11-10T14:58:30Z", "message": "[velux] better shutdown code\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7ed1adbe935cc087fbe3dd9d5fa7483db97df3c", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7ed1adbe935cc087fbe3dd9d5fa7483db97df3c", "committedDate": "2020-11-10T14:59:50Z", "message": "[velux] first start up of polling loop\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c2599323d8aa03f0540066881f8888b2fc5539d", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/5c2599323d8aa03f0540066881f8888b2fc5539d", "committedDate": "2020-11-10T15:00:11Z", "message": "[velux] cosmetics\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c73a7ac087bbd6756730dfcb2146ee318e929420", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/c73a7ac087bbd6756730dfcb2146ee318e929420", "committedDate": "2020-11-10T16:10:36Z", "message": "[velux] upload latest jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47de9079beb414e31dbef8260c7fc8a079ec81ea", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/47de9079beb414e31dbef8260c7fc8a079ec81ea", "committedDate": "2020-11-10T16:11:29Z", "message": "[velux] use all possible in motion states\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c853e98efd3156f870aea6492a1dc86a5651ca0", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/8c853e98efd3156f870aea6492a1dc86a5651ca0", "committedDate": "2020-11-10T18:13:41Z", "message": "[velux] use all possible in motion states\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbf990f8a0f38a904aae23ba63bccc292f6fef96", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/cbf990f8a0f38a904aae23ba63bccc292f6fef96", "committedDate": "2020-11-12T19:21:11Z", "message": "[velux] implement reboot action\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b77020d4a38a8ee8c9794ac5e683568a44f7509", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/4b77020d4a38a8ee8c9794ac5e683568a44f7509", "committedDate": "2020-11-12T19:24:15Z", "message": "[velux] undef position in manual override, and better code style\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "868cbd4390b75bfadd035e114ef215650edcc36e", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/868cbd4390b75bfadd035e114ef215650edcc36e", "committedDate": "2020-11-12T19:24:31Z", "message": "[velux] upload jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebe4201cc532f3a62fb3969f33d3bef3e9b6dba0", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/ebe4201cc532f3a62fb3969f33d3bef3e9b6dba0", "committedDate": "2020-11-13T15:16:04Z", "message": "[velux] tweak getDisplayPosition(); delete isManualOpen()\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8eff129cf40472b5711b9bcd0102c87760c0ee9", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/e8eff129cf40472b5711b9bcd0102c87760c0ee9", "committedDate": "2020-11-14T12:31:53Z", "message": "[vlux] fine tine logic\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81e46f1f12a99dac22decfe2efd080265b664cbc", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/81e46f1f12a99dac22decfe2efd080265b664cbc", "committedDate": "2020-11-14T12:32:11Z", "message": "[velux] upload jar\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3924cd5c7c50939f562e5f70851c7958072e3c8a", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/3924cd5c7c50939f562e5f70851c7958072e3c8a", "committedDate": "2020-11-15T12:59:24Z", "message": "[velux] information about position channel\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1188a0b01d474498e6d1b904b363a1021109bad3", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/1188a0b01d474498e6d1b904b363a1021109bad3", "committedDate": "2020-11-15T13:00:03Z", "message": "[velux] only log is actual socket closing..\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e918a5458d72f67c2746cee235a7c4d95f26138c", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/e918a5458d72f67c2746cee235a7c4d95f26138c", "committedDate": "2020-11-15T16:05:09Z", "message": "[velux] added rule example\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0469fbbb85ec339cbe9879077a6fd564b0e0ab25", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0469fbbb85ec339cbe9879077a6fd564b0e0ab25", "committedDate": "2020-11-17T12:57:35Z", "message": "[velux] clean up properties vs. config params vs. channels\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "344e29439fafa4b1ff9928c61930cf38bdc41a17", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/344e29439fafa4b1ff9928c61930cf38bdc41a17", "committedDate": "2020-11-17T12:58:24Z", "message": "[velux] code style\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9adfd2853943583b78d895c0fb063de0714f3b4e", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/9adfd2853943583b78d895c0fb063de0714f3b4e", "committedDate": "2020-11-17T12:58:50Z", "message": "[velux] actually save config changes\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "474b711a43cfe82629e00ba53c026500364f8a82", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/474b711a43cfe82629e00ba53c026500364f8a82", "committedDate": "2020-11-17T12:59:41Z", "message": "[velux] upload jar file\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd65fc1887d692bf242ce8a11ffe8541326a3f4", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/2dd65fc1887d692bf242ce8a11ffe8541326a3f4", "committedDate": "2020-11-17T15:10:17Z", "message": "[velux] longer timeout\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "815d87eb61e782df09d3da4cea50b3b96fbc6814", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/815d87eb61e782df09d3da4cea50b3b96fbc6814", "committedDate": "2020-11-17T16:10:53Z", "message": "[velux] deprecated classes marked as such\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "accba2c5ccf68f50e85547ff890671e1180a7030", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/accba2c5ccf68f50e85547ff890671e1180a7030", "committedDate": "2020-11-18T17:58:46Z", "message": "[velux] rewrite bridge discovery\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff2bd01d0858443cec57781effd9ccee3d41e871", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/ff2bd01d0858443cec57781effd9ccee3d41e871", "committedDate": "2020-11-23T17:51:54Z", "message": "[velux] actions tweaks\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b94b87dcedb6ea0b5109080bf852e253f00b51c7", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/b94b87dcedb6ea0b5109080bf852e253f00b51c7", "committedDate": "2020-11-23T17:53:06Z", "message": "[velux] moveRelative()\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70225f66d8dc1b5fc66c71ccd2802dfef764a391", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/70225f66d8dc1b5fc66c71ccd2802dfef764a391", "committedDate": "2020-11-23T17:54:17Z", "message": "[velux] upload jar file\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68dad575579d134733613144caffad0a127675f4", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/68dad575579d134733613144caffad0a127675f4", "committedDate": "2020-11-24T12:26:43Z", "message": "[velux] fianlize Somfy issue\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3Njc4OTc0", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-537678974", "createdAt": "2020-11-24T16:14:17Z", "commit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxNDoxN1rOH5KQiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzoxNTo0NlrOH5NBMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5ODk1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n          \n          \n            \n                        Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n          \n          \n            \n                                THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE));\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = Set.of(THING_TYPE_VELUX_SCENE,\n          \n          \n            \n                        THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER, THING_TYPE_VELUX_WINDOW,\n          \n          \n            \n                        THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE);", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529698952", "createdAt": "2020-11-24T16:14:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/VeluxBindingConstants.java", "diffHunk": "@@ -91,10 +91,15 @@\n     // Definitions of different set of Things\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BINDING = new HashSet<>(Arrays.asList(THING_TYPE_BINDING));\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BRIDGE = new HashSet<>(Arrays.asList(THING_TYPE_BRIDGE));\n+\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_ITEMS = new HashSet<>(\n             Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n                     THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER));\n \n+    public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n+            Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n+                    THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwMjI4Ng==", "bodyText": "The label is integrated into a sentence (When ... then ...) in the rules and should therefore be lowercase. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")\n          \n          \n            \n                @RuleAction(label = \"reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529702286", "createdAt": "2020-11-24T16:17:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNDMzNA==", "bodyText": "You could add required/label/description to the input arguments.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529704334", "createdAt": "2020-11-24T16:20:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean rebootBridge()\n+            throws IllegalStateException {\n+        logger.trace(\"rebootBridge(): action called\");\n+        VeluxBridgeHandler bridge = bridgeHandler;\n+        if (bridge == null) {\n+            throw new IllegalStateException(\"Bridge instance is null\");\n+        }\n+        return bridge.runReboot();\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Move Relative\", description = \"issues a relative move command to an actuator\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean moveRelative(\n+            @ActionInput(name = \"nodeId\") String nodeId, @ActionInput(name = \"relativePercent\") String relativePercent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTM0OQ==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be trace. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529709349", "createdAt": "2020-11-24T16:26:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMDc1Mg==", "bodyText": "Can you work on that to remove the TODO?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529710752", "createdAt": "2020-11-24T16:28:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;\n+                    break;\n                 }\n-                // Handle some common (unexpected) answers\n-                switch (Command.get(responseCommand)) {\n-                    case GW_NODE_INFORMATION_CHANGED_NTF:\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: received GW_NODE_INFORMATION_CHANGED_NTF.\",\n-                                host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_NODE_STATE_POSITION_CHANGED_NTF:\n-                        logger.trace(\n-                                \"bridgeDirectCommunicate() on {}: received GW_NODE_STATE_POSITION_CHANGED_NTF, special processing of this packet.\",\n-                                host);\n-                        SCgetHouseStatus receiver = new SCgetHouseStatus();\n-                        receiver.setResponse(responseCommand, responseData, isSequentialEnforced);\n-                        if (receiver.isCommunicationSuccessful()) {\n-                            logger.trace(\"bridgeDirectCommunicate() on {}: existingProducts().update() called.\", host);\n-                            bridgeInstance.existingProducts().update(new ProductBridgeIndex(receiver.getNtfNodeID()),\n-                                    receiver.getNtfState(), receiver.getNtfCurrentPosition(), receiver.getNtfTarget());\n-                        }\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_ERROR_NTF:\n-                        switch (responseData[0]) {\n-                            case 0:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF on {} (Not further defined error), aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 1:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Unknown Command or command is not accepted at this state) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 2:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (ERROR on Frame Structure) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 7:\n-                                logger.trace(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Busy. Try again later) on {}, retrying.\",\n-                                        host, commandString);\n-                                sendBytes = emptyPacket;\n-                                continue;\n-                            case 8:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Bad system table index) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 12:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Not authenticated) on {}, aborting.\",\n-                                        host, commandString);\n-                                resetAuthentication();\n-                                break communication;\n-                            default:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF ({}) on {}, aborting.\",\n-                                        host, responseData[0], commandString);\n-                                break communication;\n-                        }\n-                    case GW_ACTIVATION_LOG_UPDATED_NTF:\n-                        logger.info(\"bridgeDirectCommunicate() on {}: received GW_ACTIVATION_LOG_UPDATED_NTF.\", host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-\n-                    case GW_COMMAND_RUN_STATUS_NTF:\n-                    case GW_COMMAND_REMAINING_TIME_NTF:\n-                    case GW_SESSION_FINISHED_NTF:\n-                        if (!isSequentialEnforced) {\n-                            logger.trace(\n-                                    \"bridgeDirectCommunicate() on {}: response ignored due to activated parallelism, continue with receiving.\",\n-                                    host);\n-                            continue;\n+            } catch (IOException e) {\n+                logger.debug(loggerFmt, \"i/o error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // RFC1055 decode response\n+            byte[] rfc1055;\n+            try {\n+                rfc1055 = new SlipRFC1055().decode(rxPacket);\n+            } catch (ParseException e) {\n+                logger.debug(loggerFmt, \"parsing error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // SLIP decode response\n+            SlipEncoding slipEnc = new SlipEncoding(rfc1055);\n+            if (!slipEnc.isValid()) {\n+                logger.debug(loggerFmt, \"slip decode error\", \"=> aborting\", \"\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // attributes of the received (rx) response\n+            final short rxCmd = slipEnc.getCommand();\n+            final byte[] rxData = slipEnc.getData();\n+            final Command rxEnum = Command.get(rxCmd);\n+            final String rxName = rxEnum.toString();\n+\n+            // logging\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(loggerFmt, rxName, \"=> received data =>\", new Packet(rxData));\n+            } else {\n+                logger.debug(loggerFmt, rxName, \"=> received data length =>\", rxData.length);\n+            }\n+            if (isProtocolTraceEnabled) {\n+                logger.info(\"received message {} => {}\", rxName, new Packet(rxData));\n+            }\n+\n+            // handling of the responses\n+            switch (rxEnum) {\n+                case GW_ERROR_NTF:\n+                    byte code = rxData[0];\n+                    switch (code) {\n+                        case 7: // busy\n+                            logger.trace(loggerFmt, rxName, getErrorText(code), \"=> retrying\");\n+                            sending = true; // TODO: I am not sure if we should retry sending", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNjMzMw==", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)\nAlso, please set a thread name according this scheme #8216.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529716333", "createdAt": "2020-11-24T16:36:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,195 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzQ4Mg==", "bodyText": "Can this be a constant?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529717482", "createdAt": "2020-11-24T16:37:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -62,13 +64,11 @@\n      * ***** Private Objects *****\n      */\n \n-    private static final int CONNECTION_BUFFER_SIZE = 4096;\n-\n-    private boolean ready = false;\n     private @Nullable SSLSocket socket;\n     private @Nullable DataOutputStream dOut;\n     private @Nullable DataInputStreamWithTimeout dIn;\n-    private int ioTimeoutMSecs = 60000;\n+    private int ioTimeoutMSecs = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxODIyNw==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529718227", "createdAt": "2020-11-24T16:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -247,67 +241,39 @@ synchronized boolean available() throws IOException {\n      * Destructor to tear down a connection.\n      *\n      * @throws java.io.IOException in case of a communication I/O failure.\n+     *             But actually eats all exceptions to ensure sure that all shutdown code is executed\n      */\n-    synchronized void close() throws IOException {\n+    @Override\n+    public synchronized void close() throws IOException {\n         logger.debug(\"close() called.\");\n-        ready = false;\n-        logger.info(\"Shutting down Velux bridge connection.\");\n-        // Just for avoidance of Potential null pointer access\n         DataInputStreamWithTimeout dInX = dIn;\n         if (dInX != null) {\n-            dInX.close();\n-            dIn = null;\n+            try {\n+                dInX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         DataOutputStream dOutX = dOut;\n         if (dOutX != null) {\n-            dOutX.close();\n-            dOut = null;\n+            try {\n+                dOutX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         SSLSocket socketX = socket;\n         if (socketX != null) {\n-            socketX.close();\n-            socket = null;\n-        }\n-        logger.trace(\"close() finished.\");\n-    }\n-\n-    /**\n-     * Parameter modification.\n-     *\n-     * @param timeoutMSecs the maximum duration in milliseconds for read operations.\n-     */\n-    void setTimeout(int timeoutMSecs) {\n-        logger.debug(\"setTimeout() set timeout to {} milliseconds.\", timeoutMSecs);\n-        ioTimeoutMSecs = timeoutMSecs;\n-    }\n-\n-    /**\n-     * Method to flush the input buffer.\n-     *\n-     * @throws java.io.IOException in case of a communication I/O failure.\n-     */\n-    private void flushReadBufffer() throws IOException {\n-        logger.trace(\"flushReadBuffer() called.\");\n-        DataInputStreamWithTimeout dInX = dIn;\n-        if (!ready || (dInX == null)) {\n-            throw new IOException();\n-        }\n-        int byteCount = dInX.available();\n-        if (byteCount > 0) {\n-            byte[] byteArray = new byte[byteCount];\n-            dInX.readFully(byteArray);\n-            if (logger.isTraceEnabled()) {\n-                StringBuilder stringBuilder = new StringBuilder();\n-                for (byte currByte : byteArray) {\n-                    stringBuilder.append(String.format(\"%02X \", currByte));\n-                }\n-                logger.trace(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer: {}\", byteCount,\n-                        stringBuilder.toString());\n-            } else {\n-                logger.warn(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer\", byteCount);\n+            logger.info(\"Shutting down Velux bridge connection.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDE0OQ==", "bodyText": "You don't need to store these if you only want to skip a short. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                @SuppressWarnings(\"unused\")\n          \n          \n            \n                                short nsCount = dataStream.readShort();\n          \n          \n            \n                                @SuppressWarnings(\"unused\")\n          \n          \n            \n                                short arCount = dataStream.readShort();\n          \n          \n            \n                                dataStream.readShort(); // nsCount\n          \n          \n            \n                                dataStream.readShort(); // arCount", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529720149", "createdAt": "2020-11-24T16:41:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMTcwMg==", "bodyText": "Did you take a look at dataStream.readNBytes(len)? Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529721702", "createdAt": "2020-11-24T16:43:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNjM4Mg==", "bodyText": "As this has a finite runtime, you could use the scheduler provided by the discovery service to run the listener.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529726382", "createdAt": "2020-11-24T16:50:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener thread\n+     */\n+    private void startListener() {\n+        Thread listenerThreadX = this.listenerThread;\n+        if (listenerThreadX == null) {\n+            listenerThreadX = listenerThread = new Thread(listenerRunnable);\n+            listenerThreadX.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzA0OA==", "bodyText": "Can the comment be remvoed?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529727048", "createdAt": "2020-11-24T16:51:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -45,19 +46,14 @@\n  *\n  * @author Guenther Schreiner - Initial contribution.\n  */\n-//\n-// To-be-discussed: check whether an immediate activation is preferable.\n-// Might be activated by:\n-// @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n-//\n @NonNullByDefault\n @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n public class VeluxDiscoveryService extends AbstractDiscoveryService implements Runnable {\n     private final Logger logger = LoggerFactory.getLogger(VeluxDiscoveryService.class);\n \n     // Class internal\n \n-    private static final int DISCOVER_TIMEOUT_SECONDS = 300;\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 60; // 300;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzQ0Mw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529727443", "createdAt": "2020-11-24T16:51:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -161,7 +160,7 @@ protected synchronized void startScan() {\n     public synchronized void stopScan() {\n         logger.trace(\"stopScan() called.\");\n         super.stopScan();\n-        removeOlderResults(getTimestampOfLastScan());\n+        // removeOlderResults(getTimestampOfLastScan());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDE2NQ==", "bodyText": "If I understand correctly, you remove the bridges from the result, which already exist as a Thing. This is done by the framework if the representation properties are the same.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529730165", "createdAt": "2020-11-24T16:55:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -286,4 +285,27 @@ public boolean removeBridge(VeluxBridgeHandler bridge) {\n     public boolean isEmpty() {\n         return bridgeHandlers.isEmpty();\n     }\n+\n+    /**\n+     * Discover any bridges on the network that are not yet instantiated.\n+     */\n+    private void discoverBridges() {\n+        // discover the list of IP addresses of bridges on the network\n+        Set<String> foundBridgeIpAddresses = VeluxBridgeFinder.discoverIpAddresses();\n+\n+        // remove already instantiated bridges from the list\n+        for (VeluxBridgeHandler existingBridge : bridgeHandlers) {\n+            foundBridgeIpAddresses.remove(existingBridge.veluxBridgeConfiguration().ipAddress);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczOTMzMQ==", "bodyText": "The supression isn't needed anymore. Are you sure the map contains the key under all circumstances?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529739331", "createdAt": "2020-11-24T17:08:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -452,28 +468,30 @@ private void syncChannelsWithProducts() {\n                     logger.trace(\"syncChannelsWithProducts(): channel {} not found.\", channelUID);\n                     continue;\n                 }\n-                if (!channel2VeluxActuator.get(channelUID).isKnown()) {\n+                @SuppressWarnings(\"null\")\n+                Thing2VeluxActuator actuator = channel2VeluxActuator.get(channelUID);\n+                if (!actuator.isKnown()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MTc3Nw==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529741777", "createdAt": "2020-11-24T17:12:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -706,4 +747,59 @@ private synchronized void handleCommandScheduled(ChannelUID channelUID, Command\n                 new java.util.Date(thisBridge.lastSuccessfulCommunication()).toString());\n         logger.trace(\"handleCommandScheduled({}) done.\", Thread.currentThread());\n     }\n+\n+    /**\n+     * Register the exported actions\n+     */\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(VeluxActions.class);\n+    }\n+\n+    /**\n+     * Exported method (called by an OpenHAB Rules Action) to issue a reboot command to the hub.\n+     *\n+     * @return true if the command could be issued\n+     */\n+    public boolean runReboot() {\n+        logger.trace(\"runReboot() called on {}\", getThing().getUID());\n+        RunReboot bcp = thisBridge.bridgeAPI().runReboot();\n+        if (bcp != null && handleScheduler != null) {\n+            // background execution of reboot process\n+            handleScheduler.execute(() -> {\n+                if (thisBridge.bridgeCommunicate(bcp)) {\n+                    logger.info(\"Reboot command {}sucessfully sent to {}\", bcp.isCommunicationSuccessful() ? \"\" : \"un\",\n+                            getThing().getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NDE3Nw==", "bodyText": "If I see correctly, this doesn't change any semantic. I think it's logical to use logical ORs here. What's the purpose of this change?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529744177", "createdAt": "2020-11-24T17:15:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,8 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdf2b06531398c33d7586659083928f0cc0aa5ee", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/cdf2b06531398c33d7586659083928f0cc0aa5ee", "committedDate": "2020-11-25T15:10:25Z", "message": "[velux] implement code reviewer suggestions\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd262cebb7eb426b7e8bf85a4388539ae29dc005", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/dd262cebb7eb426b7e8bf85a4388539ae29dc005", "committedDate": "2020-11-25T15:14:23Z", "message": "[velux] remove jar from pull request\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/e58c50a9777538ffe7de0fb104220df902c237b3", "committedDate": "2020-11-25T18:26:56Z", "message": "[velux] implement suggestions by code reviewer\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzczNjcz", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-538773673", "createdAt": "2020-11-25T18:54:40Z", "commit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1NDo0MVrOH6AQXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1NzoxM1rOH6AVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ==", "bodyText": "This should contain the Thing UID.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530583645", "createdAt": "2020-11-25T18:54:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NDg1OA==", "bodyText": "Do you apply the suggestion?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530584858", "createdAt": "2020-11-25T18:57:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDE0OQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODY2MjA5", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-538866209", "createdAt": "2020-11-25T21:50:23Z", "commit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo1MDoyM1rOH6E5HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjoyMjoyMlrOH6Fp7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTYxMg==", "bodyText": "You don't need to set looping if you are just going to break out of the loop anyway. There are a lot of other places you are doing this too.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530659612", "createdAt": "2020-11-25T21:50:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MDU5Mw==", "bodyText": "Please don't use assert. Please throw an exception instead.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530660593", "createdAt": "2020-11-25T21:53:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjgxOA==", "bodyText": "What's wrong with reading in bulk?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530662818", "createdAt": "2020-11-25T21:58:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NjkwNw==", "bodyText": "Since this is a very long running task you should run this asynchronously so that it can be cancelled by the caller if they need to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> discoverBridgeIpAddresses() {\n          \n          \n            \n                private Future<Set<String>> discoverBridgeIpAddresses() {\n          \n      \n    \n    \n  \n\nAs far as how to implement the future, I suggest using a FutureTask.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530666907", "createdAt": "2020-11-25T22:07:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener task\n+     */\n+    private void startListener() {\n+        listenerTask = scheduler.submit(listenerRunnable);\n+    }\n+\n+    /**\n+     * Stop the listener task\n+     */\n+    private void stopListener() {\n+        Future<?> listenerTask = this.listenerTask;\n+        if (listenerTask != null) {\n+            listenerTask.cancel(false);\n+        }\n+        this.listenerTask = null;\n+    }\n+\n+    /**\n+     * Private method that searches for Velux Bridges and returns their IP addresses\n+     *\n+     * @return list of dotted IP address e.g. '123.123.123.123'\n+     */\n+    private Set<String> discoverBridgeIpAddresses() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2OTM1OQ==", "bodyText": "Please create the executor with a NamedThreadFactory so that you can give the threads names that you can tie to this binding/handler. Also make sure that the created threads are daemon.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530669359", "createdAt": "2020-11-25T22:14:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -250,10 +260,7 @@ public void initialize() {\n             logger.warn(\"initialize(): scheduler is shutdown, aborting the initialization of this bridge.\");\n             return;\n         }\n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"initialize(): handleScheduler is shutdown, aborting the initialization of this bridge.\");\n-            return;\n-        }\n+        handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MTE1Mw==", "bodyText": "I'd prefer if you avoided all of the boolean operator trickery in general.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /*\n          \n          \n            \n                     * If the following if statement used the || operator, the compiler would do logical short circuit optimisation\n          \n          \n            \n                     * so that if the leftmost function evaluated to true, the further right functions would not get called; so we\n          \n          \n            \n                     * use the | operator instead which prevents short circuiting so all three property setters are always called.\n          \n          \n            \n                     */\n          \n          \n            \n                    if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n          \n          \n            \n                            | thisProduct.setTarget(productTarget)) {\n          \n          \n            \n                        dirty = true;\n          \n          \n            \n                    dirty |= thisProduct.setState(productState);\n          \n          \n            \n                    dirty |= thisProduct.setCurrentPosition(productPosition);\n          \n          \n            \n                    dirty |= thisProduct.setTarget(productTarget);\n          \n          \n            \n                    if (dirty) {", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530671153", "createdAt": "2020-11-25T22:19:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,13 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        /*\n+         * If the following if statement used the || operator, the compiler would do logical short circuit optimisation\n+         * so that if the leftmost function evaluated to true, the further right functions would not get called; so we\n+         * use the | operator instead which prevents short circuiting so all three property setters are always called.\n+         */\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {\n             dirty = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MjExMQ==", "bodyText": "see earlier comment", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530672111", "createdAt": "2020-11-25T22:22:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -397,9 +409,10 @@ private void bridgeParamsUpdated() {\n     private synchronized void refreshOpenHAB() {\n         logger.debug(\"refreshOpenHAB() initiated by {} starting cycle {}.\", Thread.currentThread(), refreshCounter);\n \n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"refreshOpenHAB(): handleScheduler is shutdown, recreating a scheduler pool.\");\n-            handleScheduler = ThreadPoolManager.getScheduledPool(VeluxBindingConstants.BINDING_ID);\n+        ExecutorService handleScheduler = this.handleScheduler;\n+        if ((handleScheduler == null) || handleScheduler.isShutdown()) {\n+            logger.trace(\"refreshOpenHAB(): handleScheduler is shutdown, recreating a scheduler.\");\n+            handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c368e4c88ec7eafaa7e0e5deebc1e9c4cadbfbff", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/c368e4c88ec7eafaa7e0e5deebc1e9c4cadbfbff", "committedDate": "2020-11-25T23:43:00Z", "message": "[velux] implement suggestions by code reviewer\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fc1452a5f8285e47356564775c721e38df8b115", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/1fc1452a5f8285e47356564775c721e38df8b115", "committedDate": "2020-11-26T17:19:02Z", "message": "[velux] implement suggestions by code reviewer\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03aca9f1110cfe0e7e2ff3c19c213b885a5a0b0a", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/03aca9f1110cfe0e7e2ff3c19c213b885a5a0b0a", "committedDate": "2020-11-26T19:12:17Z", "message": "[velux] remove demonization\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NzQyNTI1", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-539742525", "createdAt": "2020-11-27T06:56:14Z", "commit": {"oid": "03aca9f1110cfe0e7e2ff3c19c213b885a5a0b0a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fce1d2a517c8a4c40fab7061bdf35bd36235f2b", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/6fce1d2a517c8a4c40fab7061bdf35bd36235f2b", "committedDate": "2020-11-27T12:17:45Z", "message": "[velux] shutdown\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bc5714ca600e3cb04927bbd15a975445271917c", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/5bc5714ca600e3cb04927bbd15a975445271917c", "committedDate": "2020-11-27T13:09:38Z", "message": "[velux] task safety check\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f23acae02d33b9c72cd1fce0919de54a722c9cd", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/0f23acae02d33b9c72cd1fce0919de54a722c9cd", "committedDate": "2020-11-28T18:15:25Z", "message": "[velux] pass bridge instance down to io poller\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51d0f6d5a0359674f3f4111853e5f9eeebe64744", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/51d0f6d5a0359674f3f4111853e5f9eeebe64744", "committedDate": "2020-11-28T18:16:44Z", "message": "[velux] refactored hub discovery\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79", "committedDate": "2020-11-29T17:40:33Z", "message": "[velux] fix threading issues\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjQ0NDEx", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-541244411", "createdAt": "2020-11-30T19:52:31Z", "commit": {"oid": "b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo1MjozMVrOH8LVIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo1MjozMVrOH8LVIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjI0MQ==", "bodyText": "You should shutdown the executor here.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r532862241", "createdAt": "2020-11-30T19:52:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,220 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Poller pollRunner = null;\n+    private ExecutorService executor;\n+\n+    private class Poller implements Callable<Boolean> {\n+\n+        private boolean interrupted = false;\n+\n+        public void interrupt() {\n+            interrupted = true;\n+        }\n+\n+        /**\n+         * Task that loops to read bytes from {@link InputStream} and build SLIP packets from them. The SLIP packets are\n+         * placed in a {@link ConcurrentLinkedQueue}. It loops continuously until 'interrupt()' or 'Thread.interrupt()'\n+         * are called when terminates early after the next socket read timeout.\n+         */\n+        @Override\n+        public Boolean call() throws Exception {\n+            byte[] buf = new byte[BUFFER_SIZE];\n+            byte byt;\n+            int i = 0;\n+\n+            // clean start, no exception, empty queue\n+            pollException = \"\";\n+            slipMessageQueue.clear();\n+\n+            // loop forever or until internally or externally interrupted\n+            while ((!interrupted) && (!Thread.interrupted())) {\n+                try {\n+                    buf[i] = byt = (byte) inputStream.read();\n+                    if (byt == SLIP_MARK) {\n+                        if (i > 0) {\n+                            // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                            if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                                slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                                if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                    logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                    slipMessageQueue.poll();\n+                                }\n+                            }\n+                            i = 0;\n+                            buf[0] = SLIP_MARK;\n+                            continue;\n+                        }\n+                    }\n+                    if (++i >= BUFFER_SIZE) {\n+                        i = 0;\n+                    }\n+                } catch (SocketTimeoutException e) {\n+                    // socket read time outs are OK => keep on polling\n+                    continue;\n+                } catch (IOException e) {\n+                    // any other exception => stop polling\n+                    pollException = e.getMessage();\n+                    logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                    break;\n+                }\n+            }\n+\n+            // we only get here if shutdown or an error occurs so free ourself so we can be recreated again\n+            pollRunner = null;\n+            return true;\n+        }\n+    }\n \n     /**\n-     * Executor for asynchronous read command\n+     * Check if there was an exception on the polling loop task and if so, throw it back on the caller thread.\n+     *\n+     * @throws IOException\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n+    }\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying {@link InputStream}\n      *\n-     * @param in the specified input stream\n+     * @param stream the specified input stream\n+     * @param bridge the actual Bridge Thing instance\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    public DataInputStreamWithTimeout(InputStream stream, VeluxBridgeHandler bridge) {\n+        inputStream = stream;\n+        executor = Executors.newSingleThreadExecutor(bridge.getThreadFactory());\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n-     *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11cc28d3d7ae9bb11b0c883049a6c8feb025da27", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/11cc28d3d7ae9bb11b0c883049a6c8feb025da27", "committedDate": "2020-11-30T22:38:21Z", "message": "[velux] apply reviewer request\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "248ab01dd4467df50ff1717c29bf6ab2e55933eb", "author": {"user": {"login": "andrewfg", "name": "Andrew Fiddian-Green"}}, "url": "https://github.com/openhab/openhab-addons/commit/248ab01dd4467df50ff1717c29bf6ab2e55933eb", "committedDate": "2020-12-01T10:34:44Z", "message": "[velux] jenkins null warning\n\nSigned-off-by: Andrew Fiddian-Green <software@whitebear.ch>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTEwNjMx", "url": "https://github.com/openhab/openhab-addons/pull/8777#pullrequestreview-542110631", "createdAt": "2020-12-01T17:02:15Z", "commit": {"oid": "248ab01dd4467df50ff1717c29bf6ab2e55933eb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4296, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}