{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODMwNTMy", "number": 6985, "title": "[shelly] Support for Duo, EM3, DW, Smoke, Addon; new CoAP-based updates; bug fixes", "bodyText": "Includes Fixes and enhancements based on PR #6764\nSigned-off-by: Markus Michels markus7017@gmail.com", "createdAt": "2020-02-09T13:48:20Z", "url": "https://github.com/openhab/openhab-addons/pull/6985", "merged": true, "mergeCommit": {"oid": "4d65ddf1867464cd60aedda08b6cf97f88482185"}, "closed": true, "closedAt": "2020-04-18T21:30:41Z", "author": {"login": "markus7017"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcT2w-wgFqTM4Njg2MzI3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcY8KWAAH2gAyMzcyODMwNTMyOmExMTQ4OTAwNWU0NDZkYTNjN2Y3ODg2MDY1YTNhNWQ0MmE0YWNjNzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2ODYzMjcx", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-386863271", "createdAt": "2020-04-03T00:21:17Z", "commit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDoyMToxN1rOGAA94g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMTozNjoyMVrOGACMiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg==", "bodyText": "Shouldn't it already be stopped as part of the handler getting disposed?\nWhy do you need to call this here?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669026", "createdAt": "2020-04-03T00:21:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -130,6 +142,7 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n     @Override\n     protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n         if (thingHandler instanceof ShellyBaseHandler) {\n+            ((ShellyBaseHandler) thingHandler).stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTM2Mg==", "bodyText": "Why are you suppressing warnings here?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669362", "createdAt": "2020-04-03T00:22:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTk5MQ==", "bodyText": "Why do you need to suppress warnings? Also isn't apiResult a non-null field?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669991", "createdAt": "2020-04-03T00:24:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return (e != null) && (e.getClass() == MalformedURLException.class);\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return (e != null) && (e.getClass() == UnknownHostException.class);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public ShellyApiResult getApiResult() {\n+        return apiResult != null ? apiResult : new ShellyApiResult();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDUxNA==", "bodyText": "Can this be made final? Making this final would make some of your null checks satisfy the null checker.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670514", "createdAt": "2020-04-03T00:26:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDYzMQ==", "bodyText": "You can remove this.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670631", "createdAt": "2020-04-03T00:27:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDcyNA==", "bodyText": "The null check isn't needed here.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670724", "createdAt": "2020-04-03T00:27:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDgyNg==", "bodyText": "needed?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670826", "createdAt": "2020-04-03T00:27:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -333,21 +445,34 @@\n         public ShellySettingsWiFiNetwork wifiSta1;\n         // public ShellySettingsMqtt mqtt; // not used for now\n         // public ShellySettingsSntp sntp; // not used for now\n+        public ShellySettingsCoiot coiot; // Firmware 1.6+\n         public ShellySettingsLogin login;\n         @SerializedName(\"pin_code\")\n         public String pinCode;\n         @SerializedName(\"coiot_execute_enable\")\n         public Boolean coiotExecuteEnable;\n         public String name;\n+        public Boolean discoverable; // FW 1.6+\n         public String fw;\n         @SerializedName(\"build_info\")\n         ShellySettingsBuildInfo buildInfo;\n         ShellyStatusCloud cloud;\n+        @SerializedName(\"sleep_mode\")\n+        public ShellySensorSleepMode sleepMode; // FW 1.6\n+\n         public String timezone;\n         public Double lat;\n         public Double lng;\n         public Boolean tzautodetect;\n         public String time;\n+        // @SerializedName(\"tz_utc_offset\")\n+        // public Integer tzUTCOoffset; // FW 1.6+\n+        // @SerializedName(\"tz_dst\")\n+        // public Boolean tzDdst; // FW 1.6+\n+        // @SerializedName(\"tz_dst_auto\")\n+        // public Boolean tzDstAuto; // FW 1.6+\n+        // public Long unixtime; // FW 1.6+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ==", "bodyText": "You mention 3 sensors fields but there is only one sensor field in this class.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671291", "createdAt": "2020-04-03T00:29:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -612,20 +762,39 @@\n             public ShellyShortTemp sensor3;\n         }\n \n+        public static class ShellyExtHumidity {\n+            public static class ShellyShortHum {\n+                public Double hum; // Humidity reading of sensor 0, percent\n+            }\n+\n+            // Shelly 1/1PM have up to 3 sensors\n+            // for whatever reasons it's not an array, but 3 independent elements", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 488}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTQ2Mw==", "bodyText": "If this is non-null why not make it primitive?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671463", "createdAt": "2020-04-03T00:29:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpStatus.*;\n+import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+\n+/**\n+ * The {@link ShellyApiResult} wraps up the API result and provides some more information like url, http code, received\n+ * response etc.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiResult {\n+    public String url = \"\";\n+    public String method = \"\";\n+    public String response = \"\";\n+    public Integer httpCode = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTU5NA==", "bodyText": "Why not a boolean?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671594", "createdAt": "2020-04-03T00:30:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -38,14 +41,18 @@\n  */\n @NonNullByDefault\n public class ShellyDeviceProfile {\n+    public Boolean initialized = false; // true when initialized", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjExOA==", "bodyText": "Any reason to not include the cause exception?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672118", "createdAt": "2020-04-03T00:32:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjQ2OA==", "bodyText": "Just to be consistent.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    isSensor = isHT | isFlood | isDW | isSmoke | isSense;\n          \n          \n            \n                    isSensor = isHT || isFlood || isDW || isSmoke || isSense;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672468", "createdAt": "2020-04-03T00:33:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = getString(settings.mode) != null ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = settings.coiot.updatePeriod + 15; // usually 15+15s\n+        }\n+\n+        supportsButtonUrls = settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        supportsOutUrls = settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        supportsPushUrls = settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        supportsRollerUrls = settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        supportsSensorUrls = settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT | isFlood | isDW | isSmoke | isSense;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDgxMA==", "bodyText": "This seems like an inappropriate use of a Scanner. Why not use IOUtils.toString(request.getInputStream()) instead?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402674810", "createdAt": "2020-04-03T00:42:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -132,33 +130,9 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n         }\n     }\n \n-    @SuppressWarnings(\"resource\")\n+    @SuppressWarnings({ \"resource\", \"null\" })\n     private String inputStreamToString(@Nullable HttpServletRequest request) throws IOException {\n-        @SuppressWarnings(\"null\")\n-        Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n+        final Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n         return scanner.hasNext() ? scanner.next() : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTczMw==", "bodyText": "why bother catching it if you are just going to throw it?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402675733", "createdAt": "2020-04-03T00:45:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 569}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzEyNg==", "bodyText": "Can you give an option to support https for the callback or does shelly not support it?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677126", "createdAt": "2020-04-03T00:50:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;\n             }\n         }\n-        return result;\n+        return apiResult.response;\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    @SuppressWarnings(\"null\")\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        return apiResult;\n+    }\n+\n+    public String getControlUrlPrefix(Integer id) {\n+        Validate.notNull(profile);\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n         }\n+        uri = uri + \"/\" + id.toString();\n+        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n+        return uri;\n+    }\n+\n+    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String deviceType, String urlParm) throws ShellyApiException {\n+        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n+                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    private static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String type, String parameter) throws ShellyApiException {\n+        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 662}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzQyMw==", "bodyText": "Can this NPE be prevented or do you have to catch it?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677423", "createdAt": "2020-04-03T00:51:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +300,32 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODk2MA==", "bodyText": "orphan semicolon", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402678960", "createdAt": "2020-04-03T00:57:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTIyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString(), e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679227", "createdAt": "2020-04-03T00:58:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTQyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e.getStackTrace());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679429", "createdAt": "2020-04-03T00:59:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n+                        getString(e.getClass().toString()), e.getStackTrace());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTcyOQ==", "bodyText": "Don't call e.getStacktrace() as part of logging. Just use the exception as the last argument instead.\nSee other comments for examples.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679729", "createdAt": "2020-04-03T01:00:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +174,13 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, getString(e)));\n+            logger.debug(\"{}: Exception {}\\n{}\", name, e.getClass(), e.getStackTrace());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDAwNQ==", "bodyText": "Any reason you can't use primitives instead?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680005", "createdAt": "2020-04-03T01:01:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    Integer red = 0;\n+    Integer green = 0;\n+    Integer blue = 0;\n+    Integer white = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDM4Nw==", "bodyText": "Shouldn't the null checking been handled already by the static analyzer. Why do you need to check again? Or better question: why did you make the parameter non-null?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680387", "createdAt": "2020-04-03T01:02:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -172,8 +172,9 @@ public static PercentType toPercent(Integer value) {\n         return toPercent(value, 0, SHELLY_MAX_COLOR);\n     }\n \n-    public static PercentType toPercent(@Nullable Integer _value, Integer min, Integer max) {\n+    public static PercentType toPercent(Integer _value, Integer min, Integer max) {\n         Double range = max.doubleValue() - min.doubleValue();\n+        @SuppressWarnings(\"null\")\n         Double value = _value != null ? _value.doubleValue() : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw==", "bodyText": "Was this removed intentionally?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681167", "createdAt": "2020-04-03T01:05:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -400,34 +415,25 @@ public boolean updateRelays(ShellySettingsStatus status) throws IOException {\n      * @param profile ShellyDeviceProfile\n      * @param status Last ShellySettingsStatus\n      *\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws IOException {\n-        ShellyDeviceProfile profile = getProfile();\n-\n+    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws ShellyApiException {\n         boolean updated = false;\n         if (profile.isDimmer) {\n-            Validate.notNull(orgStatus, \"orgStatus must not be null!\");\n-\n             // We need to fixup the returned Json: The dimmer returns light[] element, which is ok, but it doesn't have\n-            // the same structure as lights[] from Bulb and RGBW2. The tag gets replaced by dimmers[] so that Gson maps\n-            // to a different structure (ShellyShortLight).\n+            // the same structure as lights[] from Bulb,RGBW2 and Duo. The tag gets replaced by dimmers[] so that Gson\n+            // maps to a different structure (ShellyShortLight).\n             Gson gson = new Gson();\n             ShellySettingsStatus dstatus = gson.fromJson(ShellyApiJsonDTO.fixDimmerJson(orgStatus.json),\n                     ShellySettingsStatus.class);\n             Validate.notNull(dstatus.dimmers, \"dstatus.dimmers must not be null!\");\n-            Validate.notNull(dstatus.tmp, \"dstatus.tmp must not be null!\");\n \n             logger.trace(\"{}: Updating {}\u00a0dimmers(s)\", thingName, dstatus.dimmers.size());\n-\n             int l = 0;\n-            logger.trace(\"{}: Updating dimmers {}\", thingName, dstatus.dimmers.size());\n             for (ShellyShortLightStatus dimmer : dstatus.dimmers) {\n                 Integer r = l + 1;\n                 String groupName = profile.numRelays <= 1 ? CHANNEL_GROUP_DIMMER_CONTROL\n                         : CHANNEL_GROUP_DIMMER_CONTROL + r.toString();\n-                // updated |= updateChannel(groupName, CHANNEL_OUTPUT, getOnOff(dimmer.ison));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTc2Mg==", "bodyText": "Can these exceptions be prevented?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681762", "createdAt": "2020-04-03T01:08:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjEzOA==", "bodyText": "Why not just use put every time?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682138", "createdAt": "2020-04-03T01:09:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjI4NQ==", "bodyText": "Why bother checking if it contains? Just call remove to begin with.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682285", "createdAt": "2020-04-03T01:09:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng==", "bodyText": "All of your synchronization on this field is done only for single operations. Why not just make this a ConcurrentHashMap instead so you don't need to do synchronization around it?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682576", "createdAt": "2020-04-03T01:10:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjczNA==", "bodyText": "No need to be wasteful.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    channelData = new HashMap<>();\n          \n          \n            \n                    channelData.clear();", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682734", "createdAt": "2020-04-03T01:11:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }\n+        }\n+\n+    }\n+\n+    public void clear() {\n+        channelData = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjgxMQ==", "bodyText": "Also, you can make this field final.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682811", "createdAt": "2020-04-03T01:11:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng=="}, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzQzMQ==", "bodyText": "Static analysis should have made these validation checks redundant.\nAlso, how is channelData supposed to be null here anyhow?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683431", "createdAt": "2020-04-03T01:14:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzkxOA==", "bodyText": "Can these be made final?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683918", "createdAt": "2020-04-03T01:16:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private @Nullable Bundle bundle;\n+    private @Nullable TranslationProvider i18nProvider;\n+    private @Nullable LocaleProvider localeProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDExNg==", "bodyText": "getMessage is a more appropriate name for this method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String getString(Exception e) {\n          \n          \n            \n                public static String getMessage(Exception e) {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684116", "createdAt": "2020-04-03T01:17:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -55,6 +55,11 @@ public static String getString(@Nullable String value) {\n         return value != null ? value : \"\";\n     }\n \n+    public static String getString(Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4MQ==", "bodyText": "Should you also pass the cause exception?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684481", "createdAt": "2020-04-03T01:18:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -116,24 +121,11 @@ public static void validateRange(String name, Integer value, Integer min, Intege\n                 \"Value \" + name + \" is out of range (\" + min.toString() + \"-\" + max.toString() + \")\");\n     }\n \n-    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String deviceType, String urlParm) throws IOException {\n-        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n-                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n-    }\n-\n-    public static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String type, String parameter) throws IOException {\n-        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n-                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n-        return urlEncode(url);\n-    }\n-\n-    public static String urlEncode(String input) throws IOException {\n+    public static String urlEncode(String input) throws ShellyApiException {\n         try {\n             return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());\n         } catch (UnsupportedEncodingException e) {\n-            throw new IOException(\n+            throw new ShellyApiException(\n                     \"Unsupported encoding format: \" + StandardCharsets.UTF_8.toString() + \", input=\" + input);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDcwNA==", "bodyText": "Field and variable names should be camelcase.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684704", "createdAt": "2020-04-03T01:19:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ==", "bodyText": "I disagree with a DTO class implementing Comparator and instead it should be either a lambda, an anonymous class, or a named nested class in this DTO.\nThe best suggestion I can give to to make VersionTokenizer implement Comparable<VersionTokenizer>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402685281", "createdAt": "2020-04-03T01:21:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NjM3Mg==", "bodyText": "This fix will allow you to remove the warning suppression for this method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return version != null & (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n          \n          \n            \n                    return version != null && (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402686372", "createdAt": "2020-04-03T01:25:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            _versionString = versionString;\n+            _length = versionString.length();\n+        }\n+\n+        public boolean MoveNext() {\n+            _number = 0;\n+            _suffix = \"\";\n+\n+            // No more characters\n+            if (_position >= _length) {\n+                return false;\n+            }\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                _number = _number * 10 + (c - '0');\n+                _position++;\n+            }\n+\n+            int suffixStart = _position;\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                _position++;\n+            }\n+\n+            _suffix = _versionString.substring(suffixStart, _position);\n+\n+            if (_position < _length) {\n+                _position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        public int getNumber() {\n+            return _number;\n+        }\n+\n+        public String getSuffix() {\n+            return _suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;\n+\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.MoveNext()) {\n+            if (!tokenizer2.MoveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.MoveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.MoveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.MoveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean checkBeta(@Nullable String version) {\n+        return version != null & (version.isEmpty() || version.contains(\"???\")\n+                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4Njk2NQ==", "bodyText": "The first letter of every word in a label should be capitalized.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Battery voltage</label>\n          \n          \n            \n            \t\t<label>Battery Voltage</label>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402686965", "createdAt": "2020-04-03T01:28:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/device.xml", "diffHunk": "@@ -8,10 +8,63 @@\n \t\t<label>Device Status</label>\n \t\t<description>Some details on the device status</description>\n \t\t<channels>\n-\t\t\t<channel id=\"uptime\" typeId=\"uptime\" />\n-\t\t\t<channel id=\"wifiSignal\" typeId=\"system.signal-strength\" />\n \t\t\t<channel id=\"alarm\" typeId=\"alarmTrigger\" />\n+\t\t\t<channel id=\"wifiSignal\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"uptime\" typeId=\"uptime\" />\n \t\t</channels>\n \t</channel-group-type>\n \n+\t<channel-type id=\"alarmTrigger\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm</label>\n+\t\t<description>Alarm Trigger, e.g. weak WiFi Signal detected or over heating.</description>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NONE\">None</option>\n+\t\t\t\t<option value=\"WEAK_SIGNAL\">Weak WiFi</option>\n+\t\t\t\t<option value=\"RESTARTED\">Device restarted</option>\n+\t\t\t\t<option value=\"OVERTEMP\">Device is overheating</option>\n+\t\t\t\t<option value=\"OVERLOAD\">Device is overloaded</option>\n+\t\t\t\t<option value=\"OVERPOWER\">Device is over max power</option>\n+\t\t\t\t<option value=\"LOAD_ERROR\">Load error</option>\n+\t\t\t\t<option value=\"LOW_BATTERY\">Low battery</option>\n+\t\t\t\t<option value=\"BATTERY\">Wakeup by battery</option>\n+\t\t\t\t<option value=\"POWERON\">Device was powered on</option>\n+\t\t\t\t<option value=\"BUTTON\">Button was pressed</option>\n+\t\t\t\t<option value=\"SENSOR\">Sensor data updated</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\t<channel-type id=\"charger\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charger connected</label>\n+\t\t<description>ON: Device is charging, OFF: No charger connected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"batVoltage\" advanced=\"true\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>Battery voltage</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4Njk5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Charger connected</label>\n          \n          \n            \n            \t\t<label>Charger Connected</label>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402686993", "createdAt": "2020-04-03T01:28:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/device.xml", "diffHunk": "@@ -8,10 +8,63 @@\n \t\t<label>Device Status</label>\n \t\t<description>Some details on the device status</description>\n \t\t<channels>\n-\t\t\t<channel id=\"uptime\" typeId=\"uptime\" />\n-\t\t\t<channel id=\"wifiSignal\" typeId=\"system.signal-strength\" />\n \t\t\t<channel id=\"alarm\" typeId=\"alarmTrigger\" />\n+\t\t\t<channel id=\"wifiSignal\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"uptime\" typeId=\"uptime\" />\n \t\t</channels>\n \t</channel-group-type>\n \n+\t<channel-type id=\"alarmTrigger\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Alarm</label>\n+\t\t<description>Alarm Trigger, e.g. weak WiFi Signal detected or over heating.</description>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NONE\">None</option>\n+\t\t\t\t<option value=\"WEAK_SIGNAL\">Weak WiFi</option>\n+\t\t\t\t<option value=\"RESTARTED\">Device restarted</option>\n+\t\t\t\t<option value=\"OVERTEMP\">Device is overheating</option>\n+\t\t\t\t<option value=\"OVERLOAD\">Device is overloaded</option>\n+\t\t\t\t<option value=\"OVERPOWER\">Device is over max power</option>\n+\t\t\t\t<option value=\"LOAD_ERROR\">Load error</option>\n+\t\t\t\t<option value=\"LOW_BATTERY\">Low battery</option>\n+\t\t\t\t<option value=\"BATTERY\">Wakeup by battery</option>\n+\t\t\t\t<option value=\"POWERON\">Device was powered on</option>\n+\t\t\t\t<option value=\"BUTTON\">Button was pressed</option>\n+\t\t\t\t<option value=\"SENSOR\">Sensor data updated</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\t<channel-type id=\"charger\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charger connected</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NzU5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Wakeup reason</label>\n          \n          \n            \n            \t\t<label>Wakeup Reason</label>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402687597", "createdAt": "2020-04-03T01:30:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4Nzg1Ng==", "bodyText": "I don't think this is a valid item type.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402687856", "createdAt": "2020-04-03T01:31:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the external sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtHum\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%) from external sensor</description>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorHumidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%)</description>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%f %unit%\" />\n+\t</channel-type>\n+\t<channel-type id=\"sensorFlood\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Flood Alarm</label>\n+\t\t<description>ON: Indicates flood condition / water detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorSmoke\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Smoke Alarm</label>\n+\t\t<description>ON: Indicates smoke detection</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorLux\">\n+\t\t<item-type>Number:Illuminance</item-type>\n+\t\t<label>Lux</label>\n+\t\t<description>Brightness from the sensor (Lux)</description>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorIllumination\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Illumination</label>\n+\t\t<description>Current illumination: dark/twilight/bright</description>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"dark\">Dark</option>\n+\t\t\t\t<option value=\"twilight\">Twilight</option>\n+\t\t\t\t<option value=\"bright\">Bright</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorVibration\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Vibration</label>\n+\t\t<description>ON: Vibration detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorError\">\n+\t\t<item-type>Text</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4Nzg5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>IR Key to send</label>\n          \n          \n            \n            \t\t<label>IR Key to Send</label>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402687894", "createdAt": "2020-04-03T01:31:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the external sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtHum\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%) from external sensor</description>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorHumidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%)</description>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%f %unit%\" />\n+\t</channel-type>\n+\t<channel-type id=\"sensorFlood\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Flood Alarm</label>\n+\t\t<description>ON: Indicates flood condition / water detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorSmoke\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Smoke Alarm</label>\n+\t\t<description>ON: Indicates smoke detection</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorLux\">\n+\t\t<item-type>Number:Illuminance</item-type>\n+\t\t<label>Lux</label>\n+\t\t<description>Brightness from the sensor (Lux)</description>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorIllumination\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Illumination</label>\n+\t\t<description>Current illumination: dark/twilight/bright</description>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"dark\">Dark</option>\n+\t\t\t\t<option value=\"twilight\">Twilight</option>\n+\t\t\t\t<option value=\"bright\">Bright</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorVibration\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Vibration</label>\n+\t\t<description>ON: Vibration detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorError\">\n+\t\t<item-type>Text</item-type>\n+\t\t<label>Last Error</label>\n+\t\t<description>Only valid in case of error</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"senseKey\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>IR Key to send</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4ODUwMg==", "bodyText": "I wonder if this is more of a contact than a switch? \ud83e\udd14", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402688502", "createdAt": "2020-04-03T01:33:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the external sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtHum\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%) from external sensor</description>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorHumidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%)</description>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%f %unit%\" />\n+\t</channel-type>\n+\t<channel-type id=\"sensorFlood\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Flood Alarm</label>\n+\t\t<description>ON: Indicates flood condition / water detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorSmoke\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Smoke Alarm</label>\n+\t\t<description>ON: Indicates smoke detection</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorLux\">\n+\t\t<item-type>Number:Illuminance</item-type>\n+\t\t<label>Lux</label>\n+\t\t<description>Brightness from the sensor (Lux)</description>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorIllumination\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Illumination</label>\n+\t\t<description>Current illumination: dark/twilight/bright</description>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"dark\">Dark</option>\n+\t\t\t\t<option value=\"twilight\">Twilight</option>\n+\t\t\t\t<option value=\"bright\">Bright</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorVibration\">\n+\t\t<item-type>Switch</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4ODkyNA==", "bodyText": "I wonder if this is more of a contact than a switch? \ud83e\udd14", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402688924", "createdAt": "2020-04-03T01:35:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the external sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtHum\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%) from external sensor</description>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorHumidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%)</description>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%f %unit%\" />\n+\t</channel-type>\n+\t<channel-type id=\"sensorFlood\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Flood Alarm</label>\n+\t\t<description>ON: Indicates flood condition / water detected</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorSmoke\">\n+\t\t<item-type>Switch</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4ODk0MQ==", "bodyText": "I wonder if this is more of a contact than a switch? \ud83e\udd14", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402688941", "createdAt": "2020-04-03T01:35:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the external sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtHum\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%) from external sensor</description>\n+\t\t<category>Humidity</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorHumidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>Relative humidity in % (0..100%)</description>\n+\t\t<tags>\n+\t\t\t<tag>CurrentHumidity</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" min=\"0\" max=\"100\" pattern=\"%f %unit%\" />\n+\t</channel-type>\n+\t<channel-type id=\"sensorFlood\">\n+\t\t<item-type>Switch</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4OTE2MA==", "bodyText": "You should probably use the labels to differentiate the internal sensor temperature from the external sensor temperature.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402689160", "createdAt": "2020-04-03T01:36:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/sensor.xml", "diffHunk": "@@ -123,4 +102,121 @@\n \t\t</channels>\n \t</channel-group-type>\n \n+\n+\t<channel-type id=\"sensorState\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>State of the contact: open/close</description>\n+\t\t<category>Contact</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"OPEN\">Open</option>\n+\t\t\t\t<option value=\"CLOSED\">Closed</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorWakeup\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Wakeup reason</label>\n+\t\t<description>Reasons which woke up the device: battery, button, periodic, poweron, sensor, alarm</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"sensorTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature from the sensor</description>\n+\t\t<category>Temperature</category>\n+\t\t<tags>\n+\t\t\t<tag>CurrentTemperature</tag>\n+\t\t</tags>\n+\t\t<state readOnly=\"true\" pattern=\"%f %unit%\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"sensorExtTemp\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 143}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDczMjE3", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-388473217", "createdAt": "2020-04-06T17:37:36Z", "commit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzozNzozNlrOGBis4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1MDo1MVrOGBrPaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDMwNw==", "bodyText": "What would throw these errors? Are they preventable?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404270307", "createdAt": "2020-04-06T17:37:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,24 +152,23 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n         for (ShellyDeviceListener listener : deviceListeners) {\n             try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n+                if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n                     // event processed\n                     break;\n                 }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n+            } catch (IllegalArgumentException | NullPointerException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTI4OQ==", "bodyText": "Can you give this field a better name than e? Also can you make it final?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271289", "createdAt": "2020-04-06T17:39:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTQyNw==", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271427", "createdAt": "2020-04-06T17:39:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(ShellyApiResult res) {\n+        super(EX_NONE);\n+        apiResult = res;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty() ? \", result =\" + apiResult.response : \"\";\n+\n+        if (!isEmpty()) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n+            } else {\n+                message = getMessage();\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return e.getClass() == ShellyApiException.class;\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = !isEmpty() ? e.getClass() : null;\n+        return (apiResult.httpCode == -1)\n+                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult.isHttpAccessUnauthorized();\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return e.getClass() == MalformedURLException.class;\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return e.getClass() == UnknownHostException.class;\n+    }\n+\n+    public ShellyApiResult getApiResult() {\n+        return apiResult;\n+    }\n+\n+    private boolean isEmpty() {\n+        return nonNullString(e.getMessage()).equals(EX_NONE);\n+    }\n+\n+    private static String nonNullString(@Nullable String s) {\n+        return s != null ? s : \"\";\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzA3MQ==", "bodyText": "I only see sensor1 declared...", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404273071", "createdAt": "2020-04-06T17:42:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -612,20 +762,39 @@\n             public ShellyShortTemp sensor3;\n         }\n \n+        public static class ShellyExtHumidity {\n+            public static class ShellyShortHum {\n+                public Double hum; // Humidity reading of sensor 0, percent\n+            }\n+\n+            // Shelly 1/1PM have up to 3 sensors\n+            // for whatever reasons it's not an array, but 3 independent elements", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 488}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA==", "bodyText": "This method used to be static, which made it a factory method, which was fine. You have made it non-static yet it still produces a ShellyDeviceProfile instance. Are you trying to make this into a builder pattern? Why not just make this a constructor then?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404276294", "createdAt": "2020-04-06T17:47:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzAxNg==", "bodyText": "If all these fields are non-null, why not make the fields primitive? Boolean -> boolean, Integer -> int", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277016", "createdAt": "2020-04-06T17:48:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzgwMg==", "bodyText": "Why is this code here? This code has nothing to do with device profile, why was it moved from ShellyThingCreator?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277802", "createdAt": "2020-04-06T17:49:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDc4OQ==", "bodyText": "This method is called by a library, and as such you have no idea if or how they will handle this exception getting thrown here. Instead you should just log it and return immediately.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404280789", "createdAt": "2020-04-06T17:54:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ==", "bodyText": "The formula in your comment above doesn't match the formula you used here. Which is wrong?\nAlso, I would suggest taking advantage of the units framework conversion capabilities so you don't have to handle it yourself.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                : (status.tmp.value + 32) * 0.5556;\n          \n          \n            \n                                : Units.CELSIUS.getConverterTo(Units.FAHRENHEIT).convert(status.tmp.value);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404288161", "createdAt": "2020-04-06T18:07:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -109,84 +118,77 @@ public ShellyDeviceProfile getDeviceProfile(String thingType) throws IOException\n         return profile;\n     }\n \n+    public boolean isInitialized() {\n+        return profile.initialized;\n+    }\n+\n     /**\n      * Get generic device settings/status. Json returned from API will be mapped to a Gson object\n      *\n      * @return Device settings/status as ShellySettingsStatus object\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public ShellySettingsStatus getStatus() throws IOException {\n+    public ShellySettingsStatus getStatus() throws ShellyApiException {\n         String json = request(SHELLY_URL_STATUS);\n         ShellySettingsStatus status = gson.fromJson(json, ShellySettingsStatus.class);\n-        Validate.notNull(status);\n         status.json = json;\n         return status;\n     }\n \n-    @Nullable\n-    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString());\n-        return gson.fromJson(result, ShellyStatusRelay.class);\n+    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws ShellyApiException {\n+        return callApi(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString(), ShellyStatusRelay.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public void setRelayTurn(Integer relayIndex, String turnMode) throws IOException {\n-        Validate.notNull(profile);\n-        request((!profile.isDimmer ? SHELLY_URL_CONTROL_RELEAY : SHELLY_URL_CONTROL_LIGHT) + \"/\" + relayIndex.toString()\n-                + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n+    public void setRelayTurn(Integer id, String turnMode) throws ShellyApiException {\n+        request(getControlUrlPrefix(id) + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n     }\n \n-    public void setDimmerBrightness(Integer relayIndex, Integer brightness, boolean autoOn) throws IOException {\n-        if (autoOn) {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + SHELLY_LIGHT_TURN + \"=\"\n-                    + SHELLY_API_ON + \"&brightness=\" + brightness.toString());\n-        } else {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + \"&brightness=\"\n-                    + brightness.toString());\n-        }\n+    public void setBrightness(Integer id, Integer brightness, boolean autoOn) throws ShellyApiException {\n+        String turn = autoOn ? SHELLY_LIGHT_TURN + \"=\" + SHELLY_API_ON + \"&\" : \"\";\n+        request(getControlUrlPrefix(id) + \"?\" + turn + \"brightness=\" + brightness.toString());\n     }\n \n-    @Nullable\n-    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws IOException {\n-        String result = request(SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\");\n-        return gson.fromJson(result, ShellyControlRoller.class);\n+    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws ShellyApiException {\n+        String uri = SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\";\n+        return callApi(uri, ShellyControlRoller.class);\n     }\n \n-    public void setRollerTurn(Integer relayIndex, String turnMode) throws IOException {\n+    public void setRollerTurn(Integer relayIndex, String turnMode) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=\" + turnMode);\n     }\n \n-    public void setRollerPos(Integer relayIndex, Integer position) throws IOException {\n+    public void setRollerPos(Integer relayIndex, Integer position) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=to_pos&roller_pos=\"\n                 + position.toString());\n     }\n \n-    public void setRollerTimer(Integer relayIndex, Integer timer) throws IOException {\n+    public void setRollerTimer(Integer relayIndex, Integer timer) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?timer=\" + timer.toString());\n     }\n \n-    @Nullable\n-    public ShellyShortLightStatus getLightStatus(Integer index) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString());\n-        return gson.fromJson(result, ShellyShortLightStatus.class);\n+    public ShellyShortLightStatus getLightStatus(Integer index) throws ShellyApiException {\n+        String uri = SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString();\n+        return callApi(uri, ShellyShortLightStatus.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public ShellyStatusSensor getSensorStatus() throws IOException {\n-        Validate.notNull(profile);\n-        ShellyStatusSensor status = gson.fromJson(request(SHELLY_URL_STATUS), ShellyStatusSensor.class);\n+    public ShellyStatusSensor getSensorStatus() throws ShellyApiException {\n+        ShellyStatusSensor status = callApi(SHELLY_URL_STATUS, ShellyStatusSensor.class);\n         if (profile.isSense) {\n-            // complete reported data\n-            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value : 0;\n-            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value : 0;\n+            // complete reported data, map C to F or vice versa: C=(F - 32) * 0.5556;\n+            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value\n+                    : status.tmp.value / 0.5556 + 32;\n+            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value\n+                    : (status.tmp.value + 32) * 0.5556;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NDcyOQ==", "bodyText": "You should double check that IOUtils isn't using the system default charset, if it is using the default then you should specify it yourself here instead. The default charset can vary from system to system.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404384729", "createdAt": "2020-04-06T20:59:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n+        }\n+\n         try {\n+            path = request.getRequestURI().toLowerCase();\n+            data = IOUtils.toString(request.getInputStream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NTUyNg==", "bodyText": "Why is this a field?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404385526", "createdAt": "2020-04-06T21:01:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA==", "bodyText": "It was better when this field was named thingHandler.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404386340", "createdAt": "2020-04-06T21:02:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();\n     private final Gson gson;\n     private String thingName;\n+    private boolean discovering = false;\n \n-    private @Nullable ShellyCoapServer coapServer;\n+    private final ShellyCoapServer coapServer;\n     private @Nullable CoapClient statusClient;\n-    private @Nullable Request reqDescription;\n-    private @Nullable Request reqStatus;\n+    private Request reqDescription = new Request(Code.GET, Type.CON);;\n+    private Request reqStatus = new Request(Code.GET, Type.CON);\n \n     private int lastSerial = -1;\n+    private Double lastBrightness = -1.0;\n     private String lastPayload = \"\";\n     private Map<String, CoIotDescrBlk> blockMap = new HashMap<>();\n     private Map<String, CoIotDescrSen> sensorMap = new HashMap<>();\n \n-    public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thingHandler,\n-            @Nullable ShellyCoapServer coapServer) {\n-        Validate.notNull(coapServer);\n-        this.thingHandler = thingHandler;\n+    private static final byte[] EMPTY_BYTE = new byte[0];\n+\n+    public ShellyCoapHandler(ShellyBaseHandler th, ShellyCoapServer coapServer) {\n+        this.th = th;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODQ1Ng==", "bodyText": "I assume that sensorMap is a LinkedHashMap or an immutable map otherwise this id generation can get very inconsistent.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388456", "createdAt": "2020-04-06T21:06:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -698,48 +822,60 @@ private void resetSerial() {\n      * @param sensorId The id from the sensor update\n      * @return Index of found entry (+1 will be the suffix for the channel name) or null if sensorId is not found\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    private Integer getInputId(String sensorId) {\n-        Integer idx = 0;\n+    private int getSensorNumber(String sensorName, String sensorId) {\n+        int idx = 0;\n         for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {\n-            @Nullable\n             CoIotDescrSen sen = se.getValue();\n-            if (sen.id.equalsIgnoreCase(\"Input\")) {\n+            if (sen.desc.equalsIgnoreCase(sensorName)) {\n                 idx++; // iterate from input1..2..n\n             }\n-            if (sen.id.equalsIgnoreCase(sensorId)) {\n+            if (sen.id.equalsIgnoreCase(sensorId) && blockMap.containsKey(sen.links)) {\n                 CoIotDescrBlk blk = blockMap.get(sen.links);\n-                if ((blk != null) && StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n+                if (StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n                     idx = Integer.parseInt(StringUtils.substringAfter(blk.desc, \"Relay\"));\n                 }\n-                logger.trace(\"{}:    map to input{} channel\", thingName, idx);\n+                logger.trace(\"{}:    map sensor {}{} to index {}\", thingName, sensorName, sensorId, idx);\n+                return idx;\n+            }\n+        }\n+        logger.debug(\"{}: sensorId {} not found in sensorMap!\", thingName, sensorId);\n+        return -1;\n+    }\n+\n+    private int getExtTempId(String sensorId) {\n+        int idx = 0;\n+        for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 784}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODkxOA==", "bodyText": "No need to create an Integer instance when you don't have to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                sensor.id = new Integer(in.nextInt()).toString();\n          \n          \n            \n                                sensor.id = Integer.toString(in.nextInt());", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388918", "createdAt": "2020-04-06T21:07:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java", "diffHunk": "@@ -110,14 +120,13 @@ public CoIotGenericSensorList read(final JsonReader in) throws IOException {\n \n             in.beginObject();\n             String generic = in.nextName();\n-            Validate.notNull(generic, \"Invalid JSon format for CoIotSensorList\");\n             if (generic.equals(COIOT_TAG_GENERIC)) {\n                 in.beginArray();\n                 while (in.hasNext()) {\n                     in.beginArray();\n                     final CoIotSensor sensor = new CoIotSensor();\n                     in.nextInt(); // alway 0\n-                    sensor.index = new Integer(in.nextInt()).toString();\n+                    sensor.id = new Integer(in.nextInt()).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjIwMA==", "bodyText": "Please make a local variable out of getThing().getStatus() so you can reuse it.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396200", "createdAt": "2020-04-06T21:21:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,43 +303,38 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}:{}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    @SuppressWarnings(\"null\")\n-    protected void updateStatus() {\n+    protected void refreshStatus() {\n         try {\n             boolean updated = false;\n \n             skipUpdate++;\n-            if (lockUpdates) {\n-                logger.trace(\"{}: Update locked, try on next cycle\", thingName);\n-                return;\n-            }\n-\n-            if ((skipUpdate % refreshCount == 0) && (profile != null)\n+            if ((skipUpdate % refreshCount == 0) && (profile.isInitialized())\n                     && (getThing().getStatus() == ThingStatus.ONLINE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5Njk5Nw==", "bodyText": "This is already handled for you by the BaseThingHandler. So you don't need this method.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396997", "createdAt": "2020-04-06T21:23:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -357,93 +353,119 @@ protected void updateStatus() {\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                if (!profile.hasBattery) { // ignore Timeouts for Sensors\n+                    status = \"offline.status-error-timeout\";\n+                }\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        ThingStatus status = getThing().getStatus();\n+        return status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            setThingStatus(ThingStatus.ONLINE);\n+            requestUpdates(!profile.hasBattery ? 3 : 1, false); // request 3 updates in a row (during the first 2+3*3\n+                                                                // sec)\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (getThing().getStatus() != ThingStatus.OFFLINE) {\n+            setThingStatus(ThingStatus.OFFLINE, detail, messageKey);\n+            channelsCreated = false; // check for new channels after devices gets re-initialized (e.g. new\n+        }\n+    }\n \n+    public void setThingStatus(ThingStatus newStatus) {\n+        if (getThing().getStatus() != newStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 520}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTgyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;\n          \n          \n            \n                        int rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404399827", "createdAt": "2020-04-06T21:28:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -482,22 +503,30 @@ public void postAlarm(String alarm, boolean force) {\n      * @param data the HTML input data\n      * @return true if event was processed\n      */\n-    @SuppressWarnings({ \"null\" })\n     @Override\n-    public boolean onEvent(String deviceName, String deviceIndex, String type, Map<String, String> parameters) {\n-        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(deviceName)) {\n+    public boolean onEvent(String ipAddress, String deviceName, String deviceIndex, String type,\n+            Map<String, @Nullable String> parameters) {\n+        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(ipAddress)) {\n             logger.debug(\"{}: Event received: class={}, index={}, parameters={}\", deviceName, type, deviceIndex,\n                     parameters.toString());\n-            boolean hasBattery = profile != null && profile.hasBattery ? true : false;\n-            if (profile == null) {\n+            Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 630}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjk2Nw==", "bodyText": "All of these fields should be final and moved to the top of this class.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404402967", "createdAt": "2020-04-06T21:35:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public ShellyChannelDefinitionsDTO(ShellyTranslationProvider m) {\n+        // Device: Internal Temp\n+        channelDefinitions\n+                // Device\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP, \"deviceTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP, \"sensorWakeup\",\n+                        ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS, \"meterAccuWatts\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL, \"meterAccuTotal\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCURETURNED, \"meterAccuReturned\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER, \"charger\", ITEM_TYPE_SWITCH))\n+\n+                // Power Meter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_CURRENTWATTS, \"meterWatts\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_TOTALKWH, \"meterTotal\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN1, \"lastPower1\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN2, \"lastPower2\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN3, \"lastPower3\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // EMeter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_TOTALRET, \"meterReturned\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_REACTWATTS, \"meterReactive\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_VOLTAGE, \"meterVoltage\", ITEM_TYPE_VOLT))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_CURRENT, \"meterCurrent\", ITEM_TYPE_AMP))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_PFACTOR, \"meterPowerFactor\", ITEM_TYPE_NUMBER))\n+\n+                // Sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TEMP, \"sensorTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_HUM, \"sensorHumidity\", ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_LUX, \"sensorLux\", ITEM_TYPE_LUX))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ILLUM, \"sensorIllumination\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_VIBRATION, \"sensorVibration\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_FLOOD, \"sensorFlood\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_SMOKE, \"sensorSmoke\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_STATE, \"sensorState\", ITEM_TYPE_CONTACT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_MOTION, \"sensorMotion\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ERROR, \"sensorError\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // Addon with external sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY, \"sensorExtHum\", ITEM_TYPE_PERCENT))\n+\n+                // Battery\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LEVEL, \"system:battery-level\",\n+                        ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LOW, \"system:low-battery\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_VOLT, \"batVoltage\", ITEM_TYPE_VOLT))\n+\n+        ;\n+    }\n+\n+    public static ShellyChannel getDefinition(String channelName) throws IllegalArgumentException {\n+        String group = StringUtils.substringBefore(channelName, \"#\");\n+        String channel = StringUtils.substringAfter(channelName, \"#\");\n+        if (group.contains(CHANNEL_GROUP_METER)) {\n+            group = CHANNEL_GROUP_METER; // map meter1..n to meter\n+        } else if (group.contains(CHANNEL_GROUP_RELAY_CONTROL)) {\n+            group = CHANNEL_GROUP_RELAY_CONTROL; // map meter1..n to meter\n+        }\n+        String channelId = group + \"#\" + channel;\n+        return channelDefinitions.get(channelId);\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createDeviceChannels(final Thing thing, final ShellyDeviceProfile profile,\n+            final ShellySettingsStatus status) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+        if (!profile.isSensor) {\n+            // Only some devices report the internal device temp\n+            addChannel(thing, add, (status.tmp != null) || (status.temperature != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ITEMP);\n+\n+            // If device has more than 1 meter the channel accumulatedWatts receives the accumulated value\n+            boolean accuChannel = (((status.meters != null) && (status.meters.size() > 1) && (status.rollers == null))\n+                    || ((status.emeters != null && status.emeters.size() > 1)));\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS);\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL);\n+            addChannel(thing, add, accuChannel && (status.emeters != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ACCURETURNED);\n+        }\n+        return add;\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createRelayChannels(final Thing thing, final ShellyStatusRelay relays) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // Shelly 1/1PM Addon\n+        if (relays.extTemperature != null) {\n+            addChannel(thing, add, relays.extTemperature.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1);\n+            addChannel(thing, add, relays.extTemperature.sensor2 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2);\n+            addChannel(thing, add, relays.extTemperature.sensor3 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3);\n+        }\n+        if (relays.extHumidity != null) {\n+            addChannel(thing, add, relays.extHumidity.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY);\n+        }\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createRollerChannels(Thing thing, final ShellyControlRoller roller) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // No dynamic channels so far, maybe added in the future\n+\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createMeterChannels(Thing thing, final ShellySettingsMeter meter, String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, meter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, meter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        if (meter.counters != null) {\n+            addChannel(thing, newChannels, meter.counters[0] != null, group, CHANNEL_METER_LASTMIN1);\n+            addChannel(thing, newChannels, meter.counters[1] != null, group, CHANNEL_METER_LASTMIN2);\n+            addChannel(thing, newChannels, meter.counters[2] != null, group, CHANNEL_METER_LASTMIN3);\n+        }\n+        addChannel(thing, newChannels, meter.timestamp != null, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createEMeterChannels(final Thing thing, final ShellySettingsEMeter emeter,\n+            String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, emeter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, emeter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        addChannel(thing, newChannels, emeter.totalReturned != null, group, CHANNEL_EMETER_TOTALRET);\n+        addChannel(thing, newChannels, emeter.reactive != null, group, CHANNEL_EMETER_REACTWATTS);\n+        addChannel(thing, newChannels, emeter.voltage != null, group, CHANNEL_EMETER_VOLTAGE);\n+        addChannel(thing, newChannels, emeter.current != null, group, CHANNEL_EMETER_CURRENT);\n+        addChannel(thing, newChannels, emeter.pf != null, group, CHANNEL_EMETER_PFACTOR);\n+        addChannel(thing, newChannels, true, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createSensorChannels(final Thing thing, final ShellyStatusSensor sdata) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        // Sensor data\n+        addChannel(thing, newChannels, sdata.tmp != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP);\n+        addChannel(thing, newChannels, sdata.hum != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM);\n+        addChannel(thing, newChannels, sdata.lux != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_LUX);\n+        addChannel(thing, newChannels, sdata.accel != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_VIBRATION);\n+        addChannel(thing, newChannels, sdata.flood != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.smoke != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.lux != null && sdata.lux.illumination != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_ILLUM);\n+        addChannel(thing, newChannels, sdata.contact != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_STATE);\n+        addChannel(thing, newChannels, sdata.motion != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_MOTION);\n+        addChannel(thing, newChannels, sdata.charger != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER);\n+        addChannel(thing, newChannels, sdata.sensorError != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_ERROR);\n+        addChannel(thing, newChannels, true, CHANNEL_GROUP_SENSOR, CHANNEL_LAST_UPDATE);\n+        addChannel(thing, newChannels, sdata.actReasons != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP);\n+\n+        // Battery\n+        if (sdata.bat != null) {\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL);\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LOW);\n+            addChannel(thing, newChannels, sdata.bat.voltage != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_VOLT);\n+        }\n+        return newChannels;\n+    }\n+\n+    private static void addChannel(Thing thing, Map<String, Channel> newChannels, boolean supported, String group,\n+            String channelName) throws IllegalArgumentException {\n+        if (supported) {\n+            final String channelId = group + \"#\" + channelName;\n+            final ShellyChannel channelDef = getDefinition(channelId);\n+            final ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            final ChannelTypeUID channelTypeUID = channelDef.typeId.contains(\"system:\")\n+                    ? new ChannelTypeUID(channelDef.typeId)\n+                    : new ChannelTypeUID(BINDING_ID, channelDef.typeId);\n+\n+            // Channel channel = ChannelBuilder.create(channelUID, channelId).withType(channelTypeUID)\n+            // .withLabel(channelDef.label).withDescription(channelDef.description).build();\n+            Channel channel = ChannelBuilder.create(channelUID, channelDef.itemType).withType(channelTypeUID).build();\n+            newChannels.put(channelId, channel);\n+        }\n+    }\n+\n+    public static String ITEM_TYPE_NUMBER = \"Number\";\n+    public static String ITEM_TYPE_STRING = \"String\";\n+    public static String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMzI4Mw==", "bodyText": "Why are all these fields package private?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404403283", "createdAt": "2020-04-06T21:35:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    int red = 0;\n+    int green = 0;\n+    int blue = 0;\n+    int white = 0;\n+    PercentType percentRed = new PercentType(0);\n+    PercentType percentGreen = new PercentType(0);\n+    PercentType percentBlue = new PercentType(0);\n+    PercentType percentWhite = new PercentType(0);\n+\n+    int gain = 0;\n+    int brightness = 0;\n+    int temp = 0;\n+    int minTemp = 0;\n+    int maxTemp = 0;\n+    PercentType percentGain = new PercentType(0);\n+    PercentType percentBrightness = new PercentType(0);\n+    PercentType percentTemp = new PercentType(0);\n+    Integer effect = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n          \n          \n            \n                        api.setRelayTurn(index, command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404405900", "createdAt": "2020-04-06T21:41:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -174,7 +164,7 @@ private void handleBrightness(Command command, Integer index) throws IOException\n         if (command instanceof OnOffType) { // Switch\n             logger.debug(\"Switch output {}\", command.toString());\n             api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA==", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404406960", "createdAt": "2020-04-06T21:43:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private final Bundle bundle;\n+    private final TranslationProvider i18nProvider;\n+    private final LocaleProvider localeProvider;\n+\n+    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n+        this.bundle = bundle;\n+        this.i18nProvider = i18nProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n+        this.bundle = other.bundle;\n+        this.i18nProvider = other.i18nProvider;\n+        this.localeProvider = other.localeProvider;\n+    }\n+\n+    public @Nullable String get(String key, @Nullable Object... arguments) {\n+        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n+    }\n+\n+    public @Nullable String getText(String key, @Nullable Object... arguments) {\n+        Locale locale = localeProvider.getLocale();\n+        return i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments);\n+    }\n+\n+    public @Nullable String getDefaultText(String key) {\n+        return i18nProvider.getText(bundle, key, key, Locale.ENGLISH);\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwOTU5OA==", "bodyText": "The first letter of every word in a label should be capitalized.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Roller stop reason</label>\n          \n          \n            \n            \t\t<label>Roller Stop Reason</label>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404409598", "createdAt": "2020-04-06T21:49:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/relay.xml", "diffHunk": "@@ -284,4 +262,217 @@\n \t\t\t<channel id=\"powerLed\" typeId=\"ledPowerDisable\" />\n \t\t</channels>\n \t</channel-group-type>\n+\t<channel-group-type id=\"externalSensors\">\n+\t\t<label>External Sensors</label>\n+\t\t<description>Temperatures from external sensors connected to the optional Addon</description>\n+\t</channel-group-type>\n+\t<channel-type id=\"timerAutoOn\" advanced=\"true\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Auto-ON Timer</label>\n+\t\t<description>ON: After the output was turned off it turns on automatically after xx seconds; 0 disables the timer</description>\n+\t\t<state min=\"0\" step=\"1\" pattern=\"%d %unit%\" readOnly=\"false\"></state>\n+\t</channel-type>\n+\t<channel-type id=\"timerAutoOff\" advanced=\"true\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Auto-OFF Timer</label>\n+\t\t<description>ON: After the output was turned on it turns off automatically after xx seconds; 0 disables the timer</description>\n+\t\t<state min=\"0\" step=\"1\" pattern=\"%d %unit%\" readOnly=\"false\"></state>\n+\t</channel-type>\n+\t<channel-type id=\"timerActive\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Auto ON/OFF timer active</label>\n+\t\t<description>ON: A timer is active, OFF: no timer active</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"rollerShutter\">\n+\t\t<item-type>Rollershutter</item-type>\n+\t\t<label>Roller Control (0=open, 100=closed))</label>\n+\t\t<description>Controls the roller</description>\n+\t\t<category>Blinds</category>\n+\t</channel-type>\n+\t<channel-type id=\"rollerPosition\" advanced=\"true\">\n+\t\t<item-type>Dimmer</item-type>\n+\t\t<label>Roller Position (100=open, 0=closed)</label>\n+\t\t<description>Position the roller (100..0 in %, where 100%=open, 0%=closed)</description>\n+\t\t<state readOnly=\"false\" min=\"0\" max=\"100\" />\n+\t</channel-type>\n+\t<channel-type id=\"rollerStop\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Roller stop reason</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMDIxNw==", "bodyText": "Why are rollerPosition and rollerShutter two different channels?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404410217", "createdAt": "2020-04-06T21:50:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/thing/relay.xml", "diffHunk": "@@ -284,4 +262,217 @@\n \t\t\t<channel id=\"powerLed\" typeId=\"ledPowerDisable\" />\n \t\t</channels>\n \t</channel-group-type>\n+\t<channel-group-type id=\"externalSensors\">\n+\t\t<label>External Sensors</label>\n+\t\t<description>Temperatures from external sensors connected to the optional Addon</description>\n+\t</channel-group-type>\n+\t<channel-type id=\"timerAutoOn\" advanced=\"true\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Auto-ON Timer</label>\n+\t\t<description>ON: After the output was turned off it turns on automatically after xx seconds; 0 disables the timer</description>\n+\t\t<state min=\"0\" step=\"1\" pattern=\"%d %unit%\" readOnly=\"false\"></state>\n+\t</channel-type>\n+\t<channel-type id=\"timerAutoOff\" advanced=\"true\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Auto-OFF Timer</label>\n+\t\t<description>ON: After the output was turned on it turns off automatically after xx seconds; 0 disables the timer</description>\n+\t\t<state min=\"0\" step=\"1\" pattern=\"%d %unit%\" readOnly=\"false\"></state>\n+\t</channel-type>\n+\t<channel-type id=\"timerActive\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Auto ON/OFF timer active</label>\n+\t\t<description>ON: A timer is active, OFF: no timer active</description>\n+\t\t<state readOnly=\"true\">\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"rollerShutter\">\n+\t\t<item-type>Rollershutter</item-type>\n+\t\t<label>Roller Control (0=open, 100=closed))</label>\n+\t\t<description>Controls the roller</description>\n+\t\t<category>Blinds</category>\n+\t</channel-type>\n+\t<channel-type id=\"rollerPosition\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNTczODQ2", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-391573846", "createdAt": "2020-04-10T17:49:24Z", "commit": {"oid": "051f5eb2df1b08fed2ca04f6a2532ed74857829c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzo0OToyNVrOGEBSxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNzo0OToyNVrOGEBSxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2ODY3OA==", "bodyText": "What happened to this version?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406868678", "createdAt": "2020-04-10T17:49:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java", "diffHunk": "@@ -250,9 +250,8 @@\n     public static final String CHANNEL_BUTTON_TRIGGER = \"button\";\n \n     public static final String SERVICE_TYPE = \"_http._tcp.local.\";\n-    public static final String SHELLY_API_MIN_FWVERSION = \"v1.5.7\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_STD = \"v1.6\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_SENSOR = \"v1.7\";// v1.5.2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "051f5eb2df1b08fed2ca04f6a2532ed74857829c"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODIwNTQy", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-391820542", "createdAt": "2020-04-12T04:26:29Z", "commit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwNDoyNjozMFrOGESGTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwNTo0NDozMVrOGESdNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDAxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),\n          \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent, value,", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144012", "createdAt": "2020-04-12T04:26:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -513,8 +513,8 @@ private Integer getColorFromHSB(PercentType colorPercent) {\n \n     private Integer getColorFromHSB(PercentType colorPercent, Double factor) {\n         Double value = new Double(Math.round(colorPercent.doubleValue() * factor));\n-        logger.trace(\"convert {}% into {}/{} (factor={})\", colorPercent.toString(), value.toString(), value.intValue(),\n-                factor.toString());\n+        logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDU0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            |sensors   |temperature1 |Number   |yes      |Temperature value of external sensor #1 (if connected to to temp/hum addon)      |\n          \n          \n            \n            |sensors   |temperature1 |Number   |yes      |Temperature value of external sensor #1 (if connected to temp/hum addon)      |\n          \n      \n    \n    \n  \n\nThere a lot of other places with this typo.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144548", "createdAt": "2020-04-12T04:34:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -129,9 +183,10 @@ end\n |----------|-------------|---------|---------|---------------------------------------------------------------------------------|\n |relay     |output       |Switch   |r/w      |Controls the relay's output channel (on/off)                                     |\n |          |input        |Switch   |yes      |ON: Input/Button is powered, see General Notes on Channels                       |\n-|sensors   |temperature1 |Number   |yes      |Temperature value of external sensor #1 (if connected to device)                 |\n-|          |temperature2 |Number   |yes      |Temperature value of external sensor #2 (if connected to device)                 |\n-|          |temperature3 |Number   |yes      |Temperature value of external sensor #3 (if connected to device)                 |\n+|sensors   |temperature1 |Number   |yes      |Temperature value of external sensor #1 (if connected to to temp/hum addon)      |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDYxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            |          |totalKWH     |Number   |yes      |Total energy consumption in Watts since the device powered up (reset on restart) |\n          \n          \n            \n            |          |totalKWH     |Number   |yes      |Total energy consumption in Watts since the device powered up (resets on restart) |", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144618", "createdAt": "2020-04-12T04:35:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -308,11 +395,30 @@ The Shelly 4Pro provides 4 relays and 4 power meters.\n |          |temperature  |Number   |r/w      |color temperature (K): 0..100% or 3000..6500                           |\n |          |brightness   |Dimmer   |         |Brightness: 0..100% or 0..100                                          |\n  \n-### Shelly RGBW2 in Color Mode (thing-type: shellyrgbw2-color)\n+#### Shelly Duo (thing-type: shellybulbduo)\n+\n+|Group     |Channel      |Type     |read-only|Description                                                            |\n+|----------|-------------|---------|---------|-----------------------------------------------------------------------|\n+|control   |power        |Switch   |r/w      |Switch light ON/OFF                                                    |\n+|          |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF; in sec            |\n+|          |autoOff      |Number   |r/w      |Sets a  timer to turn the device OFF after every ON: in sec            |\n+|          |timerActive  |Switch   |yes      |ON: An auto-on/off timer is active                                     |\n+|white     |             |         |         |Color settings: only valid in WHITE mode                               |\n+|          |temperature  |Number   |r/w      |color temperature (K): 0..100% or 2700..6500                           |\n+|          |brightness   |Dimmer   |         |Brightness: 0..100% or 0..100                                          |\n+|meter     |currentWatts |Number   |yes      |Current power consumption in Watts                                               |\n+|          |lastPower1   |Number   |yes      |Energy consumption in Watts for a round minute, 1 minute  ago                    |\n+|          |lastPower2   |Number   |yes      |Energy consumption in Watts for a round minute, 2 minutes ago                    |\n+|          |lastPower3   |Number   |yes      |Energy consumption in Watts for a round minute, 3 minutes ago                    |\n+|          |totalKWH     |Number   |yes      |Total energy consumption in Watts since the device powered up (reset on restart) |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDk5OA==", "bodyText": "This won't actually break out early from the loop since you are using a lambda, you need to put this in a proper loop.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144998", "createdAt": "2020-04-12T04:40:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTAxNA==", "bodyText": "needed?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145014", "createdAt": "2020-04-12T04:40:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;\n             }\n-        }\n+        });\n     }\n \n-    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n+\n+    public void dispose() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA==", "bodyText": "Actually now that I think of it, why do you need this field anyway? Can't you just call getCause instead?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145278", "createdAt": "2020-04-12T04:44:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception exception = new Exception(EX_NONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTM0OA==", "bodyText": "Just to be consistent\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public static final String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_CLOSE = \"close\";", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145348", "createdAt": "2020-04-12T04:45:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -22,15 +22,166 @@\n  * @author Markus Michels - Initial contribution\n  */\n public class ShellyApiJsonDTO {\n+    public static final String SHELLY_NULL_URL = \"null\";\n+    public static final String SHELLY_URL_DEVINFO = \"/shelly\";\n+    public static final String SHELLY_URL_STATUS = \"/status\";\n+    public static final String SHELLY_URL_SETTINGS = \"/settings\";\n+    public static final String SHELLY_URL_SETTINGS_AP = \"/settings/ap\";\n+    public static final String SHELLY_URL_SETTINGS_STA = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_LOGIN = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_CLOUD = \"/settings/cloud\";\n+    public static final String SHELLY_URL_LIST_IR = \"/ir/list\";\n+    public static final String SHELLY_URL_SEND_IR = \"/ir/emit\";\n+\n+    public static final String SHELLY_URL_SETTINGS_RELAY = \"/settings/relay\";\n+    public static final String SHELLY_URL_STATUS_RELEAY = \"/status/relay\";\n+    public static final String SHELLY_URL_CONTROL_RELEAY = \"/relay\";\n+\n+    public static final String SHELLY_URL_SETTINGS_EMETER = \"/settings/emeter\";\n+    public static final String SHELLY_URL_STATUS_EMETER = \"/emeter\";\n+    public static final String SHELLY_URL_DATA_EMETER = \"/emeter/{0}/em_data.csv\";\n+\n+    public static final String SHELLY_URL_CONTROL_ROLLER = \"/roller\";\n+    public static final String SHELLY_URL_SETTINGS_ROLLER = \"/settings/roller\";\n+\n+    public static final String SHELLY_URL_SETTINGS_LIGHT = \"/settings/light\";\n+    public static final String SHELLY_URL_STATUS_LIGHT = \"/light\";\n+    public static final String SHELLY_URL_CONTROL_LIGHT = \"/light\";\n+\n+    public static final String SHELLY_URL_SETTINGS_DIMMER = \"/settings/light\";\n+\n+    //\n+    // Action URLs according to the device type\n+    //\n+    public static final String SHELLY_EVENTURL_SUFFIX = \"_url\";\n+\n+    // Relay\n+    public static final String SHELLY_EVENT_BTN_ON = \"btn_on\";\n+    public static final String SHELLY_EVENT_BTN_OFF = \"btn_off\";\n+    public static final String SHELLY_EVENT_OUT_ON = \"out_on\";\n+    public static final String SHELLY_EVENT_OUT_OFF = \"out_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH = \"shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH = \"longpush\";\n+\n+    // Dimmer\n+    public static final String SHELLY_EVENT_BTN1_ON = \"btn1_on\";\n+    public static final String SHELLY_EVENT_BTN1_OFF = \"btn1_off\";\n+    public static final String SHELLY_EVENT_BTN2_ON = \"btn2_on\";\n+    public static final String SHELLY_EVENT_BTN2_OFF = \"btn2_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH1 = \"btn1_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH1 = \"btn1_longpush\";\n+    public static final String SHELLY_EVENT_SHORTPUSH2 = \"btn2_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH2 = \"btn2_longpush\";\n+\n+    // Roller\n+    public static final String SHELLY_EVENT_ROLLER_OPEN = \"roller_open\";\n+    public static final String SHELLY_EVENT_ROLLER_CLOSE = \"roller_close\";\n+    public static final String SHELLY_EVENT_ROLLER_STOP = \"roller_stop\";\n+\n+    // Sensors\n+    public static final String SHELLY_EVENT_SENSORREPORT = \"report\";\n+    public static final String SHELLY_EVENT_DARK = \"dark\";\n+    public static final String SHELLY_EVENT_TWILIGHT = \"twilight\";\n+    public static final String SHELLY_EVENT_FLOOD_DETECTED = \"flood_detected\";\n+    public static final String SHELLY_EVENT_FLOOD_GONE = \"flood_gone\";\n+\n+    //\n+    // API values\n+    //\n+    public static final String SHELLY_BTNT_MOMENTARY = \"momentary\";\n+    public static final String SHELLY_BTNT_TOGGLE = \"toggle\";\n+    public static final String SHELLY_BTNT_EDGE = \"edge\";\n+    public static final String SHELLY_BTNT_DETACHED = \"detached\";\n+    public static final String SHELLY_STATE_LAST = \"last\";\n+    public static final String SHELLY_STATE_STOP = \"stop\";\n+    public static final String SHELLY_INP_MODE_OPENCLOSE = \"openclose\";\n+    public static final String SHELLY_OBSTMODE_DISABLED = \"disabled\";\n+    public static final String SHELLY_SAFETYM_WHILEOPENING = \"while_opening\";\n+    public static final String SHELLY_ALWD_TRIGGER_NONE = \"none\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_OPEN = \"open\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_CLOSE = \"close\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_STOP = \"stop\";\n+\n+    // API Error Codes\n+    public static final String SHELLY_APIERR_UNAUTHORIZED = \"Unauthorized\";\n+    public static final String SHELLY_APIERR_TIMEOUT = \"Timeout\";\n+    public static final String SHELLY_APIERR_NOT_CALIBRATED = \"Not calibrated!\";\n+\n+    // API device types / properties\n+    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n \n     public static final String SHELLY_API_ON = \"on\";\n     public static final String SHELLY_API_OFF = \"off\";\n     public static final String SHELLY_API_TRUE = \"true\";\n     public static final String SHELLY_API_FALSE = \"false\";\n \n-    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n-    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n-    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n+    public static final String SHELLY_API_MODE = \"mode\";\n+    public static final String SHELLY_MODE_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_MODE_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_MODE_COLOR = \"color\"; // Bulb/RGBW2: color mode\n+    public static final String SHELLY_MODE_WHITE = \"white\"; // Bulb/RGBW2: white mode\n+\n+    public static final String SHELLY_LED_STATUS_DISABLE = \"led_status_disable\";\n+    public static final String SHELLY_LED_POWER_DISABLE = \"led_power_disable\";\n+\n+    public static final String SHELLY_API_STOPR_NORMAL = \"normal\";\n+    public static final String SHELLY_API_STOPR_SAFETYSW = \"safety_switch\";\n+    public static final String SHELLY_API_STOPR_OBSTACLE = \"obstacle\";\n+\n+    public static final String SHELLY_TIMER_AUTOON = \"auto_on\";\n+    public static final String SHELLY_TIMER_AUTOOFF = \"auto_off\";\n+    public static final String SHELLY_TIMER_ACTIVE = \"has_timer\";\n+\n+    public static final String SHELLY_LIGHT_TURN = \"turn\";\n+    public static final String SHELLY_LIGHT_DEFSTATE = \"def_state\";\n+    public static final String SHELLY_LIGHTTIMER = \"timer\";\n+\n+    public static final String SHELLY_COLOR_RED = \"red\";\n+    public static final String SHELLY_COLOR_BLUE = \"blue\";\n+    public static final String SHELLY_COLOR_GREEN = \"green\";\n+    public static final String SHELLY_COLOR_YELLOW = \"yellow\";\n+    public static final String SHELLY_COLOR_WHITE = \"white\";\n+    public static final String SHELLY_COLOR_GAIN = \"gain\";\n+    public static final String SHELLY_COLOR_BRIGHTNESS = \"brightness\";\n+    public static final String SHELLY_COLOR_TEMP = \"temp\";\n+    public static final String SHELLY_COLOR_EFFECT = \"effect\";\n+\n+    public static final int SHELLY_MIN_ROLLER_POS = 0;\n+    public static final int SHELLY_MAX_ROLLER_POS = 100;\n+    public static final int SHELLY_MIN_BRIGHTNESS = 0;\n+    public static final int SHELLY_MAX_BRIGHTNESS = 100;\n+    public static final int SHELLY_MIN_GAIN = 0;\n+    public static final int SHELLY_MAX_GAIN = 100;\n+    public static final int SHELLY_MIN_COLOR = 0;\n+    public static final int SHELLY_MAX_COLOR = 255;\n+    public static final int SHELLY_DIM_STEPSIZE = 10;\n+\n+    // color temperature: 3000 = warm, 4750 = white, 6565 = cold; gain: 0..100\n+    public static final int MIN_COLOR_TEMP_BULB = 3000;\n+    public static final int MAX_COLOR_TEMP_BULB = 6500;\n+    public static final int MIN_COLOR_TEMP_DUO = 2700;\n+    public static final int MAX_COLOR_TEMP_DUO = 6500;\n+    public static final int COLOR_TEMP_RANGE_BULB = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final int COLOR_TEMP_RANGE_DUO = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final double MIN_BRIGHTNESS = 0.0;\n+    public static final double MAX_BRIGHTNESS = 100.0;\n+    public static final double SATURATION_FACTOR = 2.55;\n+    public static final double GAIN_FACTOR = SHELLY_MAX_GAIN / 100;\n+    public static final double BRIGHTNESS_FACTOR = SHELLY_MAX_BRIGHTNESS / 100;\n+\n+    // Door/Window\n+    public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n+    public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n+    public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n+    public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n+    public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTgyNQ==", "bodyText": "You said you moved it to ShellyThingCreator but the code is still here...", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145825", "createdAt": "2020-04-12T04:50:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -54,104 +60,216 @@\n     public String fwVersion = \"\";\n     public String fwDate = \"\";\n \n-    public Boolean hasRelays = false; // true if it has at least 1 power meter\n-    public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n-    public Boolean isRoller = false; // true for Shelly2 in roller mode\n-    public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-\n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n-    public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n-\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n-    public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public boolean hasRelays = false; // true if it has at least 1 power meter\n+    public int numRelays = 0; // number of relays/outputs\n+    public int numRollers = 0; // number of Rollers, usually 1\n+    public boolean isRoller = false; // true for Shelly2 in roller mode\n+    public boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+    public int numMeters = 0;\n+    public boolean isEMeter = false; // true for ShellyEM/EM3\n+\n+    public boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n+    public boolean isBulb = false; // true only if it is a Bulb\n+    public boolean isDuo = false; // true only if it is a Duo\n+    public boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public boolean hasLed = false; // true if battery device\n+\n+    public boolean isSensor = false; // true for HT & Smoke\n+    public boolean hasBattery = false; // true if battery device\n+    public boolean isSense = false; // true if thing is a Shelly Sense\n+    public boolean isDW = false; // true of Door Window sensor\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public int minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public int maxTemp = 0; // Bulb/Duo: Max Light Temp\n+\n+    public int updatePeriod = -1;\n+\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\") ? settings.sleepMode.period * 60 // minutes\n+                    : settings.sleepMode.period * 3600; // hours\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+        } else {\n+            updatePeriod = 2 * 15 + 5; // Default acc. CoIoT Spec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA==", "bodyText": "You said you removed this...", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145928", "createdAt": "2020-04-12T04:52:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjEyNA==", "bodyText": "Can you make this final?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146124", "createdAt": "2020-04-12T04:54:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -53,51 +59,58 @@\n  */\n @NonNullByDefault\n public class ShellyHttpApi {\n+    public static final String HTTP_HEADER_AUTH = \"Authorization\";\n+    public static final String HTTP_AUTH_TYPE_BASIC = \"Basic\";\n+    public static final String CONTENT_TYPE_XML = \"text/xml; charset=UTF-8\";\n+    public static final String CONTENT_TYPE_JSON = \"application/json\";\n+\n     private final Logger logger = LoggerFactory.getLogger(ShellyHttpApi.class);\n-    private final ShellyThingConfiguration config;\n-    private final String thingName = \"\";\n+    private HttpClient httpClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjI2OQ==", "bodyText": "So you never retry battery devices?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146269", "createdAt": "2020-04-12T04:56:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 639}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjQ4Nw==", "bodyText": "Since you don't need regex here you can use replace instead of replaceAll.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n          \n          \n            \n                        String response = contentResponse.getContentAsString().replace(\"\\t\", \"\").replace(\"\\r\\n\", \"\").trim();", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146487", "createdAt": "2020-04-12T04:59:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 703}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjU1Mg==", "bodyText": "You should specify a charset.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146552", "createdAt": "2020-04-12T05:00:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 695}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjYwMg==", "bodyText": "toString is called automatically\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    uri = uri + \"/\" + id.toString();\n          \n          \n            \n                    uri = uri + \"/\" + id;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146602", "createdAt": "2020-04-12T05:01:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n+        return apiResult;\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    public String getControlUrlPrefix(Integer id) {\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n+        }\n+        uri = uri + \"/\" + id.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 735}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzAzNA==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147034", "createdAt": "2020-04-12T05:07:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -371,8 +363,39 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\":\n+                                if ((profile.settings.temperatureUnits != null)\n+                                        && profile.settings.temperatureUnits.equalsIgnoreCase(\"F\")) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzEwNg==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147106", "createdAt": "2020-04-12T05:08:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -474,47 +538,46 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_GAIN,\n                                         ShellyColorUtils.toPercent((int) s.value, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n                                 break;\n-                            case \"temp\":\n-                                updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_TEMP, ShellyColorUtils\n-                                        .toPercent((int) s.value, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE));\n-\n+                            case \"temp\": // Shelly Bulb\n+                            case \"colortemperature\": // Shelly Duo\n+                                updateChannel(updates,\n+                                        profile.inColor ? CHANNEL_GROUP_COLOR_CONTROL : CHANNEL_GROUP_WHITE_CONTROL,\n+                                        CHANNEL_COLOR_TEMP,\n+                                        ShellyColorUtils.toPercent((int) s.value, profile.minTemp, profile.maxTemp));\n                                 break;\n-\n                             default:\n                                 logger.debug(\"{}: Update for unknown sensor type {}/{} received\", thingName, sen.type,\n                                         sen.desc);\n                         }\n                         break;\n-\n                     default:\n                         logger.debug(\"{}: Sensor data for type {} not processed, value={}\", thingName, sen.type,\n                                 s.value);\n-                        break;\n                 }\n-            } else {\n-                logger.debug(\"{}: Update for unknown sensor[{}]: Dev={}, Index={}, Value={}\", thingName, i, devId,\n-                        s.index, s.value);\n+            } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n+                // even the processing of one value failed we continue with the next one (sometimes this is caused by\n+                // buggy formats provided by the device\n+                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n             }\n         }\n \n         if (!updates.isEmpty()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 565}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzU1Nw==", "bodyText": "This log is a bit funky", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147557", "createdAt": "2020-04-12T05:14:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzYxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147613", "createdAt": "2020-04-12T05:15:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ==", "bodyText": "info?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147641", "createdAt": "2020-04-12T05:15:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzcwNg==", "bodyText": "info?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147706", "createdAt": "2020-04-12T05:16:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147748", "createdAt": "2020-04-12T05:16:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +187,14 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n+                                                                                    // buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n+            logger.debug(\"{}: Exception {}\", name, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzgzNw==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147837", "createdAt": "2020-04-12T05:18:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java", "diffHunk": "@@ -16,19 +16,16 @@\n import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n \n import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.thing.ThingTypeUID;\n import org.eclipse.smarthome.core.thing.ThingUID;\n \n /**\n- * The {@link ShellyThingCreator} implements some helper functions for Thing creation (used by Discovery and Thing\n- * handler).\n+ * The {@link ShellyThingCreator} maps the device id into the thing type id\n  *\n  * @author Markus Michels - Initial contribution\n  */\n-@NonNullByDefault\n-public class ShellyThingCreator {\n \n+public class ShellyThingCreator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzkyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean autoCoIoT = false;\n          \n          \n            \n                private boolean autoCoIoT = false;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147929", "createdAt": "2020-04-12T05:18:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODUwMA==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148500", "createdAt": "2020-04-12T05:27:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -517,55 +532,65 @@ public boolean onEvent(String deviceName, String deviceIndex, String type, Map<S\n \n                 // map some of the events to system defined button triggers\n                 String channel = \"\";\n+                String onoff = \"\";\n                 String payload = \"\";\n-                String event = type.contentEquals(EVENT_TYPE_SENSORDATA) ? SHELLY_EVENT_SENSORDATA\n-                        : parameters.get(\"type\");\n+                String parmType = getString(parameters.get(\"type\"));\n+                String event = !parmType.isEmpty() ? parmType : type;\n                 switch (event) {\n                     case SHELLY_EVENT_SHORTPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.SHORT_PRESSED;\n-                        break;\n                     case SHELLY_EVENT_LONGPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.LONG_PRESSED;\n+                        if (isButton) {\n+                            channel = CHANNEL_BUTTON_TRIGGER;\n+                            payload = event.equals(SHELLY_EVENT_SHORTPUSH) ? CommonTriggerEvents.SHORT_PRESSED\n+                                    : CommonTriggerEvents.LONG_PRESSED;\n+                        } else {\n+                            logger.debug(\"{}: Relay button is not in memontary or detached mode, ignore SHORT/LONGPUSH\",\n+                                    thingName);\n+                        }\n                         break;\n-\n                     case SHELLY_EVENT_ROLLER_OPEN:\n                     case SHELLY_EVENT_ROLLER_CLOSE:\n                     case SHELLY_EVENT_ROLLER_STOP:\n                         channel = CHANNEL_EVENT_TRIGGER;\n                         payload = event;\n                         break;\n-\n                     case SHELLY_EVENT_BTN_ON:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN_OFF:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.OFF);\n+                        if (profile.isRGBW2) {\n+                            // RGBW2 has only one input, so not per channel\n+                            group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                        }\n+                        onoff = CHANNEL_INPUT;\n                         break;\n                     case SHELLY_EVENT_BTN1_ON:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN1_OFF:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT1;\n                         break;\n                     case SHELLY_EVENT_BTN2_ON:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN2_OFF:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT2;\n                         break;\n                     case SHELLY_EVENT_OUT_ON:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_OUT_OFF:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.OFF);\n+                        onoff = CHANNEL_OUTPUT;\n+                        break;\n+                    case SHELLY_EVENT_SENSORREPORT:\n+                        // process sensor with next refresh\n+                        break;\n+                    case SHELLY_EVENT_FLOOD_DETECTED:\n+                    case SHELLY_EVENT_FLOOD_GONE:\n+                        updateChannel(group, CHANNEL_SENSOR_FLOOD,\n+                                event.equalsIgnoreCase(SHELLY_EVENT_FLOOD_DETECTED) ? OnOffType.ON : OnOffType.OFF);\n                         break;\n \n                     default:\n                         // trigger will be provided by input/output channel or sensor channels\n                 }\n \n+                if (!onoff.isEmpty()) {\n+                    updateChannel(group, onoff, event.toLowerCase().contains(\"_on\") ? OnOffType.ON : OnOffType.OFF);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 744}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA==", "bodyText": "Optional isn't really a very good choice in this case. It was better when it was a nullable field.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148728", "createdAt": "2020-04-12T05:29:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;\n     protected boolean lockUpdates = false;\n \n-    @SuppressWarnings(\"unused\")\n-    private long lastUpdateTs = 0;\n+    private final ShellyTranslationProvider messages;\n+    private boolean channelsCreated = false;\n+\n     private long lastUptime = 0;\n     private long lastAlarmTs = 0;\n-    private Integer lastTimeoutErros = -1;\n+    private long lastTimeoutErros = -1;\n \n-    private @Nullable ScheduledFuture<?> statusJob;\n-    private int skipUpdate = 0;\n+    private Optional<ScheduledFuture<?>> statusJob = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODg2Mw==", "bodyText": "please make these final", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148863", "createdAt": "2020-04-12T05:31:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static final String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static final String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static final String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public static final String ITEM_TYPE_NUMBER = \"Number\";\n+    public static final String ITEM_TYPE_STRING = \"String\";\n+    public static final String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static final String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static final String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static final String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static final String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static final String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static final String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static final String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTU5NQ==", "bodyText": "The EOF is still here.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149595", "createdAt": "2020-04-12T05:41:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private final Bundle bundle;\n+    private final TranslationProvider i18nProvider;\n+    private final LocaleProvider localeProvider;\n+\n+    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n+        this.bundle = bundle;\n+        this.i18nProvider = i18nProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n+        this.bundle = other.bundle;\n+        this.i18nProvider = other.i18nProvider;\n+        this.localeProvider = other.localeProvider;\n+    }\n+\n+    public @Nullable String get(String key, @Nullable Object... arguments) {\n+        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n+    }\n+\n+    public @Nullable String getText(String key, @Nullable Object... arguments) {\n+        Locale locale = localeProvider.getLocale();\n+        return i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments);\n+    }\n+\n+    public @Nullable String getDefaultText(String key) {\n+        return i18nProvider.getText(bundle, key, key, Locale.ENGLISH);\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA=="}, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTg3Nw==", "bodyText": "Where is this class used as a comparator?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149877", "createdAt": "2020-04-12T05:44:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, "originalCommit": {"oid": "8a81322242a07dcd8a83a36897af17525a0b4ac7"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxOTA0MTQw", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-391904140", "createdAt": "2020-04-12T23:29:49Z", "commit": {"oid": "a3e8c7be0049a752c350a7658df11de459feda54"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQyMzoyOTo0OVrOGEZicg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQyMzozMjo1MlrOGEZjXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg==", "bodyText": "If you want the stack trace, the proper way to do it is like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265906", "createdAt": "2020-04-12T23:29:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -557,12 +554,12 @@ private void handleStatusUpdate(String devId, String payload, int serial) {\n             } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n                 // even the processing of one value failed we continue with the next one (sometimes this is caused by\n                 // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n+                logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n+                        e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e8c7be0049a752c350a7658df11de459feda54"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg==", "bodyText": "same here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}:\", name, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266002", "createdAt": "2020-04-12T23:31:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -174,7 +173,7 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n                     thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n                     logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.debug(\"{}: {}\", name, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e8c7be0049a752c350a7658df11de459feda54"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAxNQ==", "bodyText": "and here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n          \n          \n            \n                                e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': \", name, service.getNiceTextString(),\n          \n          \n            \n                                e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266015", "createdAt": "2020-04-12T23:31:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -193,8 +192,9 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n             }\n         } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n                                                                                     // buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n-            logger.debug(\"{}: Exception {}\", name, e.toString());\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, e.getMessage()));\n+            logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n+                    e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e8c7be0049a752c350a7658df11de459feda54"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjE0MQ==", "bodyText": "You forgot to change this", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266141", "createdAt": "2020-04-12T23:32:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -174,7 +164,7 @@ private void handleBrightness(Command command, Integer index) throws IOException\n         if (command instanceof OnOffType) { // Switch\n             logger.debug(\"Switch output {}\", command.toString());\n             api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}, "originalCommit": {"oid": "a7ec663a0eaa84e50b049543da55ade8fd2a689f"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDIxOTYz", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-392421963", "createdAt": "2020-04-13T20:38:41Z", "commit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozODo0MVrOGE0cHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTo0MzozOVrOGE2bLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjY1NA==", "bodyText": "You still didn't resolve this one...", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407706654", "createdAt": "2020-04-13T20:38:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, "originalCommit": {"oid": "42ce66ea5f896972d0fb50348c33726756339bb9"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNjMzOA==", "bodyText": "Are you forgetting to change this or ignoring it?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407716338", "createdAt": "2020-04-13T20:56:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA=="}, "originalCommit": {"oid": "d1a54fedc2a0696db425872653084325ed15e0b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQ2Ng==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407717466", "createdAt": "2020-04-13T20:58:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +347,218 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        boolean timeout = false;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                if (timeout) {\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                    timeoutsRecovered++;\n                 }\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if ((!e.isTimeout() && !apiResult.isHttpServerError()) || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or API exception for non-battery device or retry counter expired\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeout = true;\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 659}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODg3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: CoAP Exception\", thingName, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407718872", "createdAt": "2020-04-13T21:01:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -97,31 +103,38 @@ public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thin\n     /*\n      * Initialize Coap access, send discovery packet and start Status server\n      */\n-    @SuppressWarnings(\"null\")\n-    public void start() {\n+    public void start(String thingName, ShellyThingConfiguration config) throws ShellyApiException {\n+        if (isStarted()) {\n+            logger.trace(\"{}: CoAP Listener was already started\", thingName);\n+            return;\n+        }\n         try {\n+            this.thingName = thingName;\n+            this.config = config;\n+\n             reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n-            if (statusClient == null) {\n-                coapServer.init(config.localIp);\n-                coapServer.addListener(this);\n+            if (!isStarted()) {\n+                logger.debug(\"{}: Starting CoAP Listener\", thingName);\n+                reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n+                coapServer.start(config.localIp, this);\n                 statusClient = new CoapClient(completeUrl(config.deviceIp, COLOIT_URI_DEVSTATUS))\n                         .setTimeout((long) SHELLY_API_TIMEOUT_MS).useNONs().setEndpoint(coapServer.getEndpoint());\n-\n-                coapServer.start();\n             }\n-        } catch (IOException e) {\n-            logger.warn(\"{}: Unable to start CoIoT: {}\", thingName, e.getMessage());\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}: Coap Exception: {} ({})\\n{}\", thingName, e.getMessage(), e.getClass(), e.getStackTrace());\n+        } catch (UnknownHostException e) {\n+            ShellyApiException ea = new ShellyApiException(e);\n+            logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTQwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}\", thingName, payload, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719409", "createdAt": "2020-04-13T21:02:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -211,40 +218,33 @@ public void processResponse(@Nullable Response response) {\n                         response.getPayloadString());\n             }\n \n-            if (reqStatus == null) {\n-                /*\n-                 * Observe Status Updates\n-                 */\n+            if (!discovering) {\n+                // Observe Status Updates\n                 reqStatus = sendRequest(reqStatus, config.deviceIp, COLOIT_URI_DEVSTATUS, Type.NON);\n+                discovering = true;\n             }\n-        } catch (NullPointerException | IOException e) {\n-            logger.debug(\"{}: Unable to process CoIoT Message: {} ({}); payload={}\\n{}\", thingName, e.getMessage(),\n-                    e.getClass(), payload, e.getStackTrace());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTY3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip\", thingName, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719674", "createdAt": "2020-04-13T21:03:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +288,30 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}:    Unable to decode sensor definition -> skip ({})\\n{}\", thingName, e.getMessage(),\n-                    e.getStackTrace());\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy\n+            logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDU1NA==", "bodyText": "This change is correct.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407720554", "createdAt": "2020-04-13T21:04:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -557,12 +554,12 @@ private void handleStatusUpdate(String devId, String payload, int serial) {\n             } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n                 // even the processing of one value failed we continue with the next one (sometimes this is caused by\n                 // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n+                logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n+                        e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}, "originalCommit": {"oid": "a3e8c7be0049a752c350a7658df11de459feda54"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzU5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param sen Semsor description\n          \n          \n            \n                 * @param sen Sensor description", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407723594", "createdAt": "2020-04-13T21:10:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -523,28 +581,77 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n         lastPayload = payload;\n     }\n \n-    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n-        State v = (State) thingHandler.getChannelValue(group, channel);\n-        if ((v != null) && v.equals(value)) {\n-            return false;\n+    private void updatePower(ShellyDeviceProfile profile, Map<String, State> updates, Integer id, CoIotDescrSen sen,\n+            CoIotSensor s, List<CoIotSensor> allUpdates) {\n+        String group = \"\";\n+        String channel = CHANNEL_BRIGHTNESS;\n+        String checkL = \"\"; // RGBW-white uses 4 different Power, Brightness, VSwitch values\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isBulb || profile.inColor) {\n+                group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                channel = CHANNEL_LIGHT_POWER;\n+            } else if (profile.isDuo) {\n+                group = CHANNEL_GROUP_WHITE_CONTROL;\n+            } else if (profile.isDimmer) {\n+                group = CHANNEL_GROUP_RELAY_CONTROL;\n+            } else if (profile.isRGBW2) {\n+                group = CHANNEL_GROUP_LIGHT_CHANNEL + id;\n+                checkL = String.valueOf(id.intValue() - 1); // id is 1-based, L is 0-based\n+                logger.trace(\"{}: updatePower() for L={}\", thingName, checkL);\n+            }\n+\n+            // We need to update brigthtess and on/off state at the same time to avoid \"flipping brightness slider\" in\n+            // the UI\n+            Double brightness = -1.0;\n+            Double power = -1.0;\n+            for (CoIotSensor update : allUpdates) {\n+                CoIotDescrSen d = fixDescription(sensorMap.get(update.id));\n+                if (!checkL.isEmpty() && !d.links.equals(checkL)) {\n+                    // continue until we find the correct one\n+                    continue;\n+                }\n+                if (d.desc.equalsIgnoreCase(\"brightness\")) {\n+                    brightness = new Double(update.value);\n+                } else if (d.desc.equalsIgnoreCase(\"output\") || d.desc.equalsIgnoreCase(\"state\")) {\n+                    power = new Double(update.value);\n+                }\n+            }\n+            if (power != -1) {\n+                updateChannel(updates, group, channel + \"$Switch\", power == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n+            if (brightness != -1) {\n+                updateChannel(updates, group, channel + \"$Value\",\n+                        toQuantityType(power == 1 ? brightness : 0, DIGITS_NONE, SmartHomeUnits.PERCENT));\n+            }\n+        } else if (profile.hasRelays) {\n+            group = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL : CHANNEL_GROUP_RELAY_CONTROL + id;\n+            updateChannel(updates, group, CHANNEL_OUTPUT, s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+        } else if (profile.isSensor) {\n+            // Sensor state\n+            if (profile.isDW) { // Door Window has item type Contact\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+            } else {\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n         }\n-        logger.trace(\"{}: Updating channel {}.{} from CoIoT, new value={}\", thingName, group, channel, value);\n+    }\n+\n+    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n         updates.put(mkChannelId(group, channel), value);\n         return true;\n \n     }\n \n     /**\n-     * Work around to fix inconsistent sensor types and description\n-     * Shelly not uses always the same coding for sen.T and sen.D - this helps to unify the format and simplifies\n-     * processing\n+     * Work around to fix inconsistent sensor types and description. Shelly not uses always the same coding for sen.T\n+     * and sen.D - this helps to unify the format and simplifies processing\n      *\n-     * @param sen\n+     * @param sen Semsor description", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 694}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNTIzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later:\", name, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407725237", "createdAt": "2020-04-13T21:14:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +96,82 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n-            if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+            address = service.getHostAddress();\n+            if ((address == null) || address.isEmpty()) {\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            String thingType = service.getQualifiedName().contains(SERVICE_TYPE) && name.contains(\"-\")\n+                    ? StringUtils.substringBefore(name, \"-\")\n+                    : name;\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}, type={}\", name, address, thingType);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n                 thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n                     thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjQzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.info(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726436", "createdAt": "2020-04-13T21:16:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjYxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID), e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726610", "createdAt": "2020-04-13T21:16:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjgxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n          \n          \n            \n                        logger.warn(\"{}: {}\", thingName, messages.get(\"statusupdate.failed\"), e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726815", "createdAt": "2020-04-13T21:17:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +359,104 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTk4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n          \n          \n            \n                        this.statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407729980", "createdAt": "2020-04-13T21:23:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {\n-            statusJob = scheduler.scheduleWithFixedDelay(this::updateStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n+            statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 873}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDI4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"null\")\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730283", "createdAt": "2020-04-13T21:24:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 871}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDU1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getChannelValue(String group, String channel) {\n          \n          \n            \n                public @Nullable Object getChannelValue(String group, String channel) {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730557", "createdAt": "2020-04-13T21:25:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 934}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions:\", thingName, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407731461", "createdAt": "2020-04-13T21:26:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {\n+        return cache.getValue(group, channel);\n+    }\n+\n     /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n+     * Update Thing's channels according to available status information from the API\n      *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n+     * @param thingHandler\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+    protected void updateChannelDefinitions(Map<String, Channel> dynChannels) {\n+        if (channelsCreated) {\n+            return; // already done\n+        }\n+\n         try {\n-            Object current = channelData.get(channelId);\n-            // logger.trace(\"{}: Predict channel {}.{} to become {} (type {}).\", thingName,\n-            // group, channel, value, value.getClass());\n-            if (!channelCache || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n-                if (current == null) {\n-                    channelData.put(channelId, value);\n-                } else {\n-                    channelData.replace(channelId, value);\n+            // Get subset of those channels that currently do not exist\n+            List<Channel> existingChannels = getThing().getChannels();\n+            for (Channel channel : existingChannels) {\n+                String id = channel.getUID().getId();\n+                if (dynChannels.containsKey(id)) {\n+                    dynChannels.remove(id);\n                 }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"Unable to update channel {}.{} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass(), e.getMessage(), e.getClass());\n+\n+            if (!dynChannels.isEmpty()) {\n+                logger.debug(\"{}: Updating channel definitions, {} channels\", thingName, dynChannels.size());\n+                ThingBuilder thingBuilder = editThing();\n+                for (Map.Entry<String, Channel> channel : dynChannels.entrySet()) {\n+                    Channel c = channel.getValue();\n+                    logger.debug(\"{}: Adding channel {}\", thingName, c.getUID().getId());\n+                    thingBuilder.withChannel(c);\n+                }\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{}: Channel definitions updated\", thingName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 998}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjEzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        statusJob = null;\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        this.statusJob = null;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407732131", "createdAt": "2020-04-13T21:28:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -865,94 +943,70 @@ public String getProperty(String key) {\n      * @param ForceRefresh true=force refresh before returning, false=return without\n      *            refresh\n      * @return ShellyDeviceProfile instance\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws IOException {\n+    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws ShellyApiException {\n         try {\n             refreshSettings |= forceRefresh;\n             if (refreshSettings) {\n-                logger.debug(\"{}: Refresh settings\", thingName);\n-                profile = api.getDeviceProfile(getThing().getThingTypeUID().getId());\n+                profile = api.getDeviceProfile(thingType);\n+                if (!isThingOnline()) {\n+                    logger.debug(\"{}:Device profile re-initialized (thingType={})\", thingName, thingType);\n+                }\n             }\n         } finally {\n             refreshSettings = false;\n         }\n         return profile;\n     }\n \n-    @Nullable\n     public ShellyDeviceProfile getProfile() {\n         return profile;\n     }\n \n-    @Nullable\n     protected ShellyHttpApi getShellyApi() {\n         return api;\n     }\n \n-    @Nullable\n     protected ShellyDeviceProfile getDeviceProfile() {\n         return profile;\n     }\n \n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getChannelValue(String group, String channel) {\n-        String key = mkChannelId(group, channel);\n-        return channelData.get(key);\n-    }\n-\n     public void triggerChannel(String group, String channel, String payload) {\n         triggerChannel(mkChannelId(group, channel), payload);\n     }\n \n+    public void stop() {\n+        logger.debug(\"{}: Shutting down\", thingName);\n+        if (statusJob != null) {\n+            statusJob.cancel(true);\n+            statusJob = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 1156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMzczNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to handle command:\", thingName, e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407733734", "createdAt": "2020-04-13T21:31:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -74,160 +76,167 @@ public void initialize() {\n         super.initialize();\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n-    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IOException {\n-        String groupName = channelUID.getGroupId();\n-        Integer lightId = getLightIdFromGroup(groupName);\n-        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command.toString(),\n-                channelUID.getAsString(), lightId);\n-\n-        Validate.notNull(profile, \"DeviceProfile must not be null, thing not initialized\");\n-        Validate.notNull(api, \"handleCommand(): api must not be null!\");\n-        ShellyColorUtils oldCol = getCurrentColors(lightId);\n-        Validate.notNull(oldCol, \"oldCol must not be null\");\n-        oldCol.mode = profile.mode;\n-        ShellyColorUtils col = new ShellyColorUtils(oldCol);\n-        Validate.notNull(oldCol, \"copy of oldCol must not be null\");\n-\n-        boolean update = true;\n-        switch (channelUID.getIdWithoutGroup()) {\n-            default: // non-bulb commands will be handled by the generic handler\n-                return false;\n-\n-            case CHANNEL_LIGHT_POWER:\n-                logger.debug(\"{}: Switch light {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType, \"Invalid value for power (ON or OFF): {}\",\n-                        command.toString());\n-                api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n-                        (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                col.power = (OnOffType) command;\n-                update = (OnOffType) command == OnOffType.ON;\n-                break;\n-            case CHANNEL_LIGHT_COLOR_MODE:\n-                logger.debug(\"{}: Select color mode {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType,\n-                        \"Invalid value for color mode (ON or OFF): \" + command.toString());\n-                col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-                break;\n-            case CHANNEL_COLOR_PICKER:\n-                logger.debug(\"{}: Update colors from color picker\", thingName);\n-                update = handleColorPicker(profile, lightId, col, command);\n-                break;\n-            case CHANNEL_COLOR_FULL:\n-                logger.debug(\"{}: Set colors to {}\", thingName, command.toString());\n-                handleFullColor(col, command);\n-                break;\n-            case CHANNEL_COLOR_RED:\n-                col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GREEN:\n-                col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_BLUE:\n-                col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_WHITE:\n-                col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GAIN:\n-                col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n-                break;\n-            case CHANNEL_BRIGHTNESS: // only in white mode\n-                Integer value = -1;\n-                if (command instanceof OnOffType) { // Switch\n-                    logger.debug(\"Switch light {}\", command.toString());\n-                    api.setRelayTurn(lightId, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                    requestUpdates(1, false);\n-                    break;\n-                }\n+    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IllegalArgumentException {\n+        String groupName = getString(channelUID.getGroupId());\n+        if (groupName.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty groupName\");\n+        }\n \n-                if (command instanceof PercentType) {\n-                    Float percent = ((PercentType) command).floatValue();\n-                    value = percent.intValue(); // 0..100% = 0..100\n-                    logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n-                } else if (command instanceof DecimalType) {\n-                    value = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n-                }\n-                if (value == 0) {\n-                    logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n-                    api.setRelayTurn(lightId, SHELLY_API_OFF);\n+        int lightId = getLightIdFromGroup(groupName);\n+        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command, channelUID.getAsString(),\n+                lightId);\n+\n+        try {\n+            ShellyColorUtils oldCol = getCurrentColors(lightId);\n+            oldCol.mode = profile.mode;\n+            ShellyColorUtils col = new ShellyColorUtils(oldCol);\n+\n+            boolean update = true;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                default: // non-bulb commands will be handled by the generic handler\n+                    return false;\n+\n+                case CHANNEL_LIGHT_POWER:\n+                    logger.debug(\"{}: Switch light {}\", thingName, command);\n+                    api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n+                            command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                    col.power = (OnOffType) command;\n                     requestUpdates(1, false);\n+                    update = false;\n                     break;\n-                }\n+                case CHANNEL_LIGHT_COLOR_MODE:\n+                    logger.debug(\"{}: Select color mode {}\", thingName, command);\n+                    col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+                    break;\n+                case CHANNEL_COLOR_PICKER:\n+                    logger.debug(\"{}: Update colors from color picker\", thingName);\n+                    update = handleColorPicker(profile, lightId, col, command);\n+                    break;\n+                case CHANNEL_COLOR_FULL:\n+                    logger.debug(\"{}: Set colors to {}\", thingName, command);\n+                    handleFullColor(col, command);\n+                    break;\n+                case CHANNEL_COLOR_RED:\n+                    col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GREEN:\n+                    col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_BLUE:\n+                    col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_WHITE:\n+                    col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GAIN:\n+                    col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n+                    break;\n+                case CHANNEL_BRIGHTNESS: // only in white mode\n+                    if (profile.inColor && !profile.isBulb) {\n+                        logger.debug(\"{}: Not in white mode, brightness not available\", thingName);\n+                        break;\n+                    }\n \n-                if (command instanceof IncreaseDecreaseType) {\n-                    ShellyShortLightStatus light = api.getLightStatus(lightId);\n-                    Validate.notNull(light, \"Unable to get Light status for brightness\");\n+                    int value = -1;\n+                    if (command instanceof OnOffType) { // Switch\n+                        logger.debug(\"{}: Switch light {}\", thingName, command);\n+                        ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                        col.brightness = light.brightness;\n+                        col.power = (OnOffType) command;\n+                        api.setRelayTurn(lightId, col.power == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                        // updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Switch\", col.power);\n+                        updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Value\",\n+                                toQuantityType(new Double(col.power == OnOffType.ON ? col.brightness : 0), DIGITS_NONE,\n+                                        SmartHomeUnits.PERCENT));\n+                        update = false;\n+                        break;\n+                    }\n \n-                    if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n-                        value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                    if (command instanceof PercentType) {\n+                        Float percent = ((PercentType) command).floatValue();\n+                        value = percent.intValue(); // 0..100% = 0..100\n+                        logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n+                    } else if (command instanceof DecimalType) {\n+                        value = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n+                    }\n+                    if (value == 0) {\n+                        logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n+                        api.setRelayTurn(lightId, SHELLY_API_OFF);\n+                        update = false;\n                     } else {\n-                        value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                            if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n+                                value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                            } else {\n+                                value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+                            }\n+                            logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n+                        }\n+\n+                        validateRange(\"brightness\", value, 0, 100);\n+                        logger.debug(\"{}: Changing brightness from {} to {}\", thingName, oldCol.brightness, value);\n+                        col.setBrightness(value);\n                     }\n-                    logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n-                }\n+                    updateChannel(CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_LIGHT_POWER,\n+                            value > 0 ? OnOffType.ON : OnOffType.OFF);\n+                    break;\n \n-                validateRange(\"brightness\", value, 0, 100);\n-                logger.debug(\"{}: Set brightness to\", value);\n-                col.setBrightness(value);\n-                break;\n-\n-            case CHANNEL_COLOR_TEMP:\n-                Integer temp = -1;\n-                if (command instanceof PercentType) {\n-                    logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n-                    Float percent = ((PercentType) command).floatValue() / 100;\n-                    temp = new DecimalType(\n-                            MIN_COLOR_TEMPERATURE + ((MAX_COLOR_TEMPERATURE - MIN_COLOR_TEMPERATURE)) * percent)\n-                                    .intValue();\n-                    logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName, percent,\n-                            temp);\n-                } else if (command instanceof DecimalType) {\n-                    temp = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n-                }\n-                validateRange(CHANNEL_COLOR_TEMP, temp, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE);\n-                col.setTemp(temp);\n-                break;\n-\n-            case CHANNEL_COLOR_EFFECT:\n-                Integer effect = ((DecimalType) command).intValue();\n-                logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n-                validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n-                col.setEffect(effect.intValue());\n-                break;\n-        }\n+                case CHANNEL_COLOR_TEMP:\n+                    Integer temp = -1;\n+                    if (command instanceof PercentType) {\n+                        logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n+                        Float percent = ((PercentType) command).floatValue() / 100;\n+                        temp = new DecimalType(col.minTemp + ((col.maxTemp - col.minTemp)) * percent).intValue();\n+                        logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName,\n+                                percent, temp);\n+                    } else if (command instanceof DecimalType) {\n+                        temp = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n+                    }\n+                    validateRange(CHANNEL_COLOR_TEMP, temp, col.minTemp, col.maxTemp);\n+                    col.setTemp(temp);\n+                    col.brightness = -1;\n+                    break;\n \n-        if (update) {\n-            // check for switching color mode\n-            if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n-                logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode, col.mode);\n-                api.setLightMode(col.mode);\n+                case CHANNEL_COLOR_EFFECT:\n+                    Integer effect = ((DecimalType) command).intValue();\n+                    logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n+                    validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n+                    col.setEffect(effect.intValue());\n             }\n \n-            // send changed colors to the device\n-            sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n-        }\n-\n-        return true;\n+            if (update) {\n+                // check for switching color mode\n+                if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n+                    logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode,\n+                            col.mode);\n+                    api.setLightMode(col.mode);\n+                }\n \n+                // send changed colors to the device\n+                sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n+            }\n+            return true;\n+        } catch (ShellyApiException | IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTcyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n          \n          \n            \n                                newValue.getClass(), ShellyUtils.getMessage(e), e.getClass());", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735727", "createdAt": "2020-04-13T21:35:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String channelId) {\n          \n          \n            \n                public @Nullable State getValue(String channelId) {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735889", "createdAt": "2020-04-13T21:36:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String group, String channel) {\n          \n          \n            \n                public @Nullable State getValue(String group, String channel) {\n          \n      \n    \n    \n  \n\nIn addition would it be possible to get rid of the nullable return value by returning UndefType.NULL instead?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735984", "createdAt": "2020-04-13T21:36:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA==", "bodyText": "Why couldn't you just do this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int compare(Object o1, Object o2) {\n          \n          \n            \n                    String version1 = (String) o1;\n          \n          \n            \n                    String version2 = (String) o2;\n          \n          \n            \n                public int compare(String version1, String version2) {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407738024", "createdAt": "2020-04-13T21:41:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private boolean MoveNext() {\n          \n          \n            \n                    private boolean moveNext() {", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407739180", "createdAt": "2020-04-13T21:43:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3557dbbda1155bacea7289de274e96dd402287cd"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a7269dec2de7aec3c9bc99f0e3fe809f54abca55", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a7269dec2de7aec3c9bc99f0e3fe809f54abca55", "committedDate": "2020-04-15T22:08:20Z", "message": "changed log level for \"API call returned exception\" to trace\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}, "afterCommit": {"oid": "ea3c676f9f60a737b94db41273eca5de525e9132", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/ea3c676f9f60a737b94db41273eca5de525e9132", "committedDate": "2020-04-17T05:51:13Z", "message": "[sensebox] Added German translations (#7384)\n\n* Added German translations\r\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "committedDate": "2020-04-17T12:36:41Z", "message": "Re-checkin based on latest PR review status\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/0f8b13e2ef4c7b4ec0f58a02905581c384709218", "committedDate": "2020-04-17T12:38:14Z", "message": "delete obsolete files from 2.5.2 version\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjU4OTIw", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-395658920", "createdAt": "2020-04-17T17:54:21Z", "commit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo1NDoyMVrOGHXpCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDowNzoyNlrOGHbjKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDU1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<description>Interval in seconds to query an update from the device.</description>\n          \n          \n            \n            \t\t\t<description>Interval to query an update from the device.</description>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410380552", "createdAt": "2020-04-17T17:54:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -113,6 +181,42 @@\n \t\t</parameter>\n \t</config-description>\n \n+\t<config-description uri=\"thing-type:shelly:rgbw2\">\n+\t\t<parameter name=\"userId\" type=\"text\" required=\"false\">\n+\t\t\t<label>User</label>\n+\t\t\t<description>User ID for HTTP API access.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"password\" type=\"text\" required=\"false\">\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for HTTP API access.</description>\n+\t\t\t<context>password</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"deviceIp\" type=\"text\" required=\"true\">\n+\t\t\t<label>Device IP Address</label>\n+\t\t\t<description>IP-Address of the Shelly device.</description>\n+\t\t\t<context>network-address</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"brightnessAutoOn\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Brightness Auto-ON</label>\n+\t\t\t<description>true: Turn device ON if brightness > 0 is set; false: don't touch power status when brightness is set.</description>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"eventsCoIoT\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Enable CoIoT Events</label>\n+\t\t\t<description>If enabled, the CoAP protocol is used to receive status updates.</description>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Update Interval</label>\n+\t\t\t<description>Interval in seconds to query an update from the device.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MTE0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n          \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410381144", "createdAt": "2020-04-17T17:55:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -113,6 +181,42 @@\n \t\t</parameter>\n \t</config-description>\n \n+\t<config-description uri=\"thing-type:shelly:rgbw2\">\n+\t\t<parameter name=\"userId\" type=\"text\" required=\"false\">\n+\t\t\t<label>User</label>\n+\t\t\t<description>User ID for HTTP API access.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"password\" type=\"text\" required=\"false\">\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for HTTP API access.</description>\n+\t\t\t<context>password</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"deviceIp\" type=\"text\" required=\"true\">\n+\t\t\t<label>Device IP Address</label>\n+\t\t\t<description>IP-Address of the Shelly device.</description>\n+\t\t\t<context>network-address</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"brightnessAutoOn\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Brightness Auto-ON</label>\n+\t\t\t<description>true: Turn device ON if brightness > 0 is set; false: don't touch power status when brightness is set.</description>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"eventsCoIoT\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Enable CoIoT Events</label>\n+\t\t\t<description>If enabled, the CoAP protocol is used to receive status updates.</description>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MTY1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<description>Interval in seconds to query an update from the device.</description>\n          \n          \n            \n            \t\t\t<description>Interval to query an update from the device.</description>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410381650", "createdAt": "2020-04-17T17:56:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -102,8 +129,49 @@\n \t\t\t<label>Enable CoIoT Events</label>\n \t\t\t<description>If enabled, the CoAP protocol is used to receive status updates.</description>\n \t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Update Interval</label>\n+\t\t\t<description>Interval in seconds to query an update from the device.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MTczNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n          \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410381734", "createdAt": "2020-04-17T17:56:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -102,8 +129,49 @@\n \t\t\t<label>Enable CoIoT Events</label>\n \t\t\t<description>If enabled, the CoAP protocol is used to receive status updates.</description>\n \t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MjY3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n          \n          \n            \n            \t\t\t<label>Update Interval</label>\n          \n          \n            \n            \t\t\t<description>Interval in seconds to query an update from the device.</description>\n          \n          \n            \n            \t\t\t<default>60</default>\n          \n          \n            \n            \t\t\t<unitLabel>s</unitLabel>\n          \n          \n            \n            \t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\" unit=\"s\">\n          \n          \n            \n            \t\t\t<label>Update Interval</label>\n          \n          \n            \n            \t\t\t<description>Interval to query an update from the device.</description>\n          \n          \n            \n            \t\t\t<default>60</default>\n          \n          \n            \n            \t\t\t<unitLabel>seconds</unitLabel>", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410382671", "createdAt": "2020-04-17T17:58:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -56,11 +52,42 @@\n \t\t</parameter>\n \t</config-description>\n \n-\t<config-description uri=\"thing-type:shelly:light\">\n-\t\t<parameter-group name=\"advancedOptions\">\n-\t\t\t<label>Advanced Options</label>\n-\t\t</parameter-group>\n-\n+\t<config-description uri=\"thing-type:shelly:roller\">\n+\t\t<parameter name=\"userId\" type=\"text\" required=\"false\">\n+\t\t\t<label>User</label>\n+\t\t\t<description>User ID for HTTP API access.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"password\" type=\"text\" required=\"false\">\n+\t\t\t<label>Password</label>\n+\t\t\t<description>Password for HTTP API access.</description>\n+\t\t\t<context>password</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"deviceIp\" type=\"text\" required=\"true\">\n+\t\t\t<label>Device IP Address</label>\n+\t\t\t<description>IP-Address of the Shelly device.</description>\n+\t\t\t<context>network-address</context>\n+\t\t</parameter>\n+\t\t<parameter name=\"eventsRoller\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Enable Roller Events (Roller only)</label>\n+\t\t\t<description>True if the binding should register to get Roller Events.</description>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"eventsCoIoT\" type=\"boolean\" required=\"false\">\n+\t\t\t<label>Enable CoIoT Events</label>\n+\t\t\t<description>If enabled, the CoAP protocol is used to receive status updates.</description>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\t\t<parameter name=\"updateInterval\" type=\"integer\" required=\"true\">\n+\t\t\t<label>Update Interval</label>\n+\t\t\t<description>Interval in seconds to query an update from the device.</description>\n+\t\t\t<default>60</default>\n+\t\t\t<unitLabel>s</unitLabel>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NDE4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (tokenizer2.moveNext()) {\n          \n          \n            \n                        do {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (tokenizer2.moveNext());\n          \n          \n            \n            \n          \n          \n            \n                        // Version two is longer than version one, but zero\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    }\n          \n          \n            \n                    return 0;\n          \n          \n            \n                    while (tokenizer2.moveNext()) {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                    }\n          \n          \n            \n                    // Version two is longer than version one, but zero\n          \n          \n            \n                    return 0;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410384189", "createdAt": "2020-04-17T18:01:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean moveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String s1, String s2) {\n+        return compare(s1, s2) == 0;\n+    }\n+\n+    public int compare(String version1, String version2) {\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.moveNext()) {\n+            if (!tokenizer2.moveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.moveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.moveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.moveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMTE1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410421150", "createdAt": "2020-04-17T19:15:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -113,52 +116,20 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n                 index = \"\";\n                 type = StringUtils.substringAfterLast(path, \"/\").toLowerCase();\n             }\n-            logger.trace(\"Process event of type type={} for device {}, index={}\", type, deviceName, index);\n-            Map<String, String> parms = new HashMap<>();\n+            logger.trace(\"{}: Process event of type type={}, index={}\", deviceName, type, index);\n+            Map<String, String> parms = new TreeMap<>();\n+\n             for (Map.Entry<String, String[]> p : parameters.entrySet()) {\n                 parms.put(p.getKey(), p.getValue()[0]);\n \n             }\n-            handlerFactory.onEvent(deviceName, index, type, parms);\n-\n-        } catch (NullPointerException e) {\n-            logger.debug(\n-                    \"ERROR: Exception processing callback: {} ({}), path={}, data='{}'; deviceName={}, index={}, type={}, parameters={}\\n{}\",\n-                    e.getMessage(), e.getClass(), path, data, deviceName, index, type,\n-                    request.getParameterMap().toString(), e.getStackTrace());\n+            handlerFactory.onEvent(ipAddress, deviceName, index, type, parms);\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n+                    deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTk0Nw==", "bodyText": "It would be more concise if you changed your setEventUrl method to accept multiple event types\nprivate void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes){\n    for(String eventType : eventTypes){\n        if (profile.containsEventUrl(eventType)) {\n        ...\n        }\n    }\n}\n\nThat way you can call it like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF, SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1, SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410425947", "createdAt": "2020-04-17T19:26:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,221 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_CLOSE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_VIBRATION, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 503}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTAyNA==", "bodyText": "I don't know what kind of processing goes on behind response.getSourceContext().getPeerAddress() and response.getPayloadString(). But to be safe you should probably make sure those are only called when necessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        if(logger.isDebugEnabled()){\n          \n          \n            \n                            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429024", "createdAt": "2020-04-17T19:33:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -141,8 +158,8 @@ public void processResponse(@Nullable Response response) {\n         // int validity = 0;\n         int serial = 0;\n         try {\n-            logger.debug(\"{}: CoIoT Message from {}: {}\", thingName, response.getSourceContext().getPeerAddress(),\n-                    response.toString());\n+            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n+                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTQ3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM external temp sensors", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429473", "createdAt": "2020-04-17T19:34:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 403}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM external temp sensors", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429525", "createdAt": "2020-04-17T19:34:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                                // ignore F, we use C only\n+                                break;\n+                            case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 406}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ==", "bodyText": "shouldn't this be synchronized too?", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410431181", "createdAt": "2020-04-17T19:37:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java", "diffHunk": "@@ -140,20 +122,25 @@ public CoapEndpoint getEndpoint() {\n     /**\n      * Cancel pending requests and shutdown the client\n      */\n-    @SuppressWarnings(\"null\")\n-    public void stop() {\n+    public void stop(ShellyCoapListener listener) {\n+        coapListeners.remove(listener);\n+        if (coapListeners.isEmpty()) {\n+            stop();\n+        }\n+    }\n+\n+    private void stop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjc2NQ==", "bodyText": "You shouldn't log this, thing status changes are already logged for you.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410432765", "createdAt": "2020-04-17T19:41:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +360,113 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                logger.debug(\"{}: Ignore API Timeout, retry later\", thingName);\n+                // next release will implement a watchdog here\n+                // status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n+            } else if (e.IsJSONException()) {\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unable to parse API response: {}; json={}\", thingName, res.getUrl(), res.response, e);\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unexpected API result: {}\", thingName, res.response, e);\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to refresh status: {}\", thingName, messages.get(\"statusupdate.failed\"), e);\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && !cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        return getThing().getStatus() == ThingStatus.OFFLINE;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n \n+            // request 3 updates in a row (during the first 2+3*3 sec)\n+            requestUpdates(!profile.hasBattery ? 3 : 1, channelsCreated == false);\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (!isThingOffline()) {\n+            logger.info(\"{}: Thing goes OFFLINE: {}\", thingName, messages.get(messageKey));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 545}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTQ1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n          \n          \n            \n            Make sure to wake up battery powered devices (press the button inside the device), so that they show up on the network.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410435450", "createdAt": "2020-04-17T19:47:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjc3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the device is discovered and initialized successful the binding is able to perform an auto-initialization when OH was restarted in between. The device wake-up triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers the initialization.\n          \n          \n            \n            The first time a device is discovered and initialized successfully, the binding will be able to perform auto-initialization when OH is restarted. Waking up the device triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers initialization.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410436771", "createdAt": "2020-04-17T19:49:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n+The device has a push button inside, open the case, press that button and the LED starts blinking.\n+The device should show up in the Inbox and can be added.\n+\n+`\n+Important: If device is in sleep mode and can't be reached by the binding, the Thing will change into UNKNOWN state.\n+Once the device wakes up the thing does the initialization and the state changes to ONLINE.\n+`\n+\n+Once the device is discovered and initialized successful the binding is able to perform an auto-initialization when OH was restarted in between. The device wake-up triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers the initialization.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzODQxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            So you don't need to manually wake-up the devices after an openHAB restart.\n          \n          \n            \n            Once a device is initialized, it is no longer necessary to manually wake it up after an openHAB restart.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410438419", "createdAt": "2020-04-17T19:53:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n+The device has a push button inside, open the case, press that button and the LED starts blinking.\n+The device should show up in the Inbox and can be added.\n+\n+`\n+Important: If device is in sleep mode and can't be reached by the binding, the Thing will change into UNKNOWN state.\n+Once the device wakes up the thing does the initialization and the state changes to ONLINE.\n+`\n+\n+Once the device is discovered and initialized successful the binding is able to perform an auto-initialization when OH was restarted in between. The device wake-up triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers the initialization.\n+So you don't need to manually wake-up the devices after an openHAB restart.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzODY5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Devices having no battery are expected to be ON/reachable on the network all the time.\n          \n          \n            \n            Devices that have no battery are expected to be ON/reachable on the network at all times.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410438699", "createdAt": "2020-04-17T19:53:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n+The device has a push button inside, open the case, press that button and the LED starts blinking.\n+The device should show up in the Inbox and can be added.\n+\n+`\n+Important: If device is in sleep mode and can't be reached by the binding, the Thing will change into UNKNOWN state.\n+Once the device wakes up the thing does the initialization and the state changes to ONLINE.\n+`\n+\n+Once the device is discovered and initialized successful the binding is able to perform an auto-initialization when OH was restarted in between. The device wake-up triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers the initialization.\n+So you don't need to manually wake-up the devices after an openHAB restart.\n+\n+Devices having no battery are expected to be ON/reachable on the network all the time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzOTc0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The current firmware doesn't support the timestamp report for the meters. \n          \n          \n            \n            The current firmware doesn't support timestamp reporting for the meters.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410439749", "createdAt": "2020-04-17T19:56:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -332,34 +444,51 @@ The Shelly 4Pro provides 4 relays and 4 power meters.\n \n |Group     |Channel      |Type     |read-only|Desciption                                                             |\n |----------|-------------|---------|---------|-----------------------------------------------------------------------|\n-|control   |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF command; in seconds|\n+|control   |input        |Switch   |yes      |State of Input                                                         |\n+|channel1  |brightness   |Dimmer   |r/w      |Channel 1: Brightness: 0..100, control power state with ON/OFF         |\n+|          |button       |Trigger  |yes      |Event trigger with payload SHORT_PRESSED or LONG_PRESSED (FW 1.5.6+)   |\n+|          |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF command; in seconds|\n+|          |autoOff      |Number   |r/w      |Sets a  timer to turn the device OFF after every ON command; in seconds|\n+|          |timerActive  |Switch   |yes      |ON: An auto-on/off timer is active                                     |\n+|channel2  |brightness   |Dimmer   |r/w      |Channel 2: Brightness: 0..100, control power state with ON/OFF         |\n+|          |button       |Trigger  |yes      |Event trigger with payload SHORT_PRESSED or LONG_PRESSED (FW 1.5.6+)   |\n+|          |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF command; in seconds|\n |          |autoOff      |Number   |r/w      |Sets a  timer to turn the device OFF after every ON command; in seconds|\n |          |timerActive  |Switch   |yes      |ON: An auto-on/off timer is active                                     |\n-|channel1  |power        |Switch   |r/w      |Channel 1: Turn channel on/off                                         |\n-|          |brightness   |Dimmer   |r/w      |Channel 1: Brightness: 0..100                                          |\n-|channel2  |power        |Switch   |r/w      |Channel 2: Turn channel on/off                                         |\n-|          |brightness   |Dimmer   |r/w      |Channel 2: Brightness: 0..100                                          |\n-|channel3  |power        |Switch   |r/w      |Channel 3: Turn channel on/off                                         |\n-|          |brightness   |Dimmer   |r/w      |Channel 3: Brightness: 0..100                                          |\n-|channel4  |power        |Switch   |r/w      |Channel 4: Turn channel on/off                                         |\n-|          |brightness   |Dimmer   |r/w      |Channel 4: Brightness: 0..100                                          |\n-|meter1    |currentWatts |Number   |yes      |Channel 1: Current power consumption in Watts                          |\n-|meter2    |currentWatts |Number   |yes      |Channel 2: Current power consumption in Watts                          |\n-|meter3    |currentWatts |Number   |yes      |Channel 3: Current power consumption in Watts                          |\n-|meter4    |currentWatts |Number   |yes      |Channel 4: Current power consumption in Watts                          |\n+|channel3  |brightness   |Dimmer   |r/w      |Channel 3: Brightness: 0..100, control power state with ON/OFF         |\n+|          |button       |Trigger  |yes      |Event trigger with payload SHORT_PRESSED or LONG_PRESSED (FW 1.5.6+)   |\n+|          |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF command; in seconds|\n+|          |autoOff      |Number   |r/w      |Sets a  timer to turn the device OFF after every ON command; in seconds|\n+|          |timerActive  |Switch   |yes      |ON: An auto-on/off timer is active                                     |\n+|channel4  |brightness   |Dimmer   |r/w      |Channel 5: Brightness: 0..100, control power state with ON/OFF         |\n+|          |button       |Trigger  |yes      |Event trigger with payload SHORT_PRESSED or LONG_PRESSED (FW 1.5.6+)   |\n+|          |autoOn       |Number   |r/w      |Sets a  timer to turn the device ON after every OFF command; in seconds|\n+|          |autoOff      |Number   |r/w      |Sets a  timer to turn the device OFF after every ON command; in seconds|\n+|          |timerActive  |Switch   |yes      |ON: An auto-on/off timer is active                                     |\n+|meter     |currentWatts |Number   |yes      |Current power consumption in Watts (all channels)                                   |\n \n Please note that the settings of channel group color are only valid in color mode and vice versa for white mode.\n-The current firmware doesn't support the timestamp report for the meters.\n-In this case \"n/a\" is returned.\n-Maybe an upcoming firmware release adds this attribute, then the correct value is returned;\n+The current firmware doesn't support the timestamp report for the meters. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 385}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0MDUwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the device wakes up the thing does the initialization and the state changes to ONLINE.\n          \n          \n            \n            Once the device wakes up, the thing will perform initialization and the state will change to ONLINE.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410440509", "createdAt": "2020-04-17T19:58:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n+The device has a push button inside, open the case, press that button and the LED starts blinking.\n+The device should show up in the Inbox and can be added.\n+\n+`\n+Important: If device is in sleep mode and can't be reached by the binding, the Thing will change into UNKNOWN state.\n+Once the device wakes up the thing does the initialization and the state changes to ONLINE.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When you change the IP address for a specific reason you need to delete the Thing and re-discover the device.\n          \n          \n            \n            When the IP address changes for a device you need to delete the Thing and then re-discover the device.", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410444587", "createdAt": "2020-04-17T20:07:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/README.md", "diffHunk": "@@ -4,51 +4,86 @@ This Binding integrated Shelly devices.\n \n ## Supported Devices\n \n-|Thing               |Type                                                    |\n-|--------------------|--------------------------------------------------------|\n-| shelly1            | Shelly Single Relay Switch                             |\n-| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter |\n-| shellyem           | Shelly EM with integrated Power Meter                  |\n-| shelly2-relay      | Shelly Double Relay Switch in relay mode               |\n-| shelly2-roller     | Shelly2 in Roller Mode                                 |\n-| shelly25-relay     | Shelly 2.5 in Relay Switch                             |\n-| shelly25-roller    | Shelly 2.5 in Roller Mode                              |\n-| shelly4pro         | Shelly 4x Relay Switch                                 |\n-| shellydimmer       | Shelly Dimmer                                          |\n-| shellyplugs        | Shelly Plug-S                                          |\n-| shellyplug         | Shelly Plug                                            |\n-| shellyrgbw2        | Shelly RGB Controller                                  |\n-| shellybulb         | Shelly Bulb in Color or White Mode                     |\n-| shellyht           | Shelly Sensor (temp+humidity)                          |\n-| shellyflood        | Shelly Flood Sensor                                    |\n-| shellysmoke        | Shelly Smoke Sensor                                    |\n-| shellysense        | Shelly Motion and IR Controller                        |\n-| shellydevice       | A password protected Shelly device or an unknown type  |\n+| Thing Type         | Model                                                  | Vendor ID |\n+|--------------------|--------------------------------------------------------|-----------|\n+| shelly1            | Shelly Single Relay Switch                             | SHSW-1    |\n+| shelly1pm          | Shelly Single Relay Switch with integrated Power Meter | SHSW-PM   |\n+| shelly2-relay      | Shelly Double Relay Switch in relay mode               | SHSW-21   |\n+| shelly2-roller     | Shelly2 in Roller Mode                                 | SHSW-21   |\n+| shelly25-relay     | Shelly 2.5 in Relay Switch                             | SHSW-25   |\n+| shelly25-roller    | Shelly 2.5 in Roller Mode                              | SHSW-25   |\n+| shelly4pro         | Shelly 4x Relay Switch                                 | SHSW-44   |\n+| shellydimmer       | Shelly Dimmer                                          | SHDM-1    |\n+| shellyplug         | Shelly Plug                                            | SHPLG2-1  |\n+| shellyplugs        | Shelly Plug-S                                          | SHPLG-S   |\n+| shellyem           | Shelly EM with integrated Power Meters                 | SHEM      |\n+| shellyem3          | Shelly EM3 with 3 integrated Power Meter               | SHEM-3    |\n+| shellyrgbw2        | Shelly RGB Controller                                  | SHRGBW2   |\n+| shellybulb         | Shelly Bulb in Color or White Mode                     | SHBLB-1   |\n+| shellybulbduo      | Shelly Duo (White Mode)                                | SHBDUO-1  |\n+| shellyht           | Shelly Sensor (temp+humidity)                          | SHHT-1    |\n+| shellyflood        | Shelly Flood Sensor                                    | SHWT-1    |\n+| shellysmoke        | Shelly Smoke Sensor                                    |           |\n+| shellydw           |\u00a0Shelly Door/Window                                     | SHDW-1    |\n+| shellysense        | Shelly Motion and IR Controller                        | SHSEN-1   |\n+| shellydevice       | A password protected Shelly device or an unknown type  |           |\n \n ## Firmware\n \n-To utilize all features the binding requires firmware version 1.5.2 or newer.\n+To utilize all features the binding requires firmware version 1.5.7 or newer, version 1.6 is strongly recommended.\n This should be available for all devices.\n Older versions work in general, but have impacts to functionality (e.g. no events for battery powered devices).\n \n The binding displays a WARNING in the log if the firmware is older.\n It also informs you when an update is available.\n Use the device' web ui or the Shelly App to perform the update.\n \n+## Other resources\n+\n+Check the following resources for additional information\n+\n+\n ## Discovery\n \n The binding uses mDNS to discover the Shelly devices.\n They periodically announce their presence, which is used by the binding to find them on the local network.\n \n-Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n Sometimes you need to run the manual discovery multiple times until you see all your devices.\n \n+### Dynamic creation of channels\n+\n+The Shelly series of devices has many combinations of relays, meters (different versions), sensors etc. For this the binding creates various channels dynamically based on the status information provided by the device at initialization time. \n+If a channel is missing make sure the thing was discovered correctly and is ONLINE. If a channel is missing delete the thing and re-discover it.\n+\n+### Important for battery power devices\n+\n+Make sure to wake-up battery powered devices (press the button inside the device), so that they show up on the network.\n+The device has a push button inside, open the case, press that button and the LED starts blinking.\n+The device should show up in the Inbox and can be added.\n+\n+`\n+Important: If device is in sleep mode and can't be reached by the binding, the Thing will change into UNKNOWN state.\n+Once the device wakes up the thing does the initialization and the state changes to ONLINE.\n+`\n+\n+Once the device is discovered and initialized successful the binding is able to perform an auto-initialization when OH was restarted in between. The device wake-up triggers the event URL and/or CoIoT packet, which is processed by the binding and triggers the initialization.\n+So you don't need to manually wake-up the devices after an openHAB restart.\n+\n+Devices having no battery are expected to be ON/reachable on the network all the time.\n+Otherwise the thing will go OFFLINE with COMMUNICATION_ERROR as status.\n+\n+### Re-discover when IP address has changed\n+ \n Important: The IP address should not be changed after the device is added to openHAB.\n+\n This can be achieved by\n \n - assigning a static IP address or\n - using DHCP and setup the router to always assign the same IP address to the device\n \n+When you change the IP address for a specific reason you need to delete the Thing and re-discover the device.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a01f1148c8e74a4abcc1b7036224da00db917577", "committedDate": "2020-04-18T08:29:24Z", "message": "More changes from review (functional change to version detection and\nsetting action urls)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTIxMzAy", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-395921302", "createdAt": "2020-04-18T15:02:23Z", "commit": {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowMjoyM1rOGHrrgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQxNTowMzoxN1rOGHrsFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg2Ng==", "bodyText": "You forgot to change this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return;\n          \n          \n            \n                                continue;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410708866", "createdAt": "2020-04-18T15:02:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTAxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return;\n          \n          \n            \n                                    continue;", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410709012", "createdAt": "2020-04-18T15:03:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;\n+                }\n+                if (!profile.settingsJson.contains(test)) {\n+                    // Current Action URL is != new URL\n+                    request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n                 }\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n-            }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes)\n+            throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                if (profile.containsEventUrl(eventType)) {\n+                    String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                            + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+                    String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                    String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+                    if (!enabled && !profile.settingsJson.contains(test)) {\n+                        // Don't set URL to null when the current one doesn't point to this OH\n+                        // Don't interfere with a 3rd party App\n+                        return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577"}, "originalPosition": 569}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91cc31f87382af1c14776d2abb07f329c183d9f6", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/91cc31f87382af1c14776d2abb07f329c183d9f6", "committedDate": "2020-04-18T16:30:57Z", "message": "change fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a60d58e444374efd2752e20d213886e0e50a7330", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a60d58e444374efd2752e20d213886e0e50a7330", "committedDate": "2020-04-18T20:31:46Z", "message": "synchronize start()\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTQ5MzI4", "url": "https://github.com/openhab/openhab-addons/pull/6985#pullrequestreview-395949328", "createdAt": "2020-04-18T20:42:48Z", "commit": {"oid": "a60d58e444374efd2752e20d213886e0e50a7330"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a11489005e446da3c7f7886065a3a5d42a4acc72", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a11489005e446da3c7f7886065a3a5d42a4acc72", "committedDate": "2020-04-18T20:45:52Z", "message": "synchronized added to start/stop\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1387, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}