{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwOTQ5Mjk2", "number": 6961, "title": "[paradoxalarm] Encryption support, partition commands support and refactoring", "bodyText": "Encryption support\nUpdated README\nImproved logging in many classes\nAdded communicationState channel which shows the bridge connection\nstate to the Paradox system\nChanged the priority of parameter panelType. Now the parameter is with\nhigher priority, i.e. if you provide valid panelType autodiscovery of\npanel type will not be executed, saving initial connection time.\nRenamed several classes and interfaces to reflect more properly their\nusage\nRenamed methods to reflect their usage better\nImproved lifecycle of model objects in case of disposal of bridge\nhandler\nSplit the contents of the packet into two classes - packet and inner\nclass header which holds the header parts.\nAdded listener interface (IResponseReceiver) for response receiving,\ni.e. when response is received it is returned to the original sender by\nusing this interface.\nParsing and decrypting of packets payload is now done inside the\nPacket object (before it was in the communicator)\nAdded handling of wrong packet response, i.e. live event which we\ndon't parse right now because we don't know what it means and how to\nparse it.\nImproved overall handling of asynchronous situations when data may not\nhave been received but update is triggered (NPE, etc).\nAdded more default values to non-mandatory parameters. Classified\nmandatory parameters as mandatory in bridge XML\nImplemented argument handler for main method which is used for testing\nof model as java application.\nSome unit tests\n\nSigned-off-by: Konstantin Polihronov polychronov@gmail.com", "createdAt": "2020-02-04T17:02:48Z", "url": "https://github.com/openhab/openhab-addons/pull/6961", "merged": true, "mergeCommit": {"oid": "08303a00775baf0c5e25bfb678f81da09f611806"}, "closed": true, "closedAt": "2020-06-02T17:15:46Z", "author": {"login": "theater"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDpkyugBqjMwMzE2OTg0NzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnYHUvgFqTQyMjg5MDM2NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d8f8049c03c116e12ff2b84af3dde3e7e46bf9e", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/2d8f8049c03c116e12ff2b84af3dde3e7e46bf9e", "committedDate": "2020-02-12T17:08:05Z", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "committedDate": "2020-02-12T17:13:36Z", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "committedDate": "2020-02-12T17:13:36Z", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "135bc3255dc4a98db0c85086440bb78b0d72a624", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/135bc3255dc4a98db0c85086440bb78b0d72a624", "committedDate": "2020-02-12T17:30:28Z", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ccd65bc77bedfd7cedf8fc06d877d4b6c75bf8e", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/5ccd65bc77bedfd7cedf8fc06d877d4b6c75bf8e", "committedDate": "2020-02-27T17:01:04Z", "message": "Refactoring and fixes\n\n* Refactored two panel channels names\n* Fixed issue where channel was renamed before but not everywhere in the\ncode\n* Fixed potential issue caused by wrongly used brackets in\nAbstractParser which may cause issue due to operations priority\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "committedDate": "2020-02-27T17:02:10Z", "message": "Refactoring and fixes\n\n* Refactored two panel channels names\n* Fixed issue where channel was renamed before but not everywhere in the\ncode\n* Fixed potential issue caused by wrongly used brackets in\nAbstractParser which may cause issue due to operations priority\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODE1MjI4", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-370815228", "createdAt": "2020-03-08T09:09:11Z", "commit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwOTowOToxMlrOFzUC9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxMDozMzoyNFrOFzUaHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDEzMw==", "bodyText": "Why? Wouldn't it make sense to have the bridge reflect the communication status?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389350133", "createdAt": "2020-03-08T09:09:12Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/README.md", "diffHunk": "@@ -18,32 +18,35 @@ Currently binding supports the following panels: EVO192, EVO48(not tested), EVO9\n | Thing      | Thing Type | Description                                                    |\r\n |------------|------------|----------------------------------------------------------------|\r\n | ip150      | Bridge     | The bridge is used to communicate with IP150 ethernet module attached to Paradox security system.|\r\n-| panel      | Thing      | this is representation of Paradox panel. Has the general information about the main panel module, i.e. serial number, firmware/hardware/software versions, panel type, etc...|\r\n-| partition  | Thing      | provides \"state\"(armed, disarmed, in alarm), \"partition label\" and \"additional states\" are aggregated additional states which are booleans (ready to arm, trouble, force instant arm ready, etc...)|\r\n-| zone       | Thing      | Paradox zone. Can be anything - magnetic, motion or any other opened/closed sensor. State channel is contact, low battery and is tampered channels are switch, label is String |\r\n+| panel      | Thing      | This is representation of Paradox panel. Has the general information about the main panel module, i.e. serial number, firmware/hardware/software versions, panel type, etc...|\r\n+| partition  | Thing      | The partition is grouped aggregation of multiple zones. It's also referred in Paradox Babyware as \"Area\". |\r\n+| zone       | Thing      | Paradox zone. Can be anything - magnetic, motion or any other opened/closed sensor. State channel is contact, \"low battery\" and \"is tampered\" channels are switch, label is String |\r\n \r\n ## Things configuration\r\n \r\n ### IP150 bridge parameters\r\n \r\n | Parameter         | Description                            |\r\n |-------------------|----------------------------------------|\r\n-| refresh           | Value is in seconds. Defines the refresh interval when the binding polls from paradox system.|\r\n-| ip150Password     | The password to your IP150 (not your panel PIN).|\r\n-| pcPassword        | The code 3012 setting. Default value is 0000.|\r\n-| ipAddress         | IP address of your IP150.|\r\n-| port              | The port used for data communication. Default value is 10000.|\r\n-| panelType         | Optional parameter. Will be used if discovery does not identify the panel. Otherwise provide EVO48, EVO96, EVO192, etc...|\r\n-| reconnectWaitTime | Value is in seconds. The time to wait before a reconnect occurs after socket timeout.|\r\n-| maxPartitions     | Optional parameter which sets maximum partitions to use during refresh. If not set, maximum allowed amount from panelType will be used.|\r\n-| maxZones          | Optional parameter which sets maximum zones to use during refresh. If not set, maximum allowed amount from panelType will be used.|\r\n+| refresh           | Value is in seconds. Defines the refresh interval when the binding polls from paradox system. Optional parameter. Default 5 seconds.|\r\n+| ip150Password     | The password to your IP150 (not your panel PIN). Mandatory parameter.  |\r\n+| pcPassword        | The panel programming code 3012 setting. Optional parameter. Default value is 0000.|\r\n+| ipAddress         | IP address or hostname of your IP150. If hostname is used must be resolvable by OpenHAB. Mandatory parameter.  |\r\n+| port              | The port used for data communication. Optional parameter. Default value is 10000.|\r\n+| panelType         | If parameter is passed, auto-discovery of panel type will be skipped. Provide string - EVO48, EVO96, EVO192, etc... Optional parameter. |\r\n+| reconnectWaitTime | Value is in seconds. The time to wait before a reconnect occurs after socket timeout. Optional parameter. Default value is 30 seconds.|\r\n+| maxPartitions     | Sets maximum partitions to use during refresh. If not set, maximum allowed amount from panelType will be used. Optional parameter. |\r\n+| maxZones          | Sets maximum zones to use during refresh. If not set, maximum allowed amount from panelType will be used. Optional parameter.|\r\n+| encrypt           | Sets if encryption has to be used. Optional parameter. Default value is false |\r\n \r\n ### IP150 bridge channels\r\n \r\n | Channel             | Description                                    |\r\n |---------------------|------------------------------------------------|\r\n |communicationCommand | Possible values [LOGOUT, LOGIN, RESET]         |\r\n+|communicationState   | Shows the communication status to Paradox. Different from Bridge status. Bridge may be online and able to receive commands but communication may be offline due to various reasons. Possible values [Offline, Online] |\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDM4Nw==", "bodyText": "What sense does it make to pass a password and not use it?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389350387", "createdAt": "2020-03-08T09:12:23Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/AbstractCommunicator.java", "diffHunk": "@@ -60,10 +53,11 @@\n \n     private boolean isOnline;\n \n-    public AbstractCommunicator(String ipAddress, int tcpPort, ScheduledExecutorService scheduler)\n+    public AbstractCommunicator(String ipAddress, int tcpPort, String password, ScheduledExecutorService scheduler)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDYwNw==", "bodyText": "How can it be that the receiver is null? And is this an error state? If so, please log something.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389350607", "createdAt": "2020-03-08T09:15:19Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/AbstractCommunicator.java", "diffHunk": "@@ -141,111 +139,43 @@ protected void receivePacket() {\n             int readBytes = rx.read(result);\n             if (readBytes > 0 && result[1] > 0 && result[1] + 16 < 256) {\n                 logger.trace(\"Successfully read valid packet from Rx\");\n-                retryCounter = 0;\n                 IRequest request = syncQueue.poll();\n-                byte[] bytesData = Arrays.copyOfRange(result, 0, result[1] + 16);\n-                IResponse response = new Response(request, bytesData);\n-                handleReceivedPacket(response);\n+                byte[] bytesData = Arrays.copyOfRange(result, 0, readBytes);\n+                IResponse response = new Response(request, bytesData, isEncrypted());\n+\n+                if (response.getPayload() == null || response.getHeader() == null) {\n+                    handleWrongPacket(result, request);\n+                }\n+\n+                IResponseReceiver responseReceiver = request.getResponseReceiver();\n+                if (responseReceiver != null) {\n+                    responseReceiver.receiveResponse(response, this);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NDc0OA==", "bodyText": "Why is this check not needed anymore?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389354748", "createdAt": "2020-03-08T10:13:17Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/EvoCommunicator.java", "diffHunk": "@@ -314,26 +326,30 @@ private void initializeEpromData() {\n         private int tcpPort = 10000;\r\n         private String pcPassword = \"0000\";\r\n \r\n+        private boolean useEncryption;\r\n+\r\n         EvoCommunicatorBuilder(PanelType panelType) {\r\n             this.panelType = panelType;\r\n         }\r\n \r\n         @Override\r\n         public IParadoxCommunicator build() {\r\n-            if (panelType != PanelType.EVO48 && panelType != PanelType.EVO96 && panelType != PanelType.EVO192) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NTE1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Payload should not not be null or empty !\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"Payload should not be null or empty !\");", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389355158", "createdAt": "2020-03-08T10:19:31Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not not be null or empty !\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NTg1OQ==", "bodyText": "Why not use HexUtils.bytestoHex  from the core?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389355859", "createdAt": "2020-03-08T10:30:05Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -54,27 +56,54 @@ public static void printPacket(String description, byte[] array) {\n         }\r\n     }\r\n \r\n-    private static void printByteArray(String description, byte[] array, int length) {\r\n-        if (description != null && !description.isEmpty()) {\r\n-            logger.trace(\"{}\", description);\r\n+    public static void printByteArray(String description, byte[] array) {\r\n+        if (array == null) {\r\n+            logger.trace(\"Array is null\");\r\n+            return;\r\n         }\r\n-        int countBytes = 0;\r\n-        String result = \"\";\r\n-        for (int index = 0; index < length; index++) {\r\n-            countBytes++;\r\n-            String st = String.format(\"0x%02X,\\t\", array[index]);\r\n-            result += st;\r\n-            if (countBytes > 7) {\r\n-                logger.trace(result);\r\n-                countBytes = 0;\r\n-                result = \"\";\r\n-                continue;\r\n-            }\r\n+        printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    public static void printByteArray(String description, byte[] array, int length) {\r\n+        if (!logger.isTraceEnabled()) {\r\n+            return;\r\n         }\r\n+\r\n+        String result = byteArrayToString(array, length);\r\n         if (!result.isEmpty()) {\r\n-            logger.trace(result);\r\n+            logger.trace(\"{}\", description + SPACE_DELIMITER + result);\r\n         }\r\n+    }\r\n \r\n+    public static String byteArrayToString(byte[] array) {\r\n+        return byteArrayToString(array, array.length);\r\n+    }\r\n+\r\n+    /**\r\n+     *\r\n+     * Returns passed array as HEX string. On every 8 bytes we put space for better readability. Example 16\r\n+     * bytes array output: AA47000263000000 03EE00EEEEEEB727\r\n+     *\r\n+     * @param array\r\n+     * @param length\r\n+     * @return String\r\n+     */\r\n+    public static String byteArrayToString(byte[] array, int length) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NjA2Mg==", "bodyText": "No need for required=\"false\" if you provide a default", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389356062", "createdAt": "2020-03-08T10:33:24Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/resources/ESH-INF/thing/ip150connector.xml", "diffHunk": "@@ -58,6 +61,11 @@\n \t\t\t\t<description>Maximum number of configured partitions to check (from partition 1 to maxPartitions)</description>\r\n \t\t\t\t<default>0</default>\r\n \t\t\t</parameter>\r\n+\t\t\t<parameter name=\"encrypt\" type=\"boolean\" required=\"false\">\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6ea3da57d028145fda9ddfe18092406fc0f3cae0", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/6ea3da57d028145fda9ddfe18092406fc0f3cae0", "committedDate": "2020-03-08T14:15:56Z", "message": "Changes based on JNK's review #1\n\n* Remove leftover unnecessary parameter password from\nAbstractCommunicator\n* Remove required=false wherever we have default values in thing\ndefinitions.\n* Fix exception message in EncryptionHandler\n* Clean up imports in Response.java\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "372996f4f068f3fc11b5c95e97dd281411887d83", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/372996f4f068f3fc11b5c95e97dd281411887d83", "committedDate": "2020-03-10T17:12:03Z", "message": "Changes based on JNK's review #1\n\n* Remove leftover unnecessary parameter password from\nAbstractCommunicator\n* Remove required=false wherever we have default values in thing\ndefinitions.\n* Fix exception message in EncryptionHandler\n* Clean up imports in Response.java\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70407be6157b579ec3bd4f5a1f6f62b138bd50ce", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/70407be6157b579ec3bd4f5a1f6f62b138bd50ce", "committedDate": "2020-05-04T15:14:30Z", "message": "Fix formatting of some files\n\n* mvn spotless:apply on the whole project\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/da6e378ec528d5669c07fda967a32cdd58d11180", "committedDate": "2020-05-06T15:04:14Z", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDMxMjUx", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-416431251", "createdAt": "2020-05-21T19:32:17Z", "commit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMjoxN1rOGZAAUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMjo1MjozNVrOGZJGIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY2NQ==", "bodyText": "Please apply openHab's Units of Measurement framework wherever applicable. This allows user interfaces greater flexibility when it comes to rendering data from your binding.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:ElectricPotential</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428867665", "createdAt": "2020-05-21T19:32:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/resources/ESH-INF/thing/panel.xml", "diffHunk": "@@ -60,5 +64,17 @@\n \t\t<description>Boot loader version</description>\n \t\t<state readOnly=\"true\" pattern=\"%s\"/>\n \t</channel-type>\n+\t<channel-type id=\"voltage\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODI0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static byte[] copyArray(int[] input) {\n          \n          \n            \n                public static byte[] toByteArray(int[] input) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428868243", "createdAt": "2020-05-21T19:33:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -131,4 +161,69 @@ public static byte getLowNibble(byte value) {\n         }\n         return result;\n     }\n+\n+    /**\n+     * This method fills array with 0xEE based on rate.\n+     * Example: If input array length is 5 and rate is 8 the array will be extended with 3 more bytes filled with 0xEE\n+     *\n+     * @param inputArray\n+     * @param rate\n+     * @return byte[]\n+     */\n+    public static byte[] extendArray(byte[] inputArray, int rate) {\n+        if (inputArray == null || inputArray.length % rate == 0) {\n+            return inputArray;\n+        }\n+\n+        final int newLength = inputArray.length + (rate - inputArray.length % rate);\n+        byte[] result = new byte[newLength];\n+        for (int i = 0; i < result.length; i++) {\n+            if (i < inputArray.length) {\n+                result[i] = inputArray[i];\n+            } else {\n+                result[i] = (byte) 0xEE;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns bytes from string with standard US_ASCII standard charset to ensure everywhere in the binding we use same\n+     * charset.\n+     *\n+     * @param str\n+     * @return byte[]\n+     *\n+     */\n+    public static byte[] getBytesFromString(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"String must not be null !\");\n+        }\n+\n+        return str.getBytes(StandardCharsets.US_ASCII);\n+    }\n+\n+    public static int[] copyArray(byte[] input) {\n+        if (input == null) {\n+            throw new IllegalArgumentException(\"Input array must not be null\");\n+        }\n+        int[] result = new int[input.length];\n+        for (int i = 0; i < input.length; i++) {\n+            result[i] = input[i] & 0xFF;\n+        }\n+\n+        return result;\n+    }\n+\n+    public static byte[] copyArray(int[] input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODI5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static int[] copyArray(byte[] input) {\n          \n          \n            \n                public static int[] toIntArray(byte[] input) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428868293", "createdAt": "2020-05-21T19:33:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -131,4 +161,69 @@ public static byte getLowNibble(byte value) {\n         }\n         return result;\n     }\n+\n+    /**\n+     * This method fills array with 0xEE based on rate.\n+     * Example: If input array length is 5 and rate is 8 the array will be extended with 3 more bytes filled with 0xEE\n+     *\n+     * @param inputArray\n+     * @param rate\n+     * @return byte[]\n+     */\n+    public static byte[] extendArray(byte[] inputArray, int rate) {\n+        if (inputArray == null || inputArray.length % rate == 0) {\n+            return inputArray;\n+        }\n+\n+        final int newLength = inputArray.length + (rate - inputArray.length % rate);\n+        byte[] result = new byte[newLength];\n+        for (int i = 0; i < result.length; i++) {\n+            if (i < inputArray.length) {\n+                result[i] = inputArray[i];\n+            } else {\n+                result[i] = (byte) 0xEE;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns bytes from string with standard US_ASCII standard charset to ensure everywhere in the binding we use same\n+     * charset.\n+     *\n+     * @param str\n+     * @return byte[]\n+     *\n+     */\n+    public static byte[] getBytesFromString(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"String must not be null !\");\n+        }\n+\n+        return str.getBytes(StandardCharsets.US_ASCII);\n+    }\n+\n+    public static int[] copyArray(byte[] input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MTc1Mg==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428941752", "createdAt": "2020-05-21T22:05:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/PartitionCommand.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PartitionCommand} Enum representing the possible commands for a partition with the respective integer\n+ * values that are sent as nibbles in the packet.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public enum PartitionCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MjA5OA==", "bodyText": "I prefer static final", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428942098", "createdAt": "2020-05-21T22:06:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/MemoryRequestPayload.java", "diffHunk": "@@ -22,16 +22,16 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link EpromRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n+ * The {@link MemoryRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n  * classes.\n  *\n  * @author Konstantin Polihronov - Initial contribution\n  */\n-public abstract class MemoryRequestPayload implements IPPacketPayload {\n+public abstract class MemoryRequestPayload implements IPayload {\n \n     private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\n \n-    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\n+    private final static short MESSAGE_START = (short) ((0x50 << 8) | 0x08);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNTAxNQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429005015", "createdAt": "2020-05-22T02:00:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNTc2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int r = 1; r < rounds; r++) {\n          \n          \n            \n                            sBox(a, s);\n          \n          \n            \n                            shiftRow(a, 0);\n          \n          \n            \n                            mixColumn(a);\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                        }\n          \n          \n            \n                        sBox(a, s);\n          \n          \n            \n                        shiftRow(a, 0);\n          \n          \n            \n                        keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n          \n          \n            \n                        for (int r = 1; r <= rounds; r++) {\n          \n          \n            \n                            sBox(a, s);\n          \n          \n            \n                            shiftRow(a, 0);\n          \n          \n            \n                            if(r != rounds){\n          \n          \n            \n                                mixColumn(a);\n          \n          \n            \n                            }\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429005768", "createdAt": "2020-05-22T02:04:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNjI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n          \n          \n            \n                        sBox(a, si);\n          \n          \n            \n                        shiftRow(a, 1);\n          \n          \n            \n            \n          \n          \n            \n                        for (int r = rounds - 1; r > 0; r--) {\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                            invMixColumn(a);\n          \n          \n            \n                            sBox(a, si);\n          \n          \n            \n                            shiftRow(a, 1);\n          \n          \n            \n                        }\n          \n          \n            \n                        for (int r = rounds; r > 0; r--) {\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                            if(r != rounds){\n          \n          \n            \n                                invMixColumn(a);\n          \n          \n            \n                            }\n          \n          \n            \n                            sBox(a, si);\n          \n          \n            \n                            shiftRow(a, 1);\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429006258", "createdAt": "2020-05-22T02:06:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTAxNQ==", "bodyText": "The final assignment q = z serves no useful purpose here since the method returns the next line. This code is wrong. I suspect this code is somehow not arranged correctly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nThat said, this is very convoluted for something that can be written much simpler.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0 | c == 0) {\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429011015", "createdAt": "2020-05-22T02:28:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTM2NQ==", "bodyText": "get rid of this variable and use literals instead.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429011365", "createdAt": "2020-05-22T02:29:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng==", "bodyText": "This class is not thread safe, and as such you should not provide a singleton instance for it.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429012646", "createdAt": "2020-05-22T02:35:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzIzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void mixColumn(int[] a) {\n          \n          \n            \n                private static void mixColumn(int[] a) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013231", "createdAt": "2020-05-22T02:38:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzMxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void sBox(int[] a, int[] box) {\n          \n          \n            \n                private static void sBox(int[] a, int[] box) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013318", "createdAt": "2020-05-22T02:38:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzY2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void shiftRow(int[] a, int d) {\n          \n          \n            \n                private static void shiftRow(int[] a, int d) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013668", "createdAt": "2020-05-22T02:39:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\n+\n+        int[] b = new int[] { 0, 0, 0, 0 };\n+        for (int j = 0; j < 4; j++) {\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\n+            for (int i = 0; i < 4; i++) {\n+                b[i] = a[i * 4 + j];\n+            }\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\n+\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i];\n+            }\n+        }\n+    }\n+\n+    private void invMixColumn(int[] a) {\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\n+            }\n+        }\n+\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i][j];\n+            }\n+        }\n+    }\n+\n+    private void shiftRow(int[] a, int d) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzc5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void keyAddition(int[] a, int[] rk) {\n          \n          \n            \n                private static void keyAddition(int[] a, int[] rk) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013790", "createdAt": "2020-05-22T02:40:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\n+\n+        int[] b = new int[] { 0, 0, 0, 0 };\n+        for (int j = 0; j < 4; j++) {\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\n+            for (int i = 0; i < 4; i++) {\n+                b[i] = a[i * 4 + j];\n+            }\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\n+\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i];\n+            }\n+        }\n+    }\n+\n+    private void invMixColumn(int[] a) {\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\n+            }\n+        }\n+\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i][j];\n+            }\n+        }\n+    }\n+\n+    private void shiftRow(int[] a, int d) {\n+        int[] tmpArray = new int[] { 0, 0, 0, 0 };\n+        for (int i = 1; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                int[][][] shifts = EncryptionHandlerConstants.SHIFTS;\n+                int index = i * 4 + (j + shifts[0][i][d]) % 4;\n+                tmpArray[j] = a[index];\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                a[i * 4 + j] = tmpArray[j];\n+            }\n+        }\n+    }\n+\n+    private void keyAddition(int[] a, int[] rk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDAyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte[] fillArray(byte[] keyBytes) {\n          \n          \n            \n                private static byte[] fillArray(byte[] keyBytes) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014026", "createdAt": "2020-05-22T02:41:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDE4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void printArray(String description, byte[] array) {\n          \n          \n            \n                private static void printArray(String description, byte[] array) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014188", "createdAt": "2020-05-22T02:41:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDczOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                \n          \n          \n            \n                static{\n          \n          \n            \n                    generateTables();\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014739", "createdAt": "2020-05-22T02:44:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNTI1NQ==", "bodyText": "If you initialize the tables statically, you can remove this constructor.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429015255", "createdAt": "2020-05-22T02:46:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNTc0Mg==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429015742", "createdAt": "2020-05-22T02:48:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/IResponseReceiver.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication;\n+\n+/**\n+ * The {@link IResponseReceiver} Used to pass parsed responses from Paradox to original senders of the requests for\n+ * further processing.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public interface IResponseReceiver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNjYwOQ==", "bodyText": "Yeah, I'm not going to heed that. If you are trying to avoid IP issues it is best to change a much as possible.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429016609", "createdAt": "2020-05-22T02:52:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/da6e378ec528d5669c07fda967a32cdd58d11180", "committedDate": "2020-05-06T15:04:14Z", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "ae8309737c847d5d7e8c0d26e531295bca179e4d", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/ae8309737c847d5d7e8c0d26e531295bca179e4d", "committedDate": "2020-05-22T13:36:17Z", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzgyMzQw", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-418782340", "createdAt": "2020-05-27T01:04:01Z", "commit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMTowNDowMVrOGa1QRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMTowNDowMVrOGa1QRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODY3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (i % 8 == 0) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                            int tmp = temp[0];\n          \n          \n            \n            \n          \n          \n            \n                            for (int j = 1; j < 4; j++) {\n          \n          \n            \n                                temp[j - 1] = temp[j];\n          \n          \n            \n                            }\n          \n          \n            \n            \n          \n          \n            \n                            temp[3] = tmp;\n          \n          \n            \n                            temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n          \n          \n            \n                        } else if (i % 8 == 4) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (i % 4 == 0) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (i % 8 == 0) {\n          \n          \n            \n                            int tmp = temp[0];\n          \n          \n            \n            \n          \n          \n            \n                            for (int j = 1; j < 4; j++) {\n          \n          \n            \n                                temp[j - 1] = temp[j];\n          \n          \n            \n                            }\n          \n          \n            \n            \n          \n          \n            \n                            temp[3] = tmp;\n          \n          \n            \n                            temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430788678", "createdAt": "2020-05-27T01:04:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler();\r\n+\r\n+    private int[] lTable = new int[TABLE_SIZE];\r\n+    private int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler() {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized void updateKey(byte[] newKey) {\r\n+        expandedKey = new int[KEY_LENGTH];\r\n+        expandKey(newKey);\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            } else if (i % 8 == 4) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4Nzg4OTA0", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-418788904", "createdAt": "2020-05-27T01:09:48Z", "commit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMTowOTo0OFrOGa1V8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMToxMToyNlrOGa1Xug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDEyOA==", "bodyText": "Why not just use a ByteBuffer here instead? You are already using one to append the payloadLength. Another option is to wrap your ByteArrayOutputStream in a DataOutputStream and use that to append short values and the like.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430790128", "createdAt": "2020-05-27T01:09:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/ParadoxIPPacket.java", "diffHunk": "@@ -26,173 +26,128 @@\n  *\n  * @author Konstantin Polihronov - Initial contribution\n  */\n-public class ParadoxIPPacket implements IPPacketPayload {\n+public class ParadoxIPPacket implements IPPacket {\n \n     public static final byte[] EMPTY_PAYLOAD = new byte[0];\n \n-    /**\n-     * Start of header - always 0xAA\n-     */\n-    private byte startOfHeader = (byte) 0xAA;\n-\n-    /**\n-     * Payload length - 2 bytes (LL HH)\n-     */\n-    private short payloadLength = 0;\n-\n-    /**\n-     * \"Message Type: 0x01: IP responses 0x02: Serial/pass through cmd response\n-     * 0x03: IP requests 0x04: Serial/pass through cmd requests\"\n-     */\n-    private byte messageType = 0x03;\n-\n-    /**\n-     * \"IP Encryption 0x08: Disabled 0x09: Enabled\"\n-     */\n-    private byte encryption = 0x08;\n-    private byte command = 0;\n-    private byte subCommand = 0;\n-    private byte unknown0 = 0x0A;\n-\n-    /**\n-     * Padding bytes to fill the header to 16 bytes with 0xEE.\n-     */\n-    private long theRest = 0xEEEEEEEEEEEEEEEEl;\n+    private PacketHeader header;\n     private byte[] payload;\n-    private boolean isChecksumRequired;\n \n-    public ParadoxIPPacket(IPPacketPayload payload) {\n-        this(payload.getBytes(), true);\n-    }\n-\n-    public ParadoxIPPacket(String payload, boolean isChecksumRequired) {\n-        this(payload.getBytes(StandardCharsets.US_ASCII), isChecksumRequired);\n+    public ParadoxIPPacket(byte[] bytes) {\n+        this(bytes, true);\n     }\n \n+    @SuppressWarnings(\"null\")\n     public ParadoxIPPacket(byte[] payload, boolean isChecksumRequired) {\n-        this.isChecksumRequired = isChecksumRequired;\n-\n-        if (payload == null) {\n-            this.payload = new byte[0];\n-            this.payloadLength = 0;\n-        } else {\n-            this.payload = payload;\n-            this.payloadLength = (short) payload.length;\n+        this.payload = payload != null ? payload : new byte[0];\n+        if (isChecksumRequired) {\n+            payload[payload.length - 1] = ParadoxUtil.calculateChecksum(payload);\n         }\n-\n-        // TODO: Figure out how to fill up to 16, 32, 48, etc sizes with 0xEE\n-        // if (payload.length < 16) {\n-        // this.payload = extendPayload(16, payload);\n-        // } else {\n-        // }\n+        short payloadLength = (short) (payload != null ? payload.length : 0);\n+        header = new PacketHeader(payloadLength);\n     }\n \n     @Override\n     public byte[] getBytes() {\n         try {\n             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n \n-            outputStream.write(startOfHeader);\n-            outputStream.write(ByteBuffer.allocate(Short.SIZE / Byte.SIZE).order(ByteOrder.LITTLE_ENDIAN)\n-                    .putShort(payloadLength).array());\n-            outputStream.write(messageType);\n-            outputStream.write(encryption);\n-            outputStream.write(command);\n-            outputStream.write(subCommand);\n-            outputStream.write(unknown0);\n-            outputStream.write(ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(theRest).array());\n+            outputStream.write(header.getBytes());\n             outputStream.write(payload);\n             byte[] byteArray = outputStream.toByteArray();\n \n-            if (isChecksumRequired) {\n-                byteArray[byteArray.length - 1] = ParadoxUtil.calculateChecksum(payload);\n-            }\n-\n             return byteArray;\n         } catch (IOException e) {\n             throw new ParadoxRuntimeException(\"Unable to create byte array stream.\", e);\n         }\n     }\n \n-    public byte getStartOfHeader() {\n-        return startOfHeader;\n-    }\n-\n-    public ParadoxIPPacket setStartOfHeader(byte startOfHeader) {\n-        this.startOfHeader = startOfHeader;\n-        return this;\n-    }\n-\n-    public short getPayloadLength() {\n-        return payloadLength;\n-    }\n-\n-    public ParadoxIPPacket setPayloadLength(short payloadLength) {\n-        this.payloadLength = payloadLength;\n-        return this;\n-    }\n-\n-    public byte getMessageType() {\n-        return messageType;\n-    }\n-\n-    public ParadoxIPPacket setMessageType(byte messageType) {\n-        this.messageType = messageType;\n+    public ParadoxIPPacket setCommand(HeaderCommand command) {\n+        header.command = command.getValue();\n         return this;\n     }\n \n     public ParadoxIPPacket setMessageType(HeaderMessageType messageType) {\n-        this.messageType = messageType.getValue();\n+        header.messageType = messageType.getValue();\n         return this;\n     }\n \n-    public byte getEncryption() {\n-        return encryption;\n-    }\n-\n-    public ParadoxIPPacket setEncryption(byte encryption) {\n-        this.encryption = encryption;\n+    public ParadoxIPPacket setUnknown0(byte unknownByteValue) {\n+        header.unknown0 = unknownByteValue;\n         return this;\n     }\n \n-    public byte getCommand() {\n-        return command;\n-    }\n-\n-    public ParadoxIPPacket setCommand(HeaderCommand command) {\n-        this.command = command.getValue();\n-        return this;\n-    }\n-\n-    public ParadoxIPPacket setCommand(byte command) {\n-        this.command = command;\n-        return this;\n+    @Override\n+    public PacketHeader getHeader() {\n+        return header;\n     }\n \n-    public byte getSubCommand() {\n-        return subCommand;\n+    @Override\n+    public byte[] getPayload() {\n+        return payload;\n     }\n \n-    public ParadoxIPPacket setSubCommand(byte subCommand) {\n-        this.subCommand = subCommand;\n-        return this;\n+    @Override\n+    public void encrypt() {\n+        EncryptionHandler encryptionHandler = EncryptionHandler.getInstance();\n+        payload = encryptionHandler.encrypt(payload);\n+        header.encryption = 0x09;\n     }\n \n-    public byte getUnknown0() {\n-        return unknown0;\n+    @Override\n+    public String toString() {\n+        return \"ParadoxIPPacket [\" + ParadoxUtil.byteArrayToString(getBytes()) + \"]\";\n     }\n \n-    public ParadoxIPPacket setUnknown0(byte unknown0) {\n-        this.unknown0 = unknown0;\n-        return this;\n-    }\n+    public class PacketHeader {\n \n-    public long getTheRest() {\n-        return theRest;\n-    }\n+        public PacketHeader(short payloadLength) {\n+            this.payloadLength = payloadLength;\n+        }\n \n-    public ParadoxIPPacket setTheRest(long theRest) {\n-        this.theRest = theRest;\n-        return this;\n+        /**\n+         * Start of header - always 0xAA\n+         */\n+        private byte startOfHeader = (byte) 0xAA;\n+\n+        /**\n+         * Payload length - 2 bytes (LL HH)\n+         */\n+        private short payloadLength = 0;\n+\n+        /**\n+         * \"Message Type: 0x01: IP responses 0x02: Serial/pass through cmd response\n+         * 0x03: IP requests 0x04: Serial/pass through cmd requests\"\n+         */\n+        private byte messageType = 0x03;\n+\n+        /**\n+         * \"IP Encryption 0x08: Disabled 0x09: Enabled\"\n+         */\n+        private byte encryption = 0x08;\n+        private byte command = 0;\n+        private byte subCommand = 0;\n+        private byte unknown0 = 0x00;\n+        private byte unknown1 = 0x01;\n+\n+        public byte[] getBytes() {\n+            try {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDU4Ng==", "bodyText": "Make sure to cancel this delayed future when the handler is disposed", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430790586", "createdAt": "2020-05-27T01:11:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/EntityBaseHandler.java", "diffHunk": "@@ -44,32 +46,51 @@ public EntityBaseHandler(Thing thing) {\n \n     @Override\n     public void initialize() {\n-        logger.debug(\"Start initializing. {}\", thing.getLabel());\n+        logger.trace(\"Start initializing. {}\", thing.getUID());\n         updateStatus(ThingStatus.UNKNOWN);\n \n         config = getConfigAs(EntityConfiguration.class);\n \n+        timeStamp = System.currentTimeMillis();\n         scheduler.schedule(this::initializeDelayed, INITIAL_DELAY_SECONDS, TimeUnit.SECONDS);\n     }\n \n     private void initializeDelayed() {\n-        logger.trace(\"Start initializeDelayed() in {}\", getThing().getUID());\n+        logger.debug(\"Start initializeDelayed() in {}\", getThing().getUID());\n         ParadoxPanel panel = ParadoxPanel.getInstance();\n-        if (!panel.isPanelSupported()) {\n+        // Asynchronous update not yet done\n+        if (panel.getPanelInformation() == null) {\n+            // Retry until reach MAX_WAIT_TIME\n+            if (System.currentTimeMillis() - timeStamp <= MAX_WAIT_TIME_MILLIS) {\n+                logger.debug(\"Panel information is null. Scheduling initializeDelayed() to be executed again in {} sec\",\n+                        INITIAL_DELAY_SECONDS);\n+                scheduler.schedule(this::initializeDelayed, INITIAL_DELAY_SECONDS, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e773f2dda059bf04500bc0e6b54881701bb6619", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/3e773f2dda059bf04500bc0e6b54881701bb6619", "committedDate": "2020-05-27T09:47:35Z", "message": "Encryption support flattened and rebased\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f11ba9e391fc01ec542c301254d186c559f9a9ee", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/f11ba9e391fc01ec542c301254d186c559f9a9ee", "committedDate": "2020-05-27T09:47:38Z", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3eff46fc23b4fe9b193b9dc6715cf750a94e03", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/8d3eff46fc23b4fe9b193b9dc6715cf750a94e03", "committedDate": "2020-05-27T09:50:11Z", "message": "Cosmetic changes based on cpmeisters feedback #1\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6048188deefb3fc67767b8d94b0d40ba12cce95e", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/6048188deefb3fc67767b8d94b0d40ba12cce95e", "committedDate": "2020-05-27T09:50:14Z", "message": "Changes based on cpmeister's review #2\n\n* Refactored encrypt and decrypt methods to get rid of duplicate code\noutside of for loops handling the border cases.\n* Refactored the gmul method to be much more easier to read and much\nmore clear what it does.\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/1299283cb4c20eb849f52e84e7bafc05159cb308", "committedDate": "2020-05-28T16:44:00Z", "message": "Changes based on cpmeister's review #3\n\n* Resolve conflicts in pom.xml\n* Requested changes in expandKey method\n* Added disposal of futures in EntityBaseHandler in dispose() method\n* Usage of ByteBuffer instead of ByteArrayOutputStream in getBytes()\nmethods of ParadoxIPPacket, CommandPayload and MemoryRequestPayload\nclasses\n* Added tests for checking the getBytes functionality of changed classes\n* Added test of encryption handler which checks against a particular\nexpected result\n\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99cb016a9532ba274c680455edb02fbd0021fcde", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/99cb016a9532ba274c680455edb02fbd0021fcde", "committedDate": "2020-05-23T12:58:51Z", "message": "Changes based on cpmeister's review #2\n\n* Refactored encrypt and decrypt methods to get rid of duplicate code\noutside of for loops handling the border cases.\n* Refactored the gmul method to be much more easier to read and much\nmore clear what it does.\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}, "afterCommit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/1299283cb4c20eb849f52e84e7bafc05159cb308", "committedDate": "2020-05-28T16:44:00Z", "message": "Changes based on cpmeister's review #3\n\n* Resolve conflicts in pom.xml\n* Requested changes in expandKey method\n* Added disposal of futures in EntityBaseHandler in dispose() method\n* Usage of ByteBuffer instead of ByteArrayOutputStream in getBytes()\nmethods of ParadoxIPPacket, CommandPayload and MemoryRequestPayload\nclasses\n* Added tests for checking the getBytes functionality of changed classes\n* Added test of encryption handler which checks against a particular\nexpected result\n\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "committedDate": "2020-05-29T13:12:58Z", "message": "Make EncryptionHandler instance immutable\n\n* Make encryption handler instance to always get created when the key is\nupdated\n* Changed aTable and lTable to be static and all necessary methods used\nin table generation to be also static\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDIyMjE5", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-420422219", "createdAt": "2020-05-28T19:28:40Z", "commit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOToyODo0MFrOGcDbXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozMTozMlrOGcDhFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2OTQ2OQ==", "bodyText": "No harm in cancelling something that is already done.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (delayedSchedule != null && !delayedSchedule.isCancelled() && !delayedSchedule.isDone()) {\n          \n          \n            \n                    if (delayedSchedule != null) {", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432069469", "createdAt": "2020-05-28T19:28:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/EntityBaseHandler.java", "diffHunk": "@@ -94,6 +96,15 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n         }\n     }\n \n+    @Override\n+    public void dispose() {\n+        if (delayedSchedule != null && !delayedSchedule.isCancelled() && !delayedSchedule.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDMwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int partitionNumber;\n          \n          \n            \n                private PartitionCommand command;\n          \n          \n            \n                private final int partitionNumber;\n          \n          \n            \n                private final PartitionCommand command;", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070307", "createdAt": "2020-05-28T19:30:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/CommandPayload.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * The {@link CommandPayload} Class that structures the payload for partition commands.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public class CommandPayload implements IPayload {\n+\n+    private static final int BYTES_LENGTH = 15;\n+\n+    private final byte MESSAGE_START = 0x40;\n+    private final byte PAYLOAD_SIZE = 0x0f;\n+    private final byte[] EMPTY_FOUR_BYTES = { 0, 0, 0, 0 };\n+    private final byte CHECKSUM = 0;\n+\n+    private int partitionNumber;\n+    private PartitionCommand command;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDU5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int address;\n          \n          \n            \n                private byte bytesToRead;\n          \n          \n            \n                private final int address;\n          \n          \n            \n                private final byte bytesToRead;", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070593", "createdAt": "2020-05-28T19:30:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/MemoryRequestPayload.java", "diffHunk": "@@ -1,88 +1,78 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.paradoxalarm.internal.communication.messages;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-\n-import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxException;\n-import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxRuntimeException;\n-import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link EpromRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n- * classes.\n- *\n- * @author Konstantin Polihronov - Initial contribution\n- */\n-public abstract class MemoryRequestPayload implements IPPacketPayload {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\n-\n-    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\n-\n-    private int address;\n-    private byte bytesToRead;\n-\n-    public MemoryRequestPayload(int address, byte bytesToRead) throws ParadoxException {\n-        if (bytesToRead < 1 || bytesToRead > 64) {\n-            throw new ParadoxException(\"Invalid bytes to read. Valid values are 1 to 64.\");\n-        }\n-\n-        this.address = address;\n-        this.bytesToRead = bytesToRead;\n-\n-        logTraceHexFormatted(\"MessageStart: {}\", MESSAGE_START);\n-    }\n-\n-    protected abstract byte calculateControlByte();\n-\n-    @Override\n-    public byte[] getBytes() {\n-        try {\n-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\n-            outputStream.write(ParadoxUtil.shortToByteArray(MESSAGE_START));\n-            outputStream.write(calculateControlByte());\n-            outputStream.write((byte) 0x00);\n-\n-            outputStream.write(ParadoxUtil.shortToByteArray((short) address));\n-\n-            outputStream.write(bytesToRead);\n-\n-            // The bellow 0x00 is dummy which will be overwritten by the checksum\n-            outputStream.write(0x00);\n-            byte[] byteArray = outputStream.toByteArray();\n-\n-            return byteArray;\n-        } catch (IOException e) {\n-            throw new ParadoxRuntimeException(\"Unable to create byte array stream.\", e);\n-        }\n-    }\n-\n-    protected int getAddress() {\n-        return address;\n-    }\n-\n-    protected void logTraceHexFormatted(String text, int address) {\n-        logTraceOptional(text, \"0x%02X,\\t\", address);\n-    }\n-\n-    private void logTraceOptional(String text, String format, int address) {\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"Address: {}\", String.format(format, address));\n-        }\n-    }\n-}\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\r\n+\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+\r\n+import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxException;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * The {@link MemoryRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\r\n+ * classes.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ */\r\n+public abstract class MemoryRequestPayload implements IPayload {\r\n+\r\n+    private static final int BUFFER_LENGTH = 8;\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\r\n+\r\n+    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\r\n+\r\n+    private int address;\r\n+    private byte bytesToRead;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDkzMg==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070932", "createdAt": "2020-05-28T19:31:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandlerConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+/**\n+ *\n+ * Constant\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ */\n+public class EncryptionHandlerConstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjQ5MTI0", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-421249124", "createdAt": "2020-05-29T19:56:29Z", "commit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDowNzo1M1rOGcqlGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNjowNToxN1rOGcw5yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMDkzOA==", "bodyText": "Instead of copying ranges of the expandedKey every time, you should just change this method to accept range parameters.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432710938", "createdAt": "2020-05-29T20:07:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized EncryptionHandler updateKey(byte[] newKey) {\r\n+        instance = new EncryptionHandler(newKey);\r\n+        return instance;\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 4 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            }\r\n+\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\r\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private int gmul(int c, int b) {\r\n+        int s = lTable[c] + lTable[b];\r\n+        s %= 255;\r\n+        s = aTable[s];\r\n+        if (b == 0 || c == 0) {\r\n+            s = 0;\r\n+        }\r\n+        return s;\r\n+    }\r\n+\r\n+    private static void generateTables() {\r\n+        int a = 1;\r\n+        int d;\r\n+        for (int index = 0; index < 255; index++) {\r\n+            aTable[index] = a & 0xFF;\r\n+            /* Multiply by three */\r\n+            d = (a & 0x80) & 0xFF;\r\n+            a <<= 1;\r\n+            if (d == 0x80) {\r\n+                a ^= 0x1b;\r\n+                a &= 0xFF;\r\n+            }\r\n+            a ^= aTable[index];\r\n+            a &= 0xFF;\r\n+            /* Set the log table value */\r\n+            lTable[aTable[index]] = index & 0xFF;\r\n+        }\r\n+        aTable[255] = aTable[0];\r\n+        lTable[0] = 0;\r\n+    }\r\n+\r\n+    private void sBox(int[] a, int[] box) {\r\n+        for (int i = 0; i < 16; i++) {\r\n+            a[i] = box[a[i]];\r\n+        }\r\n+    }\r\n+\r\n+    private void mixColumn(int[] a) {\r\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\r\n+\r\n+        int[] b = new int[] { 0, 0, 0, 0 };\r\n+        for (int j = 0; j < 4; j++) {\r\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\r\n+            for (int i = 0; i < 4; i++) {\r\n+                b[i] = a[i * 4 + j];\r\n+            }\r\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\r\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\r\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\r\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\r\n+\r\n+            for (int i = 0; i < 4; i++) {\r\n+                a[i * 4 + j] = b[i];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void invMixColumn(int[] a) {\r\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\r\n+        for (int j = 0; j < 4; j++) {\r\n+            for (int i = 0; i < 4; i++) {\r\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\r\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int j = 0; j < 4; j++) {\r\n+            for (int i = 0; i < 4; i++) {\r\n+                a[i * 4 + j] = b[i][j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void shiftRow(int[] a, int d) {\r\n+        int[] tmpArray = new int[] { 0, 0, 0, 0 };\r\n+        for (int i = 1; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                int[][][] shifts = EncryptionHandlerConstants.SHIFTS;\r\n+                int index = i * 4 + (j + shifts[0][i][d]) % 4;\r\n+                tmpArray[j] = a[index];\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                a[i * 4 + j] = tmpArray[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void keyAddition(int[] a, int[] rk) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19"}, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMzA3Mw==", "bodyText": "Is rounds a constant?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432713073", "createdAt": "2020-05-29T20:12:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxNTYxNQ==", "bodyText": "Please move this method to below the static{..} clause.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432715615", "createdAt": "2020-05-29T20:19:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized EncryptionHandler updateKey(byte[] newKey) {\r\n+        instance = new EncryptionHandler(newKey);\r\n+        return instance;\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 4 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            }\r\n+\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\r\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private int gmul(int c, int b) {\r\n+        int s = lTable[c] + lTable[b];\r\n+        s %= 255;\r\n+        s = aTable[s];\r\n+        if (b == 0 || c == 0) {\r\n+            s = 0;\r\n+        }\r\n+        return s;\r\n+    }\r\n+\r\n+    private static void generateTables() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNDUzNg==", "bodyText": "These should be QuantityType", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432814536", "createdAt": "2020-05-30T06:05:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/ParadoxPanelHandler.java", "diffHunk": "@@ -50,6 +57,11 @@ protected void updateEntity() {\n             updateProperty(PANEL_APPLICATION_VERSION_PROPERTY_NAME,\n                     panelInformation.getApplicationVersion().toString());\n             updateProperty(PANEL_BOOTLOADER_VERSION_PROPERTY_NAME, panelInformation.getBootLoaderVersion().toString());\n+\n+            updateState(PANEL_TIME, new DateTimeType(panel.getPanelTime()));\n+            updateState(PANEL_INPUT_VOLTAGE, new DecimalType(panel.getVdcLevel()));\n+            updateState(PANEL_BOARD_VOLTAGE, new DecimalType(panel.getDcLevel()));\n+            updateState(PANEL_BATTERY_VOLTAGE, new DecimalType(panel.getBatteryLevel()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/525342c2adcdab5afc19b4180beffa6ab2d99c15", "committedDate": "2020-05-31T12:56:30Z", "message": "Changes based on cpmeister's review #4\n\n* Make fields in payload classes final\n* Add nonnullbydefault to EncryptionHandlerConstants class\n* Change voltage types from DecimalType to QuantityType in\nParadoxPanelHandler\n* Remove unnecessary checks for delayed jobs\n* Move static generateTables() method on top\n* Extract ROUNDS from encrypt and decrypt methods as constant\n* Refactor keyAddition method to use startIndex instead of copy ranges\neverytime\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTE4Mzk4", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-421518398", "createdAt": "2020-05-31T18:46:31Z", "commit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxODo0NjozMVrOGc6l9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxOToxNjoxM1rOGc6vBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzMwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static final int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static final int[] aTable = new int[TABLE_SIZE];", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973300", "createdAt": "2020-05-31T18:46:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+    private static final int ROUNDS = 14;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int[] expandedKey = new int[KEY_LENGTH];\n          \n          \n            \n                private final int[] expandedKey = new int[KEY_LENGTH];", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973437", "createdAt": "2020-05-31T18:48:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+    private static final int ROUNDS = 14;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private static void generateTables() {\r\n+        int a = 1;\r\n+        int d;\r\n+        for (int index = 0; index < 255; index++) {\r\n+            aTable[index] = a & 0xFF;\r\n+            /* Multiply by three */\r\n+            d = (a & 0x80) & 0xFF;\r\n+            a <<= 1;\r\n+            if (d == 0x80) {\r\n+                a ^= 0x1b;\r\n+                a &= 0xFF;\r\n+            }\r\n+            a ^= aTable[index];\r\n+            a &= 0xFF;\r\n+            /* Set the log table value */\r\n+            lTable[aTable[index]] = index & 0xFF;\r\n+        }\r\n+        aTable[255] = aTable[0];\r\n+        lTable[0] = 0;\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzUwMw==", "bodyText": "How hard would it be to add @NonNullByDefault to all of these Payload classes?", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973503", "createdAt": "2020-05-31T18:49:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/CommandPayload.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * The {@link CommandPayload} Class that structures the payload for partition commands.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public class CommandPayload implements IPayload {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3Mzk3Mg==", "bodyText": "use it or lose it", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973972", "createdAt": "2020-05-31T18:55:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/CommunicationState.java", "diffHunk": "@@ -126,17 +142,17 @@ protected void runPhase(IParadoxInitialLoginCommunicator communicator, Object...\n             logger.debug(\"Phase {}\", this);\n             byte[] message4 = new byte[37];\n             message4[0] = 0x72;\n+            // message4[message4.length - 1] = 0x72;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDExNw==", "bodyText": "I'd really prefer if ParadoxPanel wasn't a singleton. But you are also free to keep it singleton since it was has already been grandfathered in.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432974117", "createdAt": "2020-05-31T18:57:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/CommunicationState.java", "diffHunk": "@@ -351,8 +366,10 @@ protected CommunicationState nextState() {\n \n         @Override\n         protected void runPhase(IParadoxInitialLoginCommunicator communicator, Object... args) {\n-            communicator.close();\n-            communicator.setOnline(false);\n+            if (communicator != null) {\n+                communicator.close();\n+            }\n+            ParadoxPanel.getInstance().dispose();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDI5NQ==", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432974295", "createdAt": "2020-05-31T18:59:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/pom.xml", "diffHunk": "@@ -13,4 +13,4 @@\n   <artifactId>org.openhab.binding.paradoxalarm</artifactId>\n \n   <name>openHAB Add-ons :: Bundles :: ParadoxAlarm Binding</name>\n-</project>\n+</project>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NTYyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | inputVoltage             | Number   | Supply Voltage                                                                          |\n          \n          \n            \n            | boardVoltage             | Number   | Board DC Voltage                                                                          |\n          \n          \n            \n            | batteryVoltage           | Number   | Battery Voltage                                                                           |\n          \n          \n            \n            | inputVoltage             | Number:ElectricPotential   | Supply Voltage                                                                          |\n          \n          \n            \n            | boardVoltage             | Number:ElectricPotential   | Board DC Voltage                                                                          |\n          \n          \n            \n            | batteryVoltage           | Number:ElectricPotential   | Battery Voltage                                                                           |", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432975622", "createdAt": "2020-05-31T19:16:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/README.md", "diffHunk": "@@ -52,32 +55,43 @@ Currently binding supports the following panels: EVO192, EVO48(not tested), EVO9\n \n ### Entities (zones, partitions) configuration parameters:\n \n-| Value  | Description                                                                        |\n-|--------|------------------------------------------------------------------------------------|\n-| id     | The numeric ID of the zone/partition                                               |\n+| Value             | Description                                                                        |\n+|-------------------|------------------------------------------------------------------------------------|\n+| id                | The numeric ID of the zone/partition                                               |\n+| disarmEnabled     | Optional boolean flag. Valid for partitions. When set to true the command DISARM will be allowed for the partition where the flag is enabled. CAUTION: Enabling DISARM command can be dangerous. If attacker can gain access to your OpenHAB (via API or UI), this command can be used to disarm your armed partition (area) |\n+\n+### Panel channels:\n+| Channel                  | Type     | Description                                                                               |\n+|--------------------------|----------|-------------------------------------------------------------------------------------------|\n+| state                    | String   | Overall panel state                                                                       |\n+| inputVoltage             | Number   | Supply Voltage                                                                          |\n+| boardVoltage             | Number   | Board DC Voltage                                                                          |\n+| batteryVoltage           | Number   | Battery Voltage                                                                           |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26abd91393572b83bf2a0f4d131305d9d980b1b2", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/26abd91393572b83bf2a0f4d131305d9d980b1b2", "committedDate": "2020-06-01T06:40:24Z", "message": "Changes based on cpmeister's review #5\n\n* Add NonNullByDefault to payload, constants and commands classes\n* Change voltage types in README\n* Add new line to pom.xml\n* Make lTable, aTable and expandedKey fields in EncryptionHandler final\n* mvn spotless:apply again to the code\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDI4NzIy", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-422028722", "createdAt": "2020-06-01T17:14:27Z", "commit": {"oid": "26abd91393572b83bf2a0f4d131305d9d980b1b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDMwNDEw", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-422030410", "createdAt": "2020-06-01T17:16:43Z", "commit": {"oid": "26abd91393572b83bf2a0f4d131305d9d980b1b2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzoxNjo0NFrOGdTBVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzoxNjo0NFrOGdTBVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM3MzUyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<state readOnly=\"true\" pattern=\"%fV\"/>\n          \n          \n            \n            \t\t<state readOnly=\"true\" pattern=\"%f %unit%\"/>", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r433373524", "createdAt": "2020-06-01T17:16:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.paradoxalarm/src/main/resources/ESH-INF/thing/panel.xml", "diffHunk": "@@ -1,64 +1,80 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<thing:thing-descriptions bindingId=\"paradoxalarm\"\n-\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n-\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n-\n-\t<thing-type id=\"panel\">\n-\t\t<supported-bridge-type-refs>\n-\t\t\t<bridge-type-ref id=\"ip150\"/>\n-\t\t</supported-bridge-type-refs>\n-\n-\t\t<label>Paradox Panel</label>\n-\t\t<description>Paradox panel various information</description>\n-\n-\t\t<channels>\n-\t\t\t<channel id=\"state\" typeId=\"panelState\"/>\n-\t\t</channels>\n-\t\t<properties>\n-\t\t\t<property name=\"serialNumber\"/>\n-\t\t\t<property name=\"panelType\"/>\n-\t\t\t<property name=\"hardwareVersion\"/>\n-\t\t\t<property name=\"applicationVersion\"/>\n-\t\t\t<property name=\"bootloaderVersion\"/>\n-\t\t</properties>\n-\t</thing-type>\n-\n-\t<channel-type id=\"panelState\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Panel State</label>\n-\t\t<description>Shows the state of the communication to panel (online/offline)</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\t<channel-type id=\"serialNumber\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Serial Number</label>\n-\t\t<description>Panel serial number</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\t<channel-type id=\"panelType\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Panel Type</label>\n-\t\t<description>Panel type (Evo, SP, etc)</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\t<channel-type id=\"hardwareVersion\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Hardware Version</label>\n-\t\t<description>Panel hardware version</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\t<channel-type id=\"applicationVersion\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Application Version</label>\n-\t\t<description>Panel application version</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\t<channel-type id=\"bootloaderVersion\">\n-\t\t<item-type>String</item-type>\n-\t\t<label>Boot Loader Version</label>\n-\t\t<description>Boot loader version</description>\n-\t\t<state readOnly=\"true\" pattern=\"%s\"/>\n-\t</channel-type>\n-\n-</thing:thing-descriptions>\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n+<thing:thing-descriptions bindingId=\"paradoxalarm\"\r\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\r\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\r\n+\r\n+\t<thing-type id=\"panel\">\r\n+\t\t<supported-bridge-type-refs>\r\n+\t\t\t<bridge-type-ref id=\"ip150\"/>\r\n+\t\t</supported-bridge-type-refs>\r\n+\r\n+\t\t<label>Paradox Panel</label>\r\n+\t\t<description>Paradox panel various information</description>\r\n+\r\n+\t\t<channels>\r\n+\t\t\t<channel id=\"state\" typeId=\"panelState\"/>\r\n+\t\t\t<channel id=\"inputVoltage\" typeId=\"voltage\"/>\r\n+\t\t\t<channel id=\"boardVoltage\" typeId=\"voltage\"/>\r\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"voltage\"/>\r\n+\t\t\t<channel id=\"panelTime\" typeId=\"panelTime\"/>\r\n+\t\t</channels>\r\n+\t\t<properties>\r\n+\t\t\t<property name=\"serialNumber\"/>\r\n+\t\t\t<property name=\"panelType\"/>\r\n+\t\t\t<property name=\"hardwareVersion\"/>\r\n+\t\t\t<property name=\"applicationVersion\"/>\r\n+\t\t\t<property name=\"bootloaderVersion\"/>\r\n+\t\t</properties>\r\n+\t</thing-type>\r\n+\r\n+\t<channel-type id=\"panelState\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Panel State</label>\r\n+\t\t<description>Shows the state of the communication to panel (online/offline)</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"serialNumber\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Serial Number</label>\r\n+\t\t<description>Panel serial number</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"panelType\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Panel Type</label>\r\n+\t\t<description>Panel type (Evo, SP, etc)</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"hardwareVersion\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Hardware Version</label>\r\n+\t\t<description>Panel hardware version</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"applicationVersion\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Application Version</label>\r\n+\t\t<description>Panel application version</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"bootloaderVersion\">\r\n+\t\t<item-type>String</item-type>\r\n+\t\t<label>Boot Loader Version</label>\r\n+\t\t<description>Boot loader version</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%s\"/>\r\n+\t</channel-type>\r\n+\t<channel-type id=\"voltage\">\r\n+\t\t<item-type>Number:ElectricPotential</item-type>\r\n+\t\t<label>Voltage</label>\r\n+\t\t<description>Voltage</description>\r\n+\t\t<state readOnly=\"true\" pattern=\"%fV\"/>\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26abd91393572b83bf2a0f4d131305d9d980b1b2"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8094dc006eea73b52290c24cb57487553579c6", "author": {"user": {"login": "theater", "name": "Konstantin Polihronov"}}, "url": "https://github.com/openhab/openhab-addons/commit/4b8094dc006eea73b52290c24cb57487553579c6", "committedDate": "2020-06-02T06:42:11Z", "message": "Update unit type in panel.xml with parametrized value\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODkwMzY1", "url": "https://github.com/openhab/openhab-addons/pull/6961#pullrequestreview-422890365", "createdAt": "2020-06-02T17:14:51Z", "commit": {"oid": "4b8094dc006eea73b52290c24cb57487553579c6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1352, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}