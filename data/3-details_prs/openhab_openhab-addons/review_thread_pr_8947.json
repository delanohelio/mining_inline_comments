{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NDA3Njg2", "number": 8947, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0zMFQxNToyMDoxN1rOGEbUGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0zMFQxNToyMDoxN1rOGEbUGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDA3Mjk1MDAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.nest/src/main/java/org/openhab/binding/nest/internal/sdm/handler/SDMAccountHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0zMFQxNToyMDoxN1rOJkWIxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0zMVQwODoxODo1MFrOJkjLCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA5MTIwNw==", "bodyText": "Can you specify the encoding you expect? E.g. StandardCharsets.UTF_8", "url": "https://github.com/openhab/openhab-addons/pull/8947#discussion_r642091207", "createdAt": "2021-05-30T15:20:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.nest/src/main/java/org/openhab/binding/nest/internal/sdm/handler/SDMAccountHandler.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nest.internal.sdm.handler;\n+\n+import static java.util.function.Predicate.not;\n+import static org.openhab.binding.nest.internal.sdm.dto.SDMGson.GSON;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nest.internal.sdm.api.PubSubAPI;\n+import org.openhab.binding.nest.internal.sdm.api.SDMAPI;\n+import org.openhab.binding.nest.internal.sdm.config.SDMAccountConfiguration;\n+import org.openhab.binding.nest.internal.sdm.discovery.SDMDiscoveryService;\n+import org.openhab.binding.nest.internal.sdm.dto.PubSubRequestsResponses.PubSubMessage;\n+import org.openhab.binding.nest.internal.sdm.dto.SDMEvent;\n+import org.openhab.binding.nest.internal.sdm.dto.SDMEvent.SDMResourceUpdate;\n+import org.openhab.binding.nest.internal.sdm.exception.FailedSendingPubSubDataException;\n+import org.openhab.binding.nest.internal.sdm.exception.FailedSendingSDMDataException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidPubSubAccessTokenException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidPubSubAuthorizationCodeException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidSDMAccessTokenException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidSDMAuthorizationCodeException;\n+import org.openhab.binding.nest.internal.sdm.listener.PubSubSubscriptionListener;\n+import org.openhab.binding.nest.internal.sdm.listener.SDMAPIRequestListener;\n+import org.openhab.binding.nest.internal.sdm.listener.SDMEventListener;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDMAccountHandler} provides the {@link SDMAPI} instance used by the device handlers.\n+ * The {@link SDMAPI} is used by device handlers for periodically refreshing device data and sending device commands.\n+ * When Pub/Sub is properly configured, the account handler also sends received {@link SDMEvent}s from the\n+ * {@link PubSubAPI} to the subscribed {@link SDMEventListener}s.\n+ *\n+ * @author Brian Higginbotham - Initial contribution\n+ * @author Wouter Born - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDMAccountHandler extends BaseBridgeHandler {\n+\n+    private static final String PUBSUB_TOPIC_NAME_PREFIX = \"projects/sdm-prod/topics/enterprise-\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDMAccountHandler.class);\n+\n+    private HttpClientFactory httpClientFactory;\n+    private OAuthFactory oAuthFactory;\n+\n+    private @NonNullByDefault({}) SDMAccountConfiguration config;\n+    private @Nullable Future<?> initializeFuture;\n+\n+    private @Nullable PubSubAPI pubSubAPI;\n+    private @Nullable Exception pubSubException;\n+\n+    private @Nullable SDMAPI sdmAPI;\n+    private @Nullable Exception sdmException;\n+    private @Nullable Future<?> sdmCheckFuture;\n+    private final Duration sdmCheckDelay = Duration.ofMinutes(1);\n+\n+    private final Map<String, SDMEventListener> listeners = new ConcurrentHashMap<>();\n+\n+    private final SDMAPIRequestListener requestListener = new SDMAPIRequestListener() {\n+        @Override\n+        public void onError(Exception exception) {\n+            sdmException = exception;\n+            logger.debug(\"SDM exception occurred\");\n+            updateThingStatus();\n+\n+            Future<?> future = sdmCheckFuture;\n+            if (future == null || future.isDone()) {\n+                sdmCheckFuture = scheduler.scheduleWithFixedDelay(() -> {\n+                    SDMAPI localSDMAPI = sdmAPI;\n+                    if (localSDMAPI != null) {\n+                        try {\n+                            logger.debug(\"Checking SDM API\");\n+                            localSDMAPI.listDevices();\n+                        } catch (FailedSendingSDMDataException | InvalidSDMAccessTokenException e) {\n+                            logger.debug(\"SDM API check failed\");\n+                        }\n+                    }\n+                }, sdmCheckDelay.toNanos(), sdmCheckDelay.toNanos(), TimeUnit.NANOSECONDS);\n+                logger.debug(\"Scheduled SDM API check job\");\n+            }\n+        }\n+\n+        @Override\n+        public void onSuccess() {\n+            if (sdmException != null) {\n+                sdmException = null;\n+                logger.debug(\"SDM exception cleared\");\n+                updateThingStatus();\n+            }\n+\n+            Future<?> future = sdmCheckFuture;\n+            if (future != null) {\n+                future.cancel(true);\n+                sdmCheckFuture = null;\n+                logger.debug(\"Cancelled SDM API check job\");\n+            }\n+        }\n+    };\n+\n+    private final PubSubSubscriptionListener subscriptionListener = new PubSubSubscriptionListener() {\n+        @Override\n+        public void onError(Exception exception) {\n+            pubSubException = exception;\n+            logger.debug(\"Pub/Sub exception occurred\");\n+            updateThingStatus();\n+        }\n+\n+        @Override\n+        public void onMessage(PubSubMessage message) {\n+            if (pubSubException != null) {\n+                pubSubException = null;\n+                logger.debug(\"Pub/Sub exception cleared\");\n+                updateThingStatus();\n+            }\n+            handlePubSubMessage(message);\n+        }\n+\n+        @Override\n+        public void onNoNewMessages() {\n+            if (pubSubException != null) {\n+                pubSubException = null;\n+                logger.debug(\"Pub/Sub exception cleared\");\n+                updateThingStatus();\n+            }\n+        }\n+    };\n+\n+    public SDMAccountHandler(Bridge bridge, HttpClientFactory httpClientFactory, OAuthFactory oAuthFactory) {\n+        super(bridge);\n+        this.httpClientFactory = httpClientFactory;\n+        this.oAuthFactory = oAuthFactory;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SDMAccountConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        initializeFuture = scheduler.submit(() -> {\n+            sdmAPI = initializeSDMAPI();\n+            if (config.usePubSub()) {\n+                pubSubAPI = initializePubSubAPI();\n+            }\n+            updateThingStatus();\n+        });\n+    }\n+\n+    private @Nullable SDMAPI initializeSDMAPI() {\n+        SDMAPI sdmAPI = new SDMAPI(httpClientFactory, oAuthFactory, getThing().getUID().getAsString(),\n+                config.sdmProjectId, config.sdmClientId, config.sdmClientSecret);\n+        sdmException = null;\n+\n+        try {\n+            if (!config.sdmAuthorizationCode.isBlank()) {\n+                sdmAPI.authorizeClient(config.sdmAuthorizationCode);\n+\n+                Configuration configuration = editConfiguration();\n+                configuration.put(SDMAccountConfiguration.SDM_AUTHORIZATION_CODE, \"\");\n+                updateConfiguration(configuration);\n+            }\n+\n+            sdmAPI.checkAccessTokenValidity();\n+            sdmAPI.addRequestListener(requestListener);\n+\n+            return sdmAPI;\n+        } catch (InvalidSDMAccessTokenException | InvalidSDMAuthorizationCodeException | IOException e) {\n+            sdmException = e;\n+            return null;\n+        }\n+    }\n+\n+    private @Nullable PubSubAPI initializePubSubAPI() {\n+        PubSubAPI pubSubAPI = new PubSubAPI(httpClientFactory, oAuthFactory, getThing().getUID().getAsString(),\n+                config.pubsubProjectId, config.pubsubClientId, config.pubsubClientSecret);\n+        pubSubException = null;\n+\n+        try {\n+            if (!config.pubsubAuthorizationCode.isBlank()) {\n+                pubSubAPI.authorizeClient(config.pubsubAuthorizationCode);\n+\n+                Configuration configuration = editConfiguration();\n+                configuration.put(SDMAccountConfiguration.PUBSUB_AUTHORIZATION_CODE, \"\");\n+                updateConfiguration(configuration);\n+            }\n+\n+            pubSubAPI.checkAccessTokenValidity();\n+            pubSubAPI.createSubscription(config.pubsubSubscriptionId, PUBSUB_TOPIC_NAME_PREFIX + config.sdmProjectId);\n+            pubSubAPI.addSubscriptionListener(config.pubsubSubscriptionId, subscriptionListener);\n+\n+            return pubSubAPI;\n+        } catch (FailedSendingPubSubDataException | InvalidPubSubAccessTokenException\n+                | InvalidPubSubAuthorizationCodeException | IOException e) {\n+            pubSubException = e;\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        Future<?> localFuture = initializeFuture;\n+        if (localFuture != null) {\n+            localFuture.cancel(true);\n+            initializeFuture = null;\n+        }\n+\n+        localFuture = sdmCheckFuture;\n+        if (localFuture != null) {\n+            localFuture.cancel(true);\n+            sdmCheckFuture = null;\n+        }\n+\n+        PubSubAPI localPubSubAPI = pubSubAPI;\n+        if (localPubSubAPI != null) {\n+            localPubSubAPI.dispose();\n+            pubSubAPI = null;\n+        }\n+\n+        SDMAPI localSDMAPI = sdmAPI;\n+        if (localSDMAPI != null) {\n+            localSDMAPI.dispose();\n+            sdmAPI = null;\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return List.of(SDMDiscoveryService.class);\n+    }\n+\n+    public void addThingDataListener(String deviceId, SDMEventListener listener) {\n+        listeners.put(deviceId, listener);\n+    }\n+\n+    public void removeThingDataListener(String deviceId, SDMEventListener listener) {\n+        listeners.remove(deviceId, listener);\n+    }\n+\n+    public @Nullable SDMAPI getAPI() {\n+        return sdmAPI;\n+    }\n+\n+    private void handlePubSubMessage(PubSubMessage message) {\n+        String messageId = message.messageId;\n+        String json = new String(Base64.getDecoder().decode(message.data));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d634c6318c4e3a0a23fa6489a040cf5d868bcf"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjMwNDc3OA==", "bodyText": "Yes that's better. You never know what might happen on Windows. :-)", "url": "https://github.com/openhab/openhab-addons/pull/8947#discussion_r642304778", "createdAt": "2021-05-31T08:18:50Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.nest/src/main/java/org/openhab/binding/nest/internal/sdm/handler/SDMAccountHandler.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nest.internal.sdm.handler;\n+\n+import static java.util.function.Predicate.not;\n+import static org.openhab.binding.nest.internal.sdm.dto.SDMGson.GSON;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nest.internal.sdm.api.PubSubAPI;\n+import org.openhab.binding.nest.internal.sdm.api.SDMAPI;\n+import org.openhab.binding.nest.internal.sdm.config.SDMAccountConfiguration;\n+import org.openhab.binding.nest.internal.sdm.discovery.SDMDiscoveryService;\n+import org.openhab.binding.nest.internal.sdm.dto.PubSubRequestsResponses.PubSubMessage;\n+import org.openhab.binding.nest.internal.sdm.dto.SDMEvent;\n+import org.openhab.binding.nest.internal.sdm.dto.SDMEvent.SDMResourceUpdate;\n+import org.openhab.binding.nest.internal.sdm.exception.FailedSendingPubSubDataException;\n+import org.openhab.binding.nest.internal.sdm.exception.FailedSendingSDMDataException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidPubSubAccessTokenException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidPubSubAuthorizationCodeException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidSDMAccessTokenException;\n+import org.openhab.binding.nest.internal.sdm.exception.InvalidSDMAuthorizationCodeException;\n+import org.openhab.binding.nest.internal.sdm.listener.PubSubSubscriptionListener;\n+import org.openhab.binding.nest.internal.sdm.listener.SDMAPIRequestListener;\n+import org.openhab.binding.nest.internal.sdm.listener.SDMEventListener;\n+import org.openhab.core.auth.client.oauth2.OAuthFactory;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDMAccountHandler} provides the {@link SDMAPI} instance used by the device handlers.\n+ * The {@link SDMAPI} is used by device handlers for periodically refreshing device data and sending device commands.\n+ * When Pub/Sub is properly configured, the account handler also sends received {@link SDMEvent}s from the\n+ * {@link PubSubAPI} to the subscribed {@link SDMEventListener}s.\n+ *\n+ * @author Brian Higginbotham - Initial contribution\n+ * @author Wouter Born - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDMAccountHandler extends BaseBridgeHandler {\n+\n+    private static final String PUBSUB_TOPIC_NAME_PREFIX = \"projects/sdm-prod/topics/enterprise-\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDMAccountHandler.class);\n+\n+    private HttpClientFactory httpClientFactory;\n+    private OAuthFactory oAuthFactory;\n+\n+    private @NonNullByDefault({}) SDMAccountConfiguration config;\n+    private @Nullable Future<?> initializeFuture;\n+\n+    private @Nullable PubSubAPI pubSubAPI;\n+    private @Nullable Exception pubSubException;\n+\n+    private @Nullable SDMAPI sdmAPI;\n+    private @Nullable Exception sdmException;\n+    private @Nullable Future<?> sdmCheckFuture;\n+    private final Duration sdmCheckDelay = Duration.ofMinutes(1);\n+\n+    private final Map<String, SDMEventListener> listeners = new ConcurrentHashMap<>();\n+\n+    private final SDMAPIRequestListener requestListener = new SDMAPIRequestListener() {\n+        @Override\n+        public void onError(Exception exception) {\n+            sdmException = exception;\n+            logger.debug(\"SDM exception occurred\");\n+            updateThingStatus();\n+\n+            Future<?> future = sdmCheckFuture;\n+            if (future == null || future.isDone()) {\n+                sdmCheckFuture = scheduler.scheduleWithFixedDelay(() -> {\n+                    SDMAPI localSDMAPI = sdmAPI;\n+                    if (localSDMAPI != null) {\n+                        try {\n+                            logger.debug(\"Checking SDM API\");\n+                            localSDMAPI.listDevices();\n+                        } catch (FailedSendingSDMDataException | InvalidSDMAccessTokenException e) {\n+                            logger.debug(\"SDM API check failed\");\n+                        }\n+                    }\n+                }, sdmCheckDelay.toNanos(), sdmCheckDelay.toNanos(), TimeUnit.NANOSECONDS);\n+                logger.debug(\"Scheduled SDM API check job\");\n+            }\n+        }\n+\n+        @Override\n+        public void onSuccess() {\n+            if (sdmException != null) {\n+                sdmException = null;\n+                logger.debug(\"SDM exception cleared\");\n+                updateThingStatus();\n+            }\n+\n+            Future<?> future = sdmCheckFuture;\n+            if (future != null) {\n+                future.cancel(true);\n+                sdmCheckFuture = null;\n+                logger.debug(\"Cancelled SDM API check job\");\n+            }\n+        }\n+    };\n+\n+    private final PubSubSubscriptionListener subscriptionListener = new PubSubSubscriptionListener() {\n+        @Override\n+        public void onError(Exception exception) {\n+            pubSubException = exception;\n+            logger.debug(\"Pub/Sub exception occurred\");\n+            updateThingStatus();\n+        }\n+\n+        @Override\n+        public void onMessage(PubSubMessage message) {\n+            if (pubSubException != null) {\n+                pubSubException = null;\n+                logger.debug(\"Pub/Sub exception cleared\");\n+                updateThingStatus();\n+            }\n+            handlePubSubMessage(message);\n+        }\n+\n+        @Override\n+        public void onNoNewMessages() {\n+            if (pubSubException != null) {\n+                pubSubException = null;\n+                logger.debug(\"Pub/Sub exception cleared\");\n+                updateThingStatus();\n+            }\n+        }\n+    };\n+\n+    public SDMAccountHandler(Bridge bridge, HttpClientFactory httpClientFactory, OAuthFactory oAuthFactory) {\n+        super(bridge);\n+        this.httpClientFactory = httpClientFactory;\n+        this.oAuthFactory = oAuthFactory;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SDMAccountConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        initializeFuture = scheduler.submit(() -> {\n+            sdmAPI = initializeSDMAPI();\n+            if (config.usePubSub()) {\n+                pubSubAPI = initializePubSubAPI();\n+            }\n+            updateThingStatus();\n+        });\n+    }\n+\n+    private @Nullable SDMAPI initializeSDMAPI() {\n+        SDMAPI sdmAPI = new SDMAPI(httpClientFactory, oAuthFactory, getThing().getUID().getAsString(),\n+                config.sdmProjectId, config.sdmClientId, config.sdmClientSecret);\n+        sdmException = null;\n+\n+        try {\n+            if (!config.sdmAuthorizationCode.isBlank()) {\n+                sdmAPI.authorizeClient(config.sdmAuthorizationCode);\n+\n+                Configuration configuration = editConfiguration();\n+                configuration.put(SDMAccountConfiguration.SDM_AUTHORIZATION_CODE, \"\");\n+                updateConfiguration(configuration);\n+            }\n+\n+            sdmAPI.checkAccessTokenValidity();\n+            sdmAPI.addRequestListener(requestListener);\n+\n+            return sdmAPI;\n+        } catch (InvalidSDMAccessTokenException | InvalidSDMAuthorizationCodeException | IOException e) {\n+            sdmException = e;\n+            return null;\n+        }\n+    }\n+\n+    private @Nullable PubSubAPI initializePubSubAPI() {\n+        PubSubAPI pubSubAPI = new PubSubAPI(httpClientFactory, oAuthFactory, getThing().getUID().getAsString(),\n+                config.pubsubProjectId, config.pubsubClientId, config.pubsubClientSecret);\n+        pubSubException = null;\n+\n+        try {\n+            if (!config.pubsubAuthorizationCode.isBlank()) {\n+                pubSubAPI.authorizeClient(config.pubsubAuthorizationCode);\n+\n+                Configuration configuration = editConfiguration();\n+                configuration.put(SDMAccountConfiguration.PUBSUB_AUTHORIZATION_CODE, \"\");\n+                updateConfiguration(configuration);\n+            }\n+\n+            pubSubAPI.checkAccessTokenValidity();\n+            pubSubAPI.createSubscription(config.pubsubSubscriptionId, PUBSUB_TOPIC_NAME_PREFIX + config.sdmProjectId);\n+            pubSubAPI.addSubscriptionListener(config.pubsubSubscriptionId, subscriptionListener);\n+\n+            return pubSubAPI;\n+        } catch (FailedSendingPubSubDataException | InvalidPubSubAccessTokenException\n+                | InvalidPubSubAuthorizationCodeException | IOException e) {\n+            pubSubException = e;\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        Future<?> localFuture = initializeFuture;\n+        if (localFuture != null) {\n+            localFuture.cancel(true);\n+            initializeFuture = null;\n+        }\n+\n+        localFuture = sdmCheckFuture;\n+        if (localFuture != null) {\n+            localFuture.cancel(true);\n+            sdmCheckFuture = null;\n+        }\n+\n+        PubSubAPI localPubSubAPI = pubSubAPI;\n+        if (localPubSubAPI != null) {\n+            localPubSubAPI.dispose();\n+            pubSubAPI = null;\n+        }\n+\n+        SDMAPI localSDMAPI = sdmAPI;\n+        if (localSDMAPI != null) {\n+            localSDMAPI.dispose();\n+            sdmAPI = null;\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return List.of(SDMDiscoveryService.class);\n+    }\n+\n+    public void addThingDataListener(String deviceId, SDMEventListener listener) {\n+        listeners.put(deviceId, listener);\n+    }\n+\n+    public void removeThingDataListener(String deviceId, SDMEventListener listener) {\n+        listeners.remove(deviceId, listener);\n+    }\n+\n+    public @Nullable SDMAPI getAPI() {\n+        return sdmAPI;\n+    }\n+\n+    private void handlePubSubMessage(PubSubMessage message) {\n+        String messageId = message.messageId;\n+        String json = new String(Base64.getDecoder().decode(message.data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MjA5MTIwNw=="}, "originalCommit": {"oid": "63d634c6318c4e3a0a23fa6489a040cf5d868bcf"}, "originalPosition": 284}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4024, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}