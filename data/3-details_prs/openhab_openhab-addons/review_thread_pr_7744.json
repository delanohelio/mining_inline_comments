{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTI2NDY2", "number": 7744, "reviewThreads": {"totalCount": 100, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMjoxMVrOEGDrPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowNTo1NVrOEguV6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg3MTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMjoxMVrOGkn1Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NToxMVrOGlU0iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NDUyMg==", "bodyText": "Can the commented out ones be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441054522", "createdAt": "2020-06-16T18:22:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.teleinfo-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-teleinfo\" description=\"Teleinfo Binding\" version=\"${project.version}\">\n+\t\t<feature>openhab-runtime-base</feature>\n+\t\t<!-- <feature>openhab-core-io-transport</feature> -->\n+\t\t<feature>openhab-transport-serial</feature>\n+\t\t<!-- <feature>openhab-core-io-transport-serial</feature> -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTYyNA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441791624", "createdAt": "2020-06-17T19:45:11Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.teleinfo-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-teleinfo\" description=\"Teleinfo Binding\" version=\"${project.version}\">\n+\t\t<feature>openhab-runtime-base</feature>\n+\t\t<!-- <feature>openhab-core-io-transport</feature> -->\n+\t\t<feature>openhab-transport-serial</feature>\n+\t\t<!-- <feature>openhab-core-io-transport-serial</feature> -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NDUyMg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg3NDE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMjo0NlrOGkn3QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NTo0N1rOGlU10Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NTA0MQ==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441055041", "createdAt": "2020-06-16T18:22:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoBindingConstants.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link TeleinfoBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoBindingConstants {\n+\n+    private static final String BINDING_ID = \"teleinfo\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_SERIAL_CONTROLLER = new ThingTypeUID(BINDING_ID, \"serialcontroller\");\n+    public static final String THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER = \"invalidFrameCounter\";\n+    // public static final ThingTypeUID THING_TYPE_REMOTE_IP = new ThingTypeUID(BINDING_ID, \"remoteip\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MTk1Mw==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441791953", "createdAt": "2020-06-17T19:45:47Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoBindingConstants.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link TeleinfoBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoBindingConstants {\n+\n+    private static final String BINDING_ID = \"teleinfo\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_SERIAL_CONTROLLER = new ThingTypeUID(BINDING_ID, \"serialcontroller\");\n+    public static final String THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER = \"invalidFrameCounter\";\n+    // public static final ThingTypeUID THING_TYPE_REMOTE_IP = new ThingTypeUID(BINDING_ID, \"remoteip\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NTA0MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg4MDk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNDoyNVrOGkn7iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTo0NzowM1rOGlU4Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NjEzNw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441056137", "createdAt": "2020-06-16T18:24:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5MjYxMA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441792610", "createdAt": "2020-06-17T19:47:03Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NjEzNw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg4NjA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNTo0N1rOGkn-tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDoyMTowNlrOGlV8hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1Njk0OA==", "bodyText": "Can these messages be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441056948", "createdAt": "2020-06-16T18:25:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwMjA4NQ==", "bodyText": "TeleinfoDiscoveryService service is actived on demand by the binding, not by the framework. In fact, the discovery service is enabled only if the user has added a Teleinfo Serial Controller thing.\nThis debug messages can help to log this dynamic activation.\nNo?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441802085", "createdAt": "2020-06-17T20:05:11Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1Njk0OA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMDA1Mw==", "bodyText": "Yes, you're right.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441810053", "createdAt": "2020-06-17T20:21:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1Njk0OA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg4OTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNjozOVrOGkoApQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDoxMToyOVrOGlVpxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NzQ0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (frameSample instanceof FrameAdco == false) {\n          \n          \n            \n                    if (!(frameSample instanceof FrameAdco)) {", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441057445", "createdAt": "2020-06-16T18:26:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgwNTI1Mg==", "bodyText": "Personally, I prefer to see == false that an discrete ! but everyone's taste is different :-)", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441805252", "createdAt": "2020-06-17T20:11:29Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NzQ0NQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg5OTUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyOTo0NFrOGkoHcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyOTo0NFrOGkoHcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTE4NQ==", "bodyText": "The representation property must be the name of the property you want to use as representative, not the value.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441059185", "createdAt": "2020-06-16T18:29:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkwMTYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMDoyM1rOGkoI0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDoyNjoyMFrOGlWGpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTUzNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441059537", "createdAt": "2020-06-16T18:30:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxMjY0NA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441812644", "createdAt": "2020-06-17T20:26:20Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTUzNw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkwODI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMjoyNFrOGkoNQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDozNzoxOFrOGlWhow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MDY3Mw==", "bodyText": "Is there a reason why you don't declare the argument as FrameAdco? Then, the type check and the cast would be obsolete.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441060673", "createdAt": "2020-06-16T18:32:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgxOTU1NQ==", "bodyText": "Actually, only ADCO frames are supported by the binding. The CJE, ICE2Q, ICE4Q and PMEPMI frames are not yot supported. These 4 frame types are not inherited from FrameAdco class.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441819555", "createdAt": "2020-06-17T20:37:18Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MDY3Mw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkxOTYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozNToyNlrOGkoUUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozNToyNlrOGkoUUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2MjQ4MQ==", "bodyText": "You could've used a Visitor to differentiate between the frames. But it's ok...", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441062481", "createdAt": "2020-06-16T18:35:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+        return new ThingUID(getThingTypeUID(teleinfoFrame), frameAdco.getAdco(),\n+                controllerHandler.getThing().getUID().getId());\n+    }\n+\n+    private ThingTypeUID getThingTypeUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameCbemmHcOption) {\n+            return THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmBaseOption) {\n+            return THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEjpOption) {\n+            return THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmTempoOption) {\n+            return THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccHcOption) {\n+            return THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccBaseOption) {\n+            return THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccEjpOption) {\n+            return THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccTempoOption) {\n+            return THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongHcOption) {\n+            return THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongBaseOption) {\n+            return THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongEjpOption) {\n+            return THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongTempoOption) {\n+            return THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkzMjg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozOTowNVrOGkocog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NjowM1rOGlWzPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NDYxMA==", "bodyText": "If I see correctly it is always the string \"adco\" put as the property name. Are all these ifs necessary?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441064610", "createdAt": "2020-06-16T18:39:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+        return new ThingUID(getThingTypeUID(teleinfoFrame), frameAdco.getAdco(),\n+                controllerHandler.getThing().getUID().getId());\n+    }\n+\n+    private ThingTypeUID getThingTypeUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameCbemmHcOption) {\n+            return THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmBaseOption) {\n+            return THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEjpOption) {\n+            return THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmTempoOption) {\n+            return THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccHcOption) {\n+            return THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccBaseOption) {\n+            return THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccEjpOption) {\n+            return THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccTempoOption) {\n+            return THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongHcOption) {\n+            return THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongBaseOption) {\n+            return THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongEjpOption) {\n+            return THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongTempoOption) {\n+            return THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+    }\n+\n+    private Map<String, Object> getThingProperties(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {\n+        Map<String, Object> properties = new HashMap<String, Object>();\n+        if (teleinfoFrame instanceof FrameAdco) {\n+            final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+            if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNDA2Mg==", "bodyText": "In this case (all constants have \"adco\" string value) you are right. But this IF block allows to prevent the scability.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441824062", "createdAt": "2020-06-17T20:46:03Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+        return new ThingUID(getThingTypeUID(teleinfoFrame), frameAdco.getAdco(),\n+                controllerHandler.getThing().getUID().getId());\n+    }\n+\n+    private ThingTypeUID getThingTypeUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameCbemmHcOption) {\n+            return THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmBaseOption) {\n+            return THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEjpOption) {\n+            return THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmTempoOption) {\n+            return THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccHcOption) {\n+            return THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccBaseOption) {\n+            return THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccEjpOption) {\n+            return THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccTempoOption) {\n+            return THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongHcOption) {\n+            return THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongBaseOption) {\n+            return THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongEjpOption) {\n+            return THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongTempoOption) {\n+            return THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+    }\n+\n+    private Map<String, Object> getThingProperties(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {\n+        Map<String, Object> properties = new HashMap<String, Object>();\n+        if (teleinfoFrame instanceof FrameAdco) {\n+            final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+            if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NDYxMA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk0MTYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/doc/datamodel.mdj", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo0MTo1MFrOGkoifw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo0NzozMlrOGlW2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NjExMQ==", "bodyText": "By coincidence, I have StarUML installed. But can you put a PNG of the model into this folder for those who haven't?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441066111", "createdAt": "2020-06-16T18:41:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/doc/datamodel.mdj", "diffHunk": "@@ -0,0 +1,14122 @@\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNDgyMA==", "bodyText": "No problem. It will be necessary to think of generating this image with each modification of the diagram", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441824820", "createdAt": "2020-06-17T20:47:32Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/doc/datamodel.mdj", "diffHunk": "@@ -0,0 +1,14122 @@\n+{", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2NjExMQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk0NTgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo0MzowMVrOGkolFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1MDoyOVrOGlW8WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2Njc3NQ==", "bodyText": "See above FrameAdco.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441066775", "createdAt": "2020-06-16T18:43:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+        return new ThingUID(getThingTypeUID(teleinfoFrame), frameAdco.getAdco(),\n+                controllerHandler.getThing().getUID().getId());\n+    }\n+\n+    private ThingTypeUID getThingTypeUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameCbemmHcOption) {\n+            return THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmBaseOption) {\n+            return THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEjpOption) {\n+            return THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmTempoOption) {\n+            return THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccHcOption) {\n+            return THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccBaseOption) {\n+            return THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccEjpOption) {\n+            return THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccTempoOption) {\n+            return THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongHcOption) {\n+            return THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongBaseOption) {\n+            return THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongEjpOption) {\n+            return THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongTempoOption) {\n+            return THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+    }\n+\n+    private Map<String, Object> getThingProperties(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {\n+        Map<String, Object> properties = new HashMap<String, Object>();\n+        if (teleinfoFrame instanceof FrameAdco) {\n+            final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+            if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            }\n+\n+            return properties;\n+        }\n+\n+        throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+    }\n+\n+    private String getRepresentationProperty(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjM5Mg==", "bodyText": "Actually, only ADCO frames are supported by the binding. The CJE, ICE2Q, ICE4Q and PMEPMI frames are not yot supported. These 4 frame types are not inherited from FrameAdco class.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441826392", "createdAt": "2020-06-17T20:50:29Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);\n+        final String representationProperty = getRepresentationProperty(thingUID.getThingTypeUID(), frameAdco);\n+        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withLabel(\"Teleinfo ADCO \" + frameAdco.getAdco()).withThingType(getThingTypeUID(frameAdco))\n+                .withBridge(controllerHandler.getThing().getUID()).withRepresentationProperty(representationProperty)\n+                .build();\n+\n+        thingDiscovered(discoveryResult);\n+    }\n+\n+    private ThingUID getThingUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+        return new ThingUID(getThingTypeUID(teleinfoFrame), frameAdco.getAdco(),\n+                controllerHandler.getThing().getUID().getId());\n+    }\n+\n+    private ThingTypeUID getThingTypeUID(final Frame teleinfoFrame) {\n+        if (teleinfoFrame instanceof FrameCbemmHcOption) {\n+            return THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmBaseOption) {\n+            return THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEjpOption) {\n+            return THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmTempoOption) {\n+            return THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccHcOption) {\n+            return THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccBaseOption) {\n+            return THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccEjpOption) {\n+            return THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbemmEvolutionIccTempoOption) {\n+            return THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongHcOption) {\n+            return THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongBaseOption) {\n+            return THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongEjpOption) {\n+            return THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else if (teleinfoFrame instanceof FrameCbetmLongTempoOption) {\n+            return THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID;\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+        }\n+    }\n+\n+    private Map<String, Object> getThingProperties(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {\n+        Map<String, Object> properties = new HashMap<String, Object>();\n+        if (teleinfoFrame instanceof FrameAdco) {\n+            final FrameAdco frameAdco = (FrameAdco) teleinfoFrame;\n+\n+            if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_BASE_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_HC_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_TEMPO_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thingTypeId)) {\n+                properties.put(THING_EJP_CBETM_ELECTRICITY_METER_PROPERTY_ADCO, frameAdco.getAdco());\n+            }\n+\n+            return properties;\n+        }\n+\n+        throw new IllegalStateException(\"Teleinfo frame type not supported: \" + teleinfoFrame.getClass());\n+    }\n+\n+    private String getRepresentationProperty(final ThingTypeUID thingTypeId, final Frame teleinfoFrame) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2Njc3NQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk2MzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo0ODozMFrOGkow3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1MToyMlrOGlW99g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2OTc4OQ==", "bodyText": "If I see correctly this list can be modified concurrently from different threads. You could make it synchronized:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<TeleinfoControllerHandlerListener> listeners = new ArrayList<>();\n          \n          \n            \n                private List<TeleinfoControllerHandlerListener> listeners = Collections.synchronizedList(new ArrayList<>());", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441069789", "createdAt": "2020-06-16T18:48:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+\n+/**\n+ * The {@link TeleinfoAbstractControllerHandler} class defines a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractControllerHandler extends BaseBridgeHandler {\n+\n+    private List<TeleinfoControllerHandlerListener> listeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNjgwNg==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441826806", "createdAt": "2020-06-17T20:51:22Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+\n+/**\n+ * The {@link TeleinfoAbstractControllerHandler} class defines a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractControllerHandler extends BaseBridgeHandler {\n+\n+    private List<TeleinfoControllerHandlerListener> listeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2OTc4OQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk2ODQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo0OTo1N1rOGko0BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1MjoxN1rOGlW_xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MDU5Ng==", "bodyText": "Syntactical sugar:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        TeleinfoControllerHandlerListener listener = listeners.get(i);\n          \n          \n            \n                        listener.onFrameReceived(this, frame);\n          \n          \n            \n                    }\n          \n          \n            \n                    listeners.forEach(l -> l.onFrameReceived(this, frame));", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441070596", "createdAt": "2020-06-16T18:49:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+\n+/**\n+ * The {@link TeleinfoAbstractControllerHandler} class defines a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractControllerHandler extends BaseBridgeHandler {\n+\n+    private List<TeleinfoControllerHandlerListener> listeners = new ArrayList<>();\n+\n+    public TeleinfoAbstractControllerHandler(@NonNull Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    public void addListener(final TeleinfoControllerHandlerListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    public void removeListener(final TeleinfoControllerHandlerListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    protected void fireOnFrameReceivedEvent(final Frame frame) {\n+        for (int i = 0; i < listeners.size(); i++) {\n+            TeleinfoControllerHandlerListener listener = listeners.get(i);\n+            listener.onFrameReceived(this, frame);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyNzI2OA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441827268", "createdAt": "2020-06-17T20:52:17Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractControllerHandler.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+\n+/**\n+ * The {@link TeleinfoAbstractControllerHandler} class defines a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractControllerHandler extends BaseBridgeHandler {\n+\n+    private List<TeleinfoControllerHandlerListener> listeners = new ArrayList<>();\n+\n+    public TeleinfoAbstractControllerHandler(@NonNull Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    public void addListener(final TeleinfoControllerHandlerListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    public void removeListener(final TeleinfoControllerHandlerListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    protected void fireOnFrameReceivedEvent(final Frame frame) {\n+        for (int i = 0; i < listeners.size(); i++) {\n+            TeleinfoControllerHandlerListener listener = listeners.get(i);\n+            listener.onFrameReceived(this, frame);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MDU5Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk3MTUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1MDo0OVrOGko12w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQxODoxNDo1M1rOGmntFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MTA2Nw==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441071067", "createdAt": "2020-06-16T18:50:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyOTI1OA==", "bodyText": "I don't know if the framework's log allows to log thing UID (?)", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441829258", "createdAt": "2020-06-17T20:56:13Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MTA2Nw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0OTU4OQ==", "bodyText": "Yes, it does:\n20:13:37.169 [ndlerExecutor-1] INFO  s.event.ThingStatusInfoChangedEvent:53 - 'lcn:module:b827ebfea4bb:17B4196847' changed from UNINITIALIZED (DISABLED) to INITIALIZING", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443149589", "createdAt": "2020-06-20T18:14:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MTA2Nw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk3NDAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1MToyOVrOGko3WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1MToyOVrOGko3WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3MTQ0OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441071448", "createdAt": "2020-06-16T18:51:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzk4OTc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1NjoyNFrOGkpBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODo1NjoyNFrOGkpBfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDA0NQ==", "bodyText": "See above and below.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441074045", "createdAt": "2020-06-16T18:56:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+            logger.debug(\"Controller is not online ({})\", bridgeStatusInfo.getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAwNDc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMDo1OFrOGkpLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMDo1OFrOGkpLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjU5Ng==", "bodyText": "After the the thing status is set to unknown, the framework starts to work with this thing: handleCommand() and dispose() can be invoked (concurrently). In this case I would remove it, since the statements until the ONLINE are executing fast, so setting it to unknown won't have any reasonable effect.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441076596", "createdAt": "2020-06-16T19:00:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+            logger.debug(\"Controller is not online ({})\", bridgeStatusInfo.getStatus());\n+            return;\n+        }\n+\n+        logger.debug(\"Controller is ONLINE. Starting Electricity Meter thing initialization\");\n+        updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAxMzY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMzo0MFrOGkpRQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMzo0MFrOGkpRQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3ODA4MA==", "bodyText": "getBridge() could return null. Same for getHandler().", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441078080", "createdAt": "2020-06-16T19:03:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+            logger.debug(\"Controller is not online ({})\", bridgeStatusInfo.getStatus());\n+            return;\n+        }\n+\n+        logger.debug(\"Controller is ONLINE. Starting Electricity Meter thing initialization\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        TeleinfoAbstractControllerHandler controllerHandler = (TeleinfoAbstractControllerHandler) getBridge()\n+                .getHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAxNTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowNDoxMlrOGkpSaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTowMjoxNFrOGlXTdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3ODM3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (ThingStatus.ONLINE.equals(status) == false) {\n          \n          \n            \n                    if (!ThingStatus.ONLINE.equals(status)) {", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441078377", "createdAt": "2020-06-16T19:04:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+            logger.debug(\"Controller is not online ({})\", bridgeStatusInfo.getStatus());\n+            return;\n+        }\n+\n+        logger.debug(\"Controller is ONLINE. Starting Electricity Meter thing initialization\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        TeleinfoAbstractControllerHandler controllerHandler = (TeleinfoAbstractControllerHandler) getBridge()\n+                .getHandler();\n+        controllerHandler.addListener(this);\n+        logger.debug(\"Electricity Meter initialization complete.\");\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands supported\n+    }\n+\n+    protected void updateStatesForBaseFrameOption(@NonNull FrameBaseOption frameBaseOption) {\n+        updateState(CHANNEL_BASE_FRAME_BASE, new DecimalType(frameBaseOption.getBase()));\n+    }\n+\n+    protected void updateStatesForHcFrameOption(@NonNull FrameHcOption frameHcOption) {\n+        updateState(CHANNEL_HC_FRAME_HCHC, new DecimalType(frameHcOption.getHchc()));\n+        updateState(CHANNEL_HC_FRAME_HCHP, new DecimalType(frameHcOption.getHchp()));\n+        updateState(CHANNEL_HC_FRAME_HHPHC, new StringType(frameHcOption.getHhphc().name()));\n+    }\n+\n+    protected void updateStatesForTempoFrameOption(@NonNull FrameTempoOption frameTempoOption) {\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJR, new DecimalType(frameTempoOption.getBbrhpjr()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJR, new DecimalType(frameTempoOption.getBbrhcjr()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJW, new DecimalType(frameTempoOption.getBbrhpjw()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJW, new DecimalType(frameTempoOption.getBbrhcjw()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJB, new DecimalType(frameTempoOption.getBbrhpjb()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJB, new DecimalType(frameTempoOption.getBbrhcjb()));\n+        updateState(CHANNEL_TEMPO_FRAME_HHPHC, new StringType(frameTempoOption.getHhphc().name()));\n+        updateState(CHANNEL_TEMPO_FRAME_PROGRAMME_CIRCUIT_1,\n+                new StringType(frameTempoOption.getProgrammeCircuit1().name()));\n+        updateState(CHANNEL_TEMPO_FRAME_PROGRAMME_CIRCUIT_2,\n+                new StringType(frameTempoOption.getProgrammeCircuit2().name()));\n+\n+        if (frameTempoOption.getDemain() == null) {\n+            updateState(CHANNEL_TEMPO_FRAME_DEMAIN, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_TEMPO_FRAME_DEMAIN, new StringType(frameTempoOption.getDemain().name()));\n+        }\n+    }\n+\n+    protected void updateStatesForEjpFrameOption(@NonNull FrameEjpOption frameEjpOption) {\n+        updateState(CHANNEL_EJP_FRAME_EJPHN, new DecimalType(frameEjpOption.getEjphn()));\n+        updateState(CHANNEL_EJP_FRAME_EJPHPM, new DecimalType(frameEjpOption.getEjphpm()));\n+\n+        if (frameEjpOption.getPejp() == null) {\n+            updateState(CHANNEL_EJP_FRAME_PEJP, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_EJP_FRAME_PEJP, new DecimalType(frameEjpOption.getPejp()));\n+        }\n+    }\n+\n+    @Override\n+    protected void updateStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        super.updateStatus(status, statusDetail, description);\n+\n+        if (ThingStatus.ONLINE.equals(status) == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzMjMxMA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441832310", "createdAt": "2020-06-17T21:02:14Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoAbstractElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoAbstractElectricityMeterHandler} class defines a skeleton for Electricity Meters handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractElectricityMeterHandler extends BaseThingHandler\n+        implements TeleinfoControllerHandlerListener {\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoAbstractElectricityMeterHandler.class);\n+\n+    public TeleinfoAbstractElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Electricity Meter thing handler {}.\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+\n+        Bridge bridge = getBridge();\n+        logger.debug(\"bridge = {}\", bridge);\n+        if (bridge != null) {\n+            bridgeStatusChanged(bridge.getStatusInfo());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Controller status changed to {}.\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, ERROR_OFFLINE_CONTROLLER_OFFLINE);\n+            logger.debug(\"Controller is not online ({})\", bridgeStatusInfo.getStatus());\n+            return;\n+        }\n+\n+        logger.debug(\"Controller is ONLINE. Starting Electricity Meter thing initialization\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        TeleinfoAbstractControllerHandler controllerHandler = (TeleinfoAbstractControllerHandler) getBridge()\n+                .getHandler();\n+        controllerHandler.addListener(this);\n+        logger.debug(\"Electricity Meter initialization complete.\");\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // no commands supported\n+    }\n+\n+    protected void updateStatesForBaseFrameOption(@NonNull FrameBaseOption frameBaseOption) {\n+        updateState(CHANNEL_BASE_FRAME_BASE, new DecimalType(frameBaseOption.getBase()));\n+    }\n+\n+    protected void updateStatesForHcFrameOption(@NonNull FrameHcOption frameHcOption) {\n+        updateState(CHANNEL_HC_FRAME_HCHC, new DecimalType(frameHcOption.getHchc()));\n+        updateState(CHANNEL_HC_FRAME_HCHP, new DecimalType(frameHcOption.getHchp()));\n+        updateState(CHANNEL_HC_FRAME_HHPHC, new StringType(frameHcOption.getHhphc().name()));\n+    }\n+\n+    protected void updateStatesForTempoFrameOption(@NonNull FrameTempoOption frameTempoOption) {\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJR, new DecimalType(frameTempoOption.getBbrhpjr()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJR, new DecimalType(frameTempoOption.getBbrhcjr()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJW, new DecimalType(frameTempoOption.getBbrhpjw()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJW, new DecimalType(frameTempoOption.getBbrhcjw()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHPJB, new DecimalType(frameTempoOption.getBbrhpjb()));\n+        updateState(CHANNEL_TEMPO_FRAME_BBRHCJB, new DecimalType(frameTempoOption.getBbrhcjb()));\n+        updateState(CHANNEL_TEMPO_FRAME_HHPHC, new StringType(frameTempoOption.getHhphc().name()));\n+        updateState(CHANNEL_TEMPO_FRAME_PROGRAMME_CIRCUIT_1,\n+                new StringType(frameTempoOption.getProgrammeCircuit1().name()));\n+        updateState(CHANNEL_TEMPO_FRAME_PROGRAMME_CIRCUIT_2,\n+                new StringType(frameTempoOption.getProgrammeCircuit2().name()));\n+\n+        if (frameTempoOption.getDemain() == null) {\n+            updateState(CHANNEL_TEMPO_FRAME_DEMAIN, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_TEMPO_FRAME_DEMAIN, new StringType(frameTempoOption.getDemain().name()));\n+        }\n+    }\n+\n+    protected void updateStatesForEjpFrameOption(@NonNull FrameEjpOption frameEjpOption) {\n+        updateState(CHANNEL_EJP_FRAME_EJPHN, new DecimalType(frameEjpOption.getEjphn()));\n+        updateState(CHANNEL_EJP_FRAME_EJPHPM, new DecimalType(frameEjpOption.getEjphpm()));\n+\n+        if (frameEjpOption.getPejp() == null) {\n+            updateState(CHANNEL_EJP_FRAME_PEJP, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_EJP_FRAME_PEJP, new DecimalType(frameEjpOption.getPejp()));\n+        }\n+    }\n+\n+    @Override\n+    protected void updateStatus(ThingStatus status, ThingStatusDetail statusDetail, @Nullable String description) {\n+        super.updateStatus(status, statusDetail, description);\n+\n+        if (ThingStatus.ONLINE.equals(status) == false) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3ODM3Nw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAyODk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowODoyM1rOGkpbPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTowNzo0M1rOGlXeQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MDYzOQ==", "bodyText": "You could combine the two ifs.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (controller != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441080639", "createdAt": "2020-06-16T19:08:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+        }\n+\n+        if (controller != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNTA3NA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441835074", "createdAt": "2020-06-17T21:07:43Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+        }\n+\n+        if (controller != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MDYzOQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAzODcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMToxOVrOGkphkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTowOToxNlrOGlXhTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjI1Ng==", "bodyText": "You could add a @SuppressWarnings(\"null\") to eliminate the compiler warning.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441082256", "createdAt": "2020-06-16T19:11:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+        }\n+\n+        if (controller != null) {\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);\n+            discoveryService.activate();\n+\n+            discoveryServiceRegs.put(controller.getThing().getUID(), bundleContext.registerService(\n+                    DiscoveryService.class.getName(), discoveryService, new Hashtable<String, Object>()));\n+\n+            return controller;\n+        }\n+\n+        if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbetmLongElectricityMeterHandler(thing);\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + thing.getThingTypeUID());\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof TeleinfoAbstractControllerHandler) {\n+            ServiceRegistration<?> serviceReg = this.discoveryServiceRegs.get(thingHandler.getThing().getUID());\n+            if (serviceReg != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzNTg1Mw==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441835853", "createdAt": "2020-06-17T21:09:16Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+        }\n+\n+        if (controller != null) {\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);\n+            discoveryService.activate();\n+\n+            discoveryServiceRegs.put(controller.getThing().getUID(), bundleContext.registerService(\n+                    DiscoveryService.class.getName(), discoveryService, new Hashtable<String, Object>()));\n+\n+            return controller;\n+        }\n+\n+        if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbetmLongElectricityMeterHandler(thing);\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + thing.getThingTypeUID());\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof TeleinfoAbstractControllerHandler) {\n+            ServiceRegistration<?> serviceReg = this.discoveryServiceRegs.get(thingHandler.getThing().getUID());\n+            if (serviceReg != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjI1Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MjM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoAbstractCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjozM1rOGkpj5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjozM1rOGkpj5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4Mjg1NQ==", "bodyText": "Please check the compiler warning.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441082855", "createdAt": "2020-06-16T19:12:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoAbstractCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+\n+/**\n+ * The {@link TeleinfoAbstractCbemmElectricityMeterHandler} class defines a skeleton for CBEMM Electricity Meters\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public abstract class TeleinfoAbstractCbemmElectricityMeterHandler extends TeleinfoAbstractElectricityMeterHandler {\n+\n+    public TeleinfoAbstractCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected void updateStatesForCommonCbemmChannels(@NonNull FrameCbemm frame) {\n+        // update common channels\n+        updateState(CHANNEL_CBEMM_ISOUSC, new DecimalType(frame.getIsousc()));\n+        updateState(CHANNEL_CBEMM_PTEC, new StringType(frame.getPtec().name()));\n+        if (frame.getImax() == null) {\n+            updateState(CHANNEL_CBEMM_IMAX, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_CBEMM_IMAX, new DecimalType(frame.getImax()));\n+        }\n+\n+        if (frame.getAdps() == null) {\n+            updateState(CHANNEL_CBEMM_ADPS, UnDefType.NULL);\n+        } else {\n+            updateState(CHANNEL_CBEMM_ADPS, new DecimalType(frame.getAdps()));\n+        }\n+        updateState(CHANNEL_CBEMM_IINST, new DecimalType(frame.getIinst()));\n+\n+        BigDecimal powerFactor = (BigDecimal) getThing().getChannel(CHANNEL_CBEMM_CURRENT_POWER).getConfiguration()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0NTQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMzoyN1rOGkpl4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjo0NzoxOFrOGmTlRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MzM2Mw==", "bodyText": "Can you use your real name?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441083363", "createdAt": "2020-06-16T19:13:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzODEyNQ==", "bodyText": "@olivierkeke", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441838125", "createdAt": "2020-06-17T21:14:08Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MzM2Mw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxOTkxMA==", "bodyText": "OK, done!", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442819910", "createdAt": "2020-06-19T12:47:18Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MzM2Mw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA1MzgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxNTo0NlrOGkprBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMToyMDo1NFrOGlX2Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NDY3Nw==", "bodyText": "adco can be null. You can handle this easily:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (adco.equalsIgnoreCase(frameCbemmBaseOption.getAdco())) {\n          \n          \n            \n                    if (frameCbemmBaseOption.getAdco().equalsIgnoreCase(adco)) {", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441084677", "createdAt": "2020-06-16T19:15:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoBaseCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoBaseCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmBaseOption frameCbemmBaseOption = (FrameCbemmBaseOption) frame;\n+\n+        String adco = (String) getThing().getConfiguration().get(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO);\n+        if (adco.equalsIgnoreCase(frameCbemmBaseOption.getAdco())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MTE4Mw==", "bodyText": "ADCO property is mandatory, but your suggestion is more strong", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441841183", "createdAt": "2020-06-17T21:20:54Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoBaseCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoBaseCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmBaseOption frameCbemmBaseOption = (FrameCbemmBaseOption) frame;\n+\n+        String adco = (String) getThing().getConfiguration().get(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO);\n+        if (adco.equalsIgnoreCase(frameCbemmBaseOption.getAdco())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NDY3Nw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA1NTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoEjpCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxNjoxM1rOGkpsFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMToyMToxNVrOGlX2vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NDk1MA==", "bodyText": "See above and below.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441084950", "createdAt": "2020-06-16T19:16:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoEjpCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+\n+/**\n+ * The {@link TeleinfoEjpCbemmElectricityMeterHandler} class defines a handler for a EJB CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoEjpCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoEjpCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmEjpOption frameCbemmEjpOption = (FrameCbemmEjpOption) frame;\n+\n+        String adco = (String) getThing().getConfiguration().get(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO);\n+        if (adco.equalsIgnoreCase(frameCbemmEjpOption.getAdco())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MTM0Mw==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441841343", "createdAt": "2020-06-17T21:21:15Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoEjpCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+\n+/**\n+ * The {@link TeleinfoEjpCbemmElectricityMeterHandler} class defines a handler for a EJB CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoEjpCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoEjpCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmEjpOption frameCbemmEjpOption = (FrameCbemmEjpOption) frame;\n+\n+        String adco = (String) getThing().getConfiguration().get(THING_EJP_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO);\n+        if (adco.equalsIgnoreCase(frameCbemmEjpOption.getAdco())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NDk1MA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA3NzM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyMzowMlrOGkp6Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMToyNzo1OVrOGlYCtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4ODUzOA==", "bodyText": "Are you sure this is always of type FrameCbemmBaseOption?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441088538", "createdAt": "2020-06-16T19:23:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoBaseCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoBaseCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmBaseOption frameCbemmBaseOption = (FrameCbemmBaseOption) frame;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NDQwNQ==", "bodyText": "Yes. The electricity meter broadcasts only one Teleinfo frame type", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441844405", "createdAt": "2020-06-17T21:27:59Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author olivierkeke - Change ADCO property to parameter\n+ */\n+public class TeleinfoBaseCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoBaseCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        final FrameCbemmBaseOption frameCbemmBaseOption = (FrameCbemmBaseOption) frame;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4ODUzOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA5OTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/cbemm/FrameCbemmBaseOption.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOTo0MFrOGkqHkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTozMDowMFrOGlYGSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTk4Ng==", "bodyText": "Does this have any function? Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441091986", "createdAt": "2020-06-16T19:29:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/cbemm/FrameCbemmBaseOption.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.cbemm;\n+\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+\n+/**\n+ * The {@link FrameCbemmBaseOption} class defines a CBEMM Teleinfo frame with Base option.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class FrameCbemmBaseOption extends FrameCbemm implements FrameBaseOption {\n+\n+    private static final long serialVersionUID = 5560141193379363335L;\n+\n+    private int base;\n+\n+    public FrameCbemmBaseOption() {\n+        // default constructor\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NTMyMw==", "bodyText": "Javabeans convention", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441845323", "createdAt": "2020-06-17T21:30:00Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/cbemm/FrameCbemmBaseOption.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.cbemm;\n+\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+\n+/**\n+ * The {@link FrameCbemmBaseOption} class defines a CBEMM Teleinfo frame with Base option.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class FrameCbemmBaseOption extends FrameCbemm implements FrameBaseOption {\n+\n+    private static final long serialVersionUID = 5560141193379363335L;\n+\n+    private int base;\n+\n+    public FrameCbemmBaseOption() {\n+        // default constructor\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTk4Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODExMDk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTozMzoxOVrOGkqPAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTozNDoxNlrOGlYNyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5Mzg4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"Teleinfo inputStream is null\");", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441093888", "createdAt": "2020-06-16T19:33:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NzI0Mw==", "bodyText": "\"Teleinfo inputstream not null\" = \"Teleinfo inputstream must not be null\" for me.\nBut Ok for your suggestion", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441847243", "createdAt": "2020-06-17T21:34:16Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5Mzg4OA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODExNDIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTozNDoyMFrOGkqRBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTozNToxMVrOGlYPWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5NDQwNg==", "bodyText": "You could remove the exception catch clause when using this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n          \n          \n            \n                        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441094406", "createdAt": "2020-06-16T19:34:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0NzY0MQ==", "bodyText": "Ok, thanks", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441847641", "createdAt": "2020-06-17T21:35:11Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5NDQwNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODEyMjE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTozNzowNVrOGkqWPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTozNjoyNFrOGlYRcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5NTc0Mg==", "bodyText": "Syntactical sugar\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n          \n          \n            \n                        @Override\n          \n          \n            \n                        public Void call() throws Exception {\n          \n          \n            \n                    Future<Void> seekNextHeaderFrameTask = executorService.submit(() -> {", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441095742", "createdAt": "2020-06-16T19:37:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0ODE3OA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441848178", "createdAt": "2020-06-17T21:36:24Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5NTc0Mg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODE5MTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1ODoxMVrOGkrByw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNTowNDo1OFrOGmYDaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNjg5MQ==", "bodyText": "Is dataType needed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441106891", "createdAt": "2020-06-16T19:58:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 623}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1MTgyMw==", "bodyText": "dataType parameter is used to set the generic return type of function.\nI don't know if there is another solution", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441851823", "createdAt": "2020-06-17T21:44:50Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNjg5MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 623}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5MzE2MQ==", "bodyText": "Seems to work without dataType so I remove that.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442893161", "createdAt": "2020-06-19T15:04:58Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNjg5MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 623}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODE5NDkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1OTozMFrOGkrEJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQxMjoxNTozMVrOGmmTKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNzQ5NQ==", "bodyText": "Since we want to get rid of Apache Commons, can you replace this with native Java code? See #7722. I think this can be done with String.format().", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441107495", "createdAt": "2020-06-16T19:59:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }\n+\n+    private ProgrammeCircuit1 convertProgrammeCircuit1(char value) {\n+        String prgCircuit1 = computeProgrammeCircuitBinaryValue(value).substring(3, 5);\n+        switch (prgCircuit1) {\n+            case \"01\":\n+                return ProgrammeCircuit1.A;\n+            case \"10\":\n+                return ProgrammeCircuit1.B;\n+            case \"11\":\n+                return ProgrammeCircuit1.C;\n+            default:\n+                final String error = String.format(\"Programme circuit 1 '%s' is unknown\", prgCircuit1);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private ProgrammeCircuit2 convertProgrammeCircuit2(char value) {\n+        String prgCircuit2 = computeProgrammeCircuitBinaryValue(value).substring(5, 8);\n+        switch (prgCircuit2) {\n+            case \"000\":\n+                return ProgrammeCircuit2.P0;\n+            case \"001\":\n+                return ProgrammeCircuit2.P1;\n+            case \"010\":\n+                return ProgrammeCircuit2.P2;\n+            case \"011\":\n+                return ProgrammeCircuit2.P3;\n+            case \"100\":\n+                return ProgrammeCircuit2.P4;\n+            case \"101\":\n+                return ProgrammeCircuit2.P5;\n+            case \"110\":\n+                return ProgrammeCircuit2.P6;\n+            case \"111\":\n+                return ProgrammeCircuit2.P7;\n+            default:\n+                final String error = String.format(\"Programme circuit 2 '%s' is unknown\", prgCircuit2);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private String computeProgrammeCircuitBinaryValue(char value) {\n+        return StringUtils.leftPad(Integer.toBinaryString(value), 8, \"0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 666}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1MjQ0NA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441852444", "createdAt": "2020-06-17T21:46:15Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }\n+\n+    private ProgrammeCircuit1 convertProgrammeCircuit1(char value) {\n+        String prgCircuit1 = computeProgrammeCircuitBinaryValue(value).substring(3, 5);\n+        switch (prgCircuit1) {\n+            case \"01\":\n+                return ProgrammeCircuit1.A;\n+            case \"10\":\n+                return ProgrammeCircuit1.B;\n+            case \"11\":\n+                return ProgrammeCircuit1.C;\n+            default:\n+                final String error = String.format(\"Programme circuit 1 '%s' is unknown\", prgCircuit1);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private ProgrammeCircuit2 convertProgrammeCircuit2(char value) {\n+        String prgCircuit2 = computeProgrammeCircuitBinaryValue(value).substring(5, 8);\n+        switch (prgCircuit2) {\n+            case \"000\":\n+                return ProgrammeCircuit2.P0;\n+            case \"001\":\n+                return ProgrammeCircuit2.P1;\n+            case \"010\":\n+                return ProgrammeCircuit2.P2;\n+            case \"011\":\n+                return ProgrammeCircuit2.P3;\n+            case \"100\":\n+                return ProgrammeCircuit2.P4;\n+            case \"101\":\n+                return ProgrammeCircuit2.P5;\n+            case \"110\":\n+                return ProgrammeCircuit2.P6;\n+            case \"111\":\n+                return ProgrammeCircuit2.P7;\n+            default:\n+                final String error = String.format(\"Programme circuit 2 '%s' is unknown\", prgCircuit2);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private String computeProgrammeCircuitBinaryValue(char value) {\n+        return StringUtils.leftPad(Integer.toBinaryString(value), 8, \"0\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNzQ5NQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 666}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEyNjU3MQ==", "bodyText": "Done with String.format(\"%8s\",Integer.toBinaryString(value)).replace(' ', '0')", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443126571", "createdAt": "2020-06-20T12:15:31Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+\n+        Future<Map<Label, Object>> nextFrameFuture = executorService.submit(new Callable<Map<Label, Object>>() {\n+            @Override\n+            public Map<Label, Object> call() throws Exception {\n+                // read label values\n+                Map<Label, Object> frameValues = new HashMap<>();\n+                while ((groupLine = bufferedReader.readLine()) != null && !isHeaderFrame(groupLine)) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+\n+                    String[] groupLineTokens = groupLine.split(\"\\\\s\");\n+                    if (groupLineTokens.length != 2 && groupLineTokens.length != 3) {\n+                        final String error = String.format(\"The groupLine '%1$s' is incomplete\", groupLine);\n+                        throw new InvalidFrameException(error);\n+                    }\n+                    String labelStr = groupLineTokens[0];\n+                    String valueString = groupLineTokens[1];\n+\n+                    // verify integrity (through checksum)\n+                    char checksum = (groupLineTokens.length == 3 ? groupLineTokens[2].charAt(0) : ' ');\n+                    char computedChecksum = FrameUtil.computeGroupLineChecksum(labelStr, valueString);\n+                    if (computedChecksum != checksum) {\n+                        logger.trace(\"computedChecksum = {}\", computedChecksum);\n+                        logger.trace(\"checksum = {}\", checksum);\n+                        final String error = String.format(\n+                                \"The groupLine '%s' is corrupted (integrity not checked). Actual checksum: '%s' / Expected checksum: '%s'\",\n+                                groupLine, checksum, computedChecksum);\n+                        throw new InvalidFrameException(error);\n+                    }\n+\n+                    Label label;\n+                    try {\n+                        label = Label.valueOf(labelStr);\n+                    } catch (IllegalArgumentException e) {\n+                        if (autoRepairInvalidADPSgroupLine && labelStr.startsWith(Label.ADPS.name())) {\n+                            // in this hardware issue, label variable is composed by label name and value. E.g: ADPS032\n+                            logger.warn(\"Try to auto repair malformed ADPS groupLine '{}'\", labelStr);\n+                            label = Label.ADPS;\n+                            valueString = labelStr.substring(Label.ADPS.name().length());\n+                        } else {\n+                            final String error = String.format(\"The label '%s' is unknown\", labelStr);\n+                            throw new InvalidFrameException(error);\n+                        }\n+                    }\n+\n+                    Class<?> labelType = label.getType();\n+                    Converter converter = LABEL_VALUE_CONVERTERS.get(labelType);\n+                    if (converter == null) {\n+                        final String error = String.format(\"No converter founded for '%s' label type\", labelType);\n+                        throw new IllegalStateException(error);\n+                    }\n+                    try {\n+                        Object value = converter.convert(valueString);\n+\n+                        frameValues.put(label, value);\n+                    } catch (ConvertionException e) {\n+                        final String error = String.format(\"An error occurred during '%s' value conversion\",\n+                                valueString);\n+                        throw new InvalidFrameException(error, e);\n+                    }\n+                }\n+\n+                return frameValues;\n+            }\n+        });\n+\n+        try {\n+            logger.debug(\"reading data frame...\");\n+            logger.trace(\"readingFrameTimeoutInMs = {}\", readingFrameTimeoutInMs);\n+            Map<Label, Object> frameValues = nextFrameFuture.get(readingFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            // build the frame from map values\n+            final Frame frame = buildFrame(frameValues);\n+            frame.setTimestamp(LocalDate.now());\n+            frame.setId(UUID.randomUUID());\n+\n+            logger.debug(\"readNextFrame() [end]\");\n+            return frame;\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?\n+        }\n+    }\n+\n+    public long getWaitNextHeaderFrameTimeoutInMs() {\n+        return waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+    }\n+\n+    public long getReadingFrameTimeoutInMs() {\n+        return readingFrameTimeoutInMs;\n+    }\n+\n+    public void setReadingFrameTimeoutInMs(long readingFrameTimeoutInMs) {\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+    }\n+\n+    public boolean isAutoRepairInvalidADPSgroupLine() {\n+        return autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    public void setAutoRepairInvalidADPSgroupLine(boolean autoRepairInvalidADPSgroupLine) {\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public int read() throws IOException {\n+        throw new UnsupportedOperationException(\"The 'read()' is not supported\");\n+    }\n+\n+    private boolean isHeaderFrame(final String line) {\n+        // A new teleinfo trame begin with '3' and '2' bytes (END OF TEXT et START OF TEXT)\n+        return (line != null && line.length() > 1 && line.codePointAt(0) == 3 && line.codePointAt(1) == 2);\n+    }\n+\n+    private Frame buildFrame(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        if (frameValues.containsKey(Label.IINST1)) {\n+            if (frameValues.containsKey(Label.IMAX1)) {\n+                return buildFrameCbetmLong(frameValues);\n+            } else {\n+                return buildFrameCbetmShort(frameValues);\n+            }\n+        } else if (frameValues.containsKey(Label.PAPP)) {\n+            return buildFrameCbemmEvolutionIcc(frameValues);\n+        } else {\n+            return buildFrameCbemm(frameValues);\n+        }\n+    }\n+\n+    private FrameCbetmLong buildFrameCbetmLong(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [start]\");\n+        final FrameCbetmLong frameCbetm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbetm = buildFrameCbetmLongEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbetm = buildFrameCbetmLongTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbetmLong(Map<Label, Object>) [end]\");\n+        return frameCbetm;\n+    }\n+\n+    private void setCbetmCommonFrameFields(final FrameCbetmLong frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setImax1(getRequiredLabelValue(Label.IMAX1, Integer.class, frameValues));\n+        frame.setImax2(getRequiredLabelValue(Label.IMAX2, Integer.class, frameValues));\n+        frame.setImax3(getRequiredLabelValue(Label.IMAX3, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setPmax(getRequiredLabelValue(Label.PMAX, Integer.class, frameValues));\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        frame.setPpot(getRequiredLabelValue(Label.PPOT, String.class, frameValues));\n+        logger.trace(\"setCbetmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbetmLongBaseOption buildFrameCbetmLongBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongBaseOption frame = new FrameCbetmLongBaseOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongHcOption buildFrameCbetmLongHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongHcOption frame = new FrameCbetmLongHcOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongEjpOption buildFrameCbetmLongEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongEjpOption frame = new FrameCbetmLongEjpOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbetmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmLongTempoOption buildFrameCbetmLongTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbetmLongTempoOption frame = new FrameCbetmLongTempoOption();\n+        setCbetmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbetmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbetmShort buildFrameCbetmShort(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [start]\");\n+        FrameCbetmShort frame = new FrameCbetmShort();\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIinst1(getRequiredLabelValue(Label.IINST1, Integer.class, frameValues));\n+        frame.setIinst2(getRequiredLabelValue(Label.IINST2, Integer.class, frameValues));\n+        frame.setIinst3(getRequiredLabelValue(Label.IINST3, Integer.class, frameValues));\n+        frame.setAdir1(getOptionalLabelValue(Label.ADIR1, Integer.class, frameValues));\n+        frame.setAdir2(getOptionalLabelValue(Label.ADIR2, Integer.class, frameValues));\n+        frame.setAdir3(getOptionalLabelValue(Label.ADIR3, Integer.class, frameValues));\n+        logger.trace(\"buildFrameCbetmShort(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemm buildFrameCbemm(final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [start]\");\n+        final FrameCbemm frameCbemm;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemm = buildFrameCbemmEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemm = buildFrameCbemmTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+        logger.trace(\"buildFrameCbemm(Map<Label, Object>) [end]\");\n+        return frameCbemm;\n+    }\n+\n+    private void setCbemmCommonFrameFields(final FrameCbemm frame, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        frame.setAdco(getRequiredLabelValue(Label.ADCO, String.class, frameValues));\n+        frame.setIsousc(getRequiredLabelValue(Label.ISOUSC, Integer.class, frameValues));\n+        frame.setIinst(getRequiredLabelValue(Label.IINST, Integer.class, frameValues));\n+        frame.setImax(getOptionalLabelValue(Label.IMAX, Integer.class, frameValues));\n+        frame.setPtec(getRequiredLabelValue(Label.PTEC, Ptec.class, frameValues));\n+        frame.setAdps(getOptionalLabelValue(Label.ADPS, Integer.class, frameValues));\n+        frame.setMotdetat(getRequiredLabelValue(Label.MOTDETAT, String.class, frameValues));\n+        logger.trace(\"setCbemmCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmBaseOption buildFrameCbemmBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmBaseOption frame = new FrameCbemmBaseOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmHcOption buildFrameCbemmHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmHcOption frame = new FrameCbemmHcOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEjpOption buildFrameCbemmEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEjpOption frame = new FrameCbemmEjpOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmTempoOption buildFrameCbemmTempoOption(final Map<Label, Object> frameValues,\n+            ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2) throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmTempoOption frame = new FrameCbemmTempoOption();\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIcc buildFrameCbemmEvolutionIcc(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [start]\");\n+        final FrameCbemmEvolutionIcc frameCbemmEvoIcc;\n+        String optionTarif = getRequiredLabelValue(Label.OPTARIF, String.class, frameValues);\n+        if (\"BASE\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccBaseOption(frameValues);\n+        } else if (\"HC..\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccHcOption(frameValues);\n+        } else if (\"EJP.\".equals(optionTarif)) {\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccEjpOption(frameValues);\n+        } else if (optionTarif.startsWith(\"BBR\") && optionTarif.length() == 4) {\n+            ProgrammeCircuit1 prgCircuit1 = convertProgrammeCircuit1(optionTarif.charAt(3));\n+            ProgrammeCircuit2 prgCircuit2 = convertProgrammeCircuit2(optionTarif.charAt(3));\n+            frameCbemmEvoIcc = buildFrameCbemmEvolutionIccTempoOption(frameValues, prgCircuit1, prgCircuit2);\n+        } else {\n+            final String error = String.format(\"The option Tarif '%s' is not supported\", optionTarif);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        logger.trace(\"buildFrameCbemmEvolutionIcc(Map<Label, Object>) [end]\");\n+        return frameCbemmEvoIcc;\n+    }\n+\n+    private void setCbemmEvolutionIccCommonFrameFields(final FrameCbemmEvolutionIcc frame,\n+            final Map<Label, Object> frameValues) throws InvalidFrameException {\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [start]\");\n+        setCbemmCommonFrameFields(frame, frameValues);\n+        frame.setPapp(getRequiredLabelValue(Label.PAPP, Integer.class, frameValues));\n+        logger.trace(\"setCbemmEvolutionIccCommonFrameFields(Frame, Map<Label, Object>) [end]\");\n+    }\n+\n+    private FrameCbemmEvolutionIccBaseOption buildFrameCbemmEvolutionIccBaseOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccBaseOption frame = new FrameCbemmEvolutionIccBaseOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameBaseOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccBaseOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccHcOption buildFrameCbemmEvolutionIccHcOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccHcOption frame = new FrameCbemmEvolutionIccHcOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameHcOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccHcOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccTempoOption buildFrameCbemmEvolutionIccTempoOption(\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccTempoOption frame = new FrameCbemmEvolutionIccTempoOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameTempoOptionFields(frame, frameValues, prgCircuit1, prgCircuit2);\n+        logger.trace(\"buildFrameCbemmEvolutionIccTempoOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private FrameCbemmEvolutionIccEjpOption buildFrameCbemmEvolutionIccEjpOption(final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [start]\");\n+        FrameCbemmEvolutionIccEjpOption frame = new FrameCbemmEvolutionIccEjpOption();\n+        setCbemmEvolutionIccCommonFrameFields(frame, frameValues);\n+        setFrameEjpOptionFields(frame, frameValues);\n+        logger.trace(\"buildFrameCbemmEvolutionIccEjpOption(Map<Label, Object>) [end]\");\n+        return frame;\n+    }\n+\n+    private void setFrameBaseOptionFields(final FrameBaseOption frameBaseOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [start]\");\n+        frameBaseOption.setBase(getRequiredLabelValue(Label.BASE, Integer.class, frameValues));\n+        logger.trace(\"setFrameBaseOptionFields(FrameBaseOption) [end]\");\n+    }\n+\n+    private void setFrameHcOptionFields(final FrameHcOption frameHcOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [start]\");\n+        frameHcOption.setHchc(getRequiredLabelValue(Label.HCHC, Integer.class, frameValues));\n+        frameHcOption.setHchp(getRequiredLabelValue(Label.HCHP, Integer.class, frameValues));\n+        frameHcOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        logger.trace(\"setFrameHcOptionFields(FrameHcOption) [end]\");\n+    }\n+\n+    private void setFrameEjpOptionFields(final FrameEjpOption frameEjpOption, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [start]\");\n+        frameEjpOption.setEjphn(getRequiredLabelValue(Label.EJPHN, Integer.class, frameValues));\n+        frameEjpOption.setEjphpm(getRequiredLabelValue(Label.EJPHPM, Integer.class, frameValues));\n+        frameEjpOption.setPejp(getOptionalLabelValue(Label.PEJP, Integer.class, frameValues));\n+        logger.trace(\"setFrameEjpOptionFields(FrameEjpOption) [end]\");\n+    }\n+\n+    private void setFrameTempoOptionFields(final FrameTempoOption frameTempoOption,\n+            final Map<Label, Object> frameValues, ProgrammeCircuit1 prgCircuit1, ProgrammeCircuit2 prgCircuit2)\n+            throws InvalidFrameException {\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [start]\");\n+        frameTempoOption.setBbrhpjr(getRequiredLabelValue(Label.BBRHPJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjr(getRequiredLabelValue(Label.BBRHCJR, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjw(getRequiredLabelValue(Label.BBRHPJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjw(getRequiredLabelValue(Label.BBRHCJW, Integer.class, frameValues));\n+        frameTempoOption.setBbrhpjb(getRequiredLabelValue(Label.BBRHPJB, Integer.class, frameValues));\n+        frameTempoOption.setBbrhcjb(getRequiredLabelValue(Label.BBRHCJB, Integer.class, frameValues));\n+        frameTempoOption.setDemain(getOptionalLabelValue(Label.DEMAIN, CouleurDemain.class, frameValues));\n+        frameTempoOption.setHhphc(getRequiredLabelValue(Label.HHPHC, Hhphc.class, frameValues));\n+        frameTempoOption.setProgrammeCircuit1(prgCircuit1);\n+        frameTempoOption.setProgrammeCircuit2(prgCircuit2);\n+        logger.trace(\"setFrameTempoOptionFields(FrameTempoOption) [end]\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getRequiredLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues)\n+            throws InvalidFrameException {\n+        if (!frameValues.containsKey(label)) {\n+            final String error = String.format(\"The required label '%1$s' is missing in frame\", label);\n+            throw new InvalidFrameException(error);\n+        }\n+\n+        return (T) frameValues.get(label);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getOptionalLabelValue(Label label, Class<T> dataType, final Map<Label, Object> frameValues) {\n+        return (T) frameValues.get(label);\n+    }\n+\n+    private ProgrammeCircuit1 convertProgrammeCircuit1(char value) {\n+        String prgCircuit1 = computeProgrammeCircuitBinaryValue(value).substring(3, 5);\n+        switch (prgCircuit1) {\n+            case \"01\":\n+                return ProgrammeCircuit1.A;\n+            case \"10\":\n+                return ProgrammeCircuit1.B;\n+            case \"11\":\n+                return ProgrammeCircuit1.C;\n+            default:\n+                final String error = String.format(\"Programme circuit 1 '%s' is unknown\", prgCircuit1);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private ProgrammeCircuit2 convertProgrammeCircuit2(char value) {\n+        String prgCircuit2 = computeProgrammeCircuitBinaryValue(value).substring(5, 8);\n+        switch (prgCircuit2) {\n+            case \"000\":\n+                return ProgrammeCircuit2.P0;\n+            case \"001\":\n+                return ProgrammeCircuit2.P1;\n+            case \"010\":\n+                return ProgrammeCircuit2.P2;\n+            case \"011\":\n+                return ProgrammeCircuit2.P3;\n+            case \"100\":\n+                return ProgrammeCircuit2.P4;\n+            case \"101\":\n+                return ProgrammeCircuit2.P5;\n+            case \"110\":\n+                return ProgrammeCircuit2.P6;\n+            case \"111\":\n+                return ProgrammeCircuit2.P7;\n+            default:\n+                final String error = String.format(\"Programme circuit 2 '%s' is unknown\", prgCircuit2);\n+                throw new IllegalStateException(error);\n+        }\n+    }\n+\n+    private String computeProgrammeCircuitBinaryValue(char value) {\n+        return StringUtils.leftPad(Integer.toBinaryString(value), 8, \"0\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwNzQ5NQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 666}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODIzNDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDoxMjozNlrOGkrdOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQwODoxNjo1MlrOGmqcwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExMzkxNQ==", "bodyText": "Do you want to enforce a timeout of BufferedReader.readLine() with this Callable? Isn't readLine() returning null, instead of blocking when using it with serial interfaces?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441113915", "createdAt": "2020-06-16T20:12:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NDQzOA==", "bodyText": "The Teleinfo protocol defines a timeout between two frames", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441854438", "createdAt": "2020-06-17T21:51:04Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExMzkxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NTk5Mw==", "bodyText": "If I see correctly the timeout is 33.4ms and you multiplied it with 100. So, the code in the Callable is interrupted after 3.3sec.. But I think the timeout never kicks in, since the timeout of the serial port is set to 250ms in TeleinfoSerialControllerHandler:177. So, you could remove the sumbit()s and execute the code directly.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443155993", "createdAt": "2020-06-20T19:59:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExMzkxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2MzUwNA==", "bodyText": "The Teleinfo protocol defines this timeout to 33.4ms, but with this default timeout, the binding throws always timeout errors. That's why, I have override the timeout to 3,34 s.\nI had imagined setting this timeout to be configurable so that the user can overload the official timeout (33,4ms), but I am afraid that a new user does not think of modifying this parameter if errors occurred and that the user experience is very bad.\nThe timeout of the serial port (250ms) and this timeout are different. You could receive data between end of frame and start of frame due to, for example, hardware issues. In this case, the timeout of serial port will never be triggered when the delay could be triggered", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443163504", "createdAt": "2020-06-20T22:08:57Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExMzkxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5NDU2Mg==", "bodyText": "I agree with you that 33ms is too short for the JVM to handle it correctly and that the timeout shouldn't be configureable by the user. I guess you mean loose contact or so, that the serial port detects data continuously, where is no data. This case should be very rare, since you have a parity bit, so garbage will be dropped at operating system driver level. Is a correct communication possible at all, in this case?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443194562", "createdAt": "2020-06-21T08:16:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,682 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConvertionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME = 33400;\n+    public static long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader = null;\n+    private InputStream teleinfoInputStream = null;\n+    private String groupLine = null;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME, DEFAULT_TIMEOUT_READING_FRAME,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream not null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        try {\n+            this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, \"ASCII\"));\n+            this.teleinfoInputStream = teleinfoInputStream;\n+        } catch (UnsupportedEncodingException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+        logger.debug(\"readNextFrame() [start]\");\n+\n+        // seek the next header frame\n+        Future<Void> seekNextHeaderFrameTask = executorService.submit(new Callable<Void>() {\n+            @Override\n+            public Void call() throws Exception {\n+                while (!isHeaderFrame(groupLine)) {\n+                    groupLine = bufferedReader.readLine();\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(\"groupLine = {}\", groupLine);\n+                    }\n+                    if (groupLine == null) { // end of stream\n+                        logger.trace(\"end of stream reached !\");\n+                        return null;\n+                    }\n+                }\n+\n+                logger.trace(\"header frame found !\");\n+                return null;\n+            }\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExMzkxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI0MjM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/ConvertionException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDoxNToyMFrOGkridA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMTo1MjowNVrOGlYrew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNTI1Mg==", "bodyText": "Typo", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441115252", "createdAt": "2020-06-16T20:15:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/ConvertionException.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+/**\n+ * The {@link ConvertionException} class defines a conversion exception.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class ConvertionException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NDg0Mw==", "bodyText": "Lol. Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441854843", "createdAt": "2020-06-17T21:52:05Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/ConvertionException.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+/**\n+ * The {@link ConvertionException} class defines a conversion exception.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class ConvertionException extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNTI1Mg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI0OTQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/Label.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDoxNzozOVrOGkrnGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDowNjo0NVrOGmoH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNjQ0MQ==", "bodyText": "Could you add the NonNullByDefault annotation?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441116441", "createdAt": "2020-06-16T20:17:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/Label.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+\n+/**\n+ * The {@link Label} enum defines all Teleinfo labels and their format.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public enum Label {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1NjQ3Nw==", "bodyText": "@fwolter what benefits of this annotation?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441856477", "createdAt": "2020-06-17T21:56:00Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/Label.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+\n+/**\n+ * The {@link Label} enum defines all Teleinfo labels and their format.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public enum Label {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNjQ0MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjQ2Mg==", "bodyText": "You get free null checks at compile time. In this case you \"see\" (without annotation) that there won't be any null dereferences. However, it doesn't hurt adding it. It's required by the coding guidelines https://www.openhab.org/docs/developer/guidelines.html#null-annotations", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443156462", "createdAt": "2020-06-20T20:06:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/Label.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.reader.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.reader.common.Ptec;\n+\n+/**\n+ * The {@link Label} enum defines all Teleinfo labels and their format.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public enum Label {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExNjQ0MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI1OTM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDoyMDo0M1rOGkrtOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDoxMDowNVrOGmoIqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExODAwOA==", "bodyText": "Does this work when using more than one bridge with a different serial port? Or with other applications beside openHAB?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441118008", "createdAt": "2020-06-16T20:20:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReader;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderAdaptor;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderListener;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.RXTXPort;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * The {@link TeleinfoSerialportReader} class defines the Serial port implementation of {@link TeleinfoReader}.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialportReader extends TeleinfoReaderAdaptor {\n+\n+    private static Logger logger = LoggerFactory.getLogger(TeleinfoSerialportReader.class);\n+\n+    private String serialPortName;\n+    private long refreshInterval;\n+\n+    private Timer teleinfoSerialportReaderTimer;\n+    private SerialPort serialPort;\n+    private long waitNextHeaderFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME;\n+    private long readingFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME;\n+\n+    public TeleinfoSerialportReader(String serialPortName, long refreshInterval) {\n+        this.serialPortName = serialPortName;\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        logger.debug(\"open() [start]\");\n+\n+        CommPortIdentifier portIdentifier;\n+        try {\n+            logger.trace(\"serialPortName = {}\", serialPortName);\n+            System.setProperty(\"gnu.io.rxtx.SerialPorts\", serialPortName); // Workaround to force serial port detection\n+                                                                           // on Linux", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1ODgyNQ==", "bodyText": "This code line is copy-paste from Zwave binding", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441858825", "createdAt": "2020-06-17T22:01:53Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReader;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderAdaptor;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderListener;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.RXTXPort;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * The {@link TeleinfoSerialportReader} class defines the Serial port implementation of {@link TeleinfoReader}.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialportReader extends TeleinfoReaderAdaptor {\n+\n+    private static Logger logger = LoggerFactory.getLogger(TeleinfoSerialportReader.class);\n+\n+    private String serialPortName;\n+    private long refreshInterval;\n+\n+    private Timer teleinfoSerialportReaderTimer;\n+    private SerialPort serialPort;\n+    private long waitNextHeaderFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME;\n+    private long readingFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME;\n+\n+    public TeleinfoSerialportReader(String serialPortName, long refreshInterval) {\n+        this.serialPortName = serialPortName;\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        logger.debug(\"open() [start]\");\n+\n+        CommPortIdentifier portIdentifier;\n+        try {\n+            logger.trace(\"serialPortName = {}\", serialPortName);\n+            System.setProperty(\"gnu.io.rxtx.SerialPorts\", serialPortName); // Workaround to force serial port detection\n+                                                                           // on Linux", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExODAwOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjY1MQ==", "bodyText": "Can't find it in the zwave binding. Maybe the bug is fixed already. I found this: openhab/openhab-core#805", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443156651", "createdAt": "2020-06-20T20:10:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReader;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderAdaptor;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderListener;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.RXTXPort;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * The {@link TeleinfoSerialportReader} class defines the Serial port implementation of {@link TeleinfoReader}.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialportReader extends TeleinfoReaderAdaptor {\n+\n+    private static Logger logger = LoggerFactory.getLogger(TeleinfoSerialportReader.class);\n+\n+    private String serialPortName;\n+    private long refreshInterval;\n+\n+    private Timer teleinfoSerialportReaderTimer;\n+    private SerialPort serialPort;\n+    private long waitNextHeaderFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME;\n+    private long readingFrameTimeoutInMs = TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME;\n+\n+    public TeleinfoSerialportReader(String serialPortName, long refreshInterval) {\n+        this.serialPortName = serialPortName;\n+        this.refreshInterval = refreshInterval;\n+    }\n+\n+    @Override\n+    public void open() throws IOException {\n+        logger.debug(\"open() [start]\");\n+\n+        CommPortIdentifier portIdentifier;\n+        try {\n+            logger.trace(\"serialPortName = {}\", serialPortName);\n+            System.setProperty(\"gnu.io.rxtx.SerialPorts\", serialPortName); // Workaround to force serial port detection\n+                                                                           // on Linux", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTExODAwOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODI5NDQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozMToxM1rOGksDcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjowMzozMlrOGlY9lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMzY5Nw==", "bodyText": "This class is never used in your binding?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441123697", "createdAt": "2020-06-16T20:31:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReader;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderAdaptor;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderListener;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.RXTXPort;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * The {@link TeleinfoSerialportReader} class defines the Serial port implementation of {@link TeleinfoReader}.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialportReader extends TeleinfoReaderAdaptor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1OTQ3OA==", "bodyText": "Deprecated code. To delete", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441859478", "createdAt": "2020-06-17T22:03:32Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/serialport/TeleinfoSerialportReader.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io.serialport;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReader;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderAdaptor;\n+import org.openhab.binding.teleinfo.internal.reader.TeleinfoReaderListener;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import gnu.io.CommPortIdentifier;\n+import gnu.io.NoSuchPortException;\n+import gnu.io.PortInUseException;\n+import gnu.io.RXTXPort;\n+import gnu.io.SerialPort;\n+import gnu.io.UnsupportedCommOperationException;\n+\n+/**\n+ * The {@link TeleinfoSerialportReader} class defines the Serial port implementation of {@link TeleinfoReader}.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialportReader extends TeleinfoReaderAdaptor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyMzY5Nw=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMwOTA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozNToxM1rOGksMKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMDo1MTowNFrOGmoSLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNTkzMA==", "bodyText": "Can you reference which bug you are working around? e.g. Stackoverflow post.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441125930", "createdAt": "2020-06-16T20:35:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoReceiveThread extends Thread implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, @NonNull final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        try {\n+            logger.trace(\"RXTX library CPU load workaround, sleep forever\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg1OTc2MA==", "bodyText": "This code line is copy-paste from Zwave binding. No more information of this issue", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441859760", "createdAt": "2020-06-17T22:04:20Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoReceiveThread extends Thread implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, @NonNull final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        try {\n+            logger.trace(\"RXTX library CPU load workaround, sleep forever\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNTkzMA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1OTA4Nw==", "bodyText": "If that relates to NeuronRobotics/nrjavaserial#22 it seems to be fixed. @wborn Do you know if this is the workaround for that bug?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443159087", "createdAt": "2020-06-20T20:51:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoReceiveThread extends Thread implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, @NonNull final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        try {\n+            logger.trace(\"RXTX library CPU load workaround, sleep forever\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNTkzMA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMxNDY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozNjo1MVrOGksPoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjowNTo0M1rOGlZAsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNjgxNg==", "bodyText": "Can this method be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441126816", "createdAt": "2020-06-16T20:36:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoReceiveThread extends Thread implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, @NonNull final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        try {\n+            logger.trace(\"RXTX library CPU load workaround, sleep forever\");\n+            Thread.sleep(Long.MAX_VALUE);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Starting Teleinfo thread: Receive\");\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME * 100,\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME * 100, autoRepairInvalidADPSgroupLine)) {\n+            while (!interrupted()) {\n+                try {\n+                    Frame nextFrame = teleinfoStream.readNextFrame();\n+                    listener.onFrameReceived(this, nextFrame);\n+                } catch (InvalidFrameException e) {\n+                    logger.error(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());\n+                    listener.onInvalidFrameReceived(this, e);\n+                } catch (TimeoutException e) {\n+                    logger.error(\"Got timeout during frame reading\", e);\n+                    if (!listener.continueOnReadNextFrameTimeoutException(this, e)) {\n+                        break;\n+                    }\n+                    // skipInputStreamBuffer();\n+                } catch (IOException e) {\n+                    logger.error(\"Got I/O exception. Detail: \\\"{}\\\"\", e.getLocalizedMessage(), e);\n+                    listener.onSerialPortInputStreamIOException(this, e);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"An error occurred during serial port input stream opening\", e);\n+        }\n+\n+        logger.debug(\"Terminates Teleinfo receive thread\");\n+\n+        serialPort.removeEventListener();\n+    }\n+\n+    public TeleinfoReceiveThreadListener getListener() {\n+        return listener;\n+    }\n+\n+    public void setListener(TeleinfoReceiveThreadListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private void skipInputStreamBuffer() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MDI3NQ==", "bodyText": "Ok (deprecated code)", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441860275", "createdAt": "2020-06-17T22:05:43Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoReceiveThread extends Thread implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, @NonNull final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        try {\n+            logger.trace(\"RXTX library CPU load workaround, sleep forever\");\n+            Thread.sleep(Long.MAX_VALUE);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Starting Teleinfo thread: Receive\");\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_WAIT_NEXT_HEADER_FRAME * 100,\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME * 100, autoRepairInvalidADPSgroupLine)) {\n+            while (!interrupted()) {\n+                try {\n+                    Frame nextFrame = teleinfoStream.readNextFrame();\n+                    listener.onFrameReceived(this, nextFrame);\n+                } catch (InvalidFrameException e) {\n+                    logger.error(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());\n+                    listener.onInvalidFrameReceived(this, e);\n+                } catch (TimeoutException e) {\n+                    logger.error(\"Got timeout during frame reading\", e);\n+                    if (!listener.continueOnReadNextFrameTimeoutException(this, e)) {\n+                        break;\n+                    }\n+                    // skipInputStreamBuffer();\n+                } catch (IOException e) {\n+                    logger.error(\"Got I/O exception. Detail: \\\"{}\\\"\", e.getLocalizedMessage(), e);\n+                    listener.onSerialPortInputStreamIOException(this, e);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"An error occurred during serial port input stream opening\", e);\n+        }\n+\n+        logger.debug(\"Terminates Teleinfo receive thread\");\n+\n+        serialPort.removeEventListener();\n+    }\n+\n+    public TeleinfoReceiveThreadListener getListener() {\n+        return listener;\n+    }\n+\n+    public void setListener(TeleinfoReceiveThreadListener listener) {\n+        this.listener = listener;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private void skipInputStreamBuffer() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNjgxNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMxODc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozNzo1OFrOGksSFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozNzo1OFrOGksSFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNzQ0Ng==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441127446", "createdAt": "2020-06-16T20:37:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMyMjg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDozOToxNFrOGksUrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMjoxMjowN1rOGmokXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyODEwOA==", "bodyText": "This creates a new thread. Can you use openHAB's threadpool instead by using the field scheduler?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441128108", "createdAt": "2020-06-16T20:39:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MTE4Nw==", "bodyText": "@fwolter have you an example?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441861187", "createdAt": "2020-06-17T22:08:10Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyODEwOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NjgzOQ==", "bodyText": "Sure:\nhttps://github.com/openhab/org.openhab.binding.zwave/blob/2.5.x/src/main/java/org/openhab/binding/zwave/handler/ZWaveSerialHandler.java#L95", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443156839", "createdAt": "2020-06-20T20:13:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyODEwOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2Mzc0MA==", "bodyText": "Thanks !", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443163740", "createdAt": "2020-06-20T22:12:07Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyODEwOA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMyNzYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MDozMFrOGksXbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MDozMFrOGksXbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyODgxMw==", "bodyText": "Can this be scheduleWithFixedDelay()? See https://www.openhab.org/docs/developer/guidelines.html#e-runtime-behavior", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441128813", "createdAt": "2020-06-16T20:40:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);\n+        keepAliveThread.scheduleAtFixedRate(new TimerTask() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMzMTc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MTo1NVrOGksaAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MTo1NVrOGksaAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyOTQ3NQ==", "bodyText": "This should be debug", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441129475", "createdAt": "2020-06-16T20:41:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);\n+        keepAliveThread.scheduleAtFixedRate(new TimerTask() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"Check Teleinfo receiveThread status...\");\n+                logger.debug(\"isInitialized() = {}\", isInitialized());\n+                if (receiveThread != null) {\n+                    logger.debug(\"receiveThread.isAlive() = {}\", receiveThread.isAlive());\n+                }\n+                if (isInitialized() && (receiveThread == null || (receiveThread != null && !receiveThread.isAlive()))) {\n+                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                    logger.info(\"Try to restart Teleinfo receiving...\");\n+                    stopReceivingAndCloseSerialPort();\n+                    openSerialPortAndStartReceiving();\n+                }\n+            }\n+        }, 60000, 60000);\n+\n+        if (ThingStatus.OFFLINE.equals(getThing().getStatus())) {\n+            logger.info(\"Teleinfo Serial is initialized, but the bridge is currently OFFLINE due to errors\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMzMjYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MjoxMlrOGksagg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0MjoxMlrOGksagg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyOTYwMg==", "bodyText": "This is already logged by the framework. See above.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441129602", "createdAt": "2020-06-16T20:42:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);\n+        keepAliveThread.scheduleAtFixedRate(new TimerTask() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"Check Teleinfo receiveThread status...\");\n+                logger.debug(\"isInitialized() = {}\", isInitialized());\n+                if (receiveThread != null) {\n+                    logger.debug(\"receiveThread.isAlive() = {}\", receiveThread.isAlive());\n+                }\n+                if (isInitialized() && (receiveThread == null || (receiveThread != null && !receiveThread.isAlive()))) {\n+                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                    logger.info(\"Try to restart Teleinfo receiving...\");\n+                    stopReceivingAndCloseSerialPort();\n+                    openSerialPortAndStartReceiving();\n+                }\n+            }\n+        }, 60000, 60000);\n+\n+        if (ThingStatus.OFFLINE.equals(getThing().getStatus())) {\n+            logger.info(\"Teleinfo Serial is initialized, but the bridge is currently OFFLINE due to errors\");\n+        } else {\n+            logger.info(\"Teleinfo Serial is initialized\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODMzODAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0Mzo1MlrOGksd6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0Mzo1MlrOGksd6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMDQ3NA==", "bodyText": "See above. dispose() can be invoked now and will throw a null pointer exception, because keepAliveThread is still null.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441130474", "createdAt": "2020-06-16T20:43:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM0NTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0NjowMlrOGksiew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0NjowMlrOGksiew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMTY0Mw==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441131643", "createdAt": "2020-06-16T20:46:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);\n+        keepAliveThread.scheduleAtFixedRate(new TimerTask() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"Check Teleinfo receiveThread status...\");\n+                logger.debug(\"isInitialized() = {}\", isInitialized());\n+                if (receiveThread != null) {\n+                    logger.debug(\"receiveThread.isAlive() = {}\", receiveThread.isAlive());\n+                }\n+                if (isInitialized() && (receiveThread == null || (receiveThread != null && !receiveThread.isAlive()))) {\n+                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                    logger.info(\"Try to restart Teleinfo receiving...\");\n+                    stopReceivingAndCloseSerialPort();\n+                    openSerialPortAndStartReceiving();\n+                }\n+            }\n+        }, 60000, 60000);\n+\n+        if (ThingStatus.OFFLINE.equals(getThing().getStatus())) {\n+            logger.info(\"Teleinfo Serial is initialized, but the bridge is currently OFFLINE due to errors\");\n+        } else {\n+            logger.info(\"Teleinfo Serial is initialized\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.info(\"Teleinfo Serial is stopping...\");\n+        keepAliveThread.cancel();\n+        keepAliveThread = null;\n+        stopReceivingAndCloseSerialPort();\n+        logger.info(\"Teleinfo Serial is stopped\");\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoReceiveThread receiveThread, @NonNull Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+        logger.debug(\"startReceiving [start]\");\n+\n+        config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport == null || StringUtils.isBlank(config.serialport)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM1MjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0ODoxMlrOGksmxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo0ODoxMlrOGksmxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMjc0Mg==", "bodyText": "This should be executed in a scheduler thread, since initialize() is supposed to return fast.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441132742", "createdAt": "2020-06-16T20:48:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM2MjkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1MToyOFrOGkstSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1MToyOFrOGkstSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNDQwOA==", "bodyText": "Logging to error should only be done if some fatal error has occured. Nevertheless, the framework already logs the state change of the Thing. So, this would result in logging it twice. You could remove it.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441134408", "createdAt": "2020-06-16T20:51:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private org.eclipse.smarthome.io.transport.serial.SerialPort serialPort;\n+    private TeleinfoReceiveThread receiveThread;\n+    private Timer keepAliveThread;\n+    private @Nullable TeleinfoSerialControllerConfiguration config;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(@NonNull Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing Teleinfo Serial controller\");\n+        invalidFrameCounter = 0;\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        openSerialPortAndStartReceiving();\n+\n+        keepAliveThread = new Timer(\"Teleinfo-KeepAliveThread-timer\", true);\n+        keepAliveThread.scheduleAtFixedRate(new TimerTask() {\n+            @Override\n+            public void run() {\n+                logger.debug(\"Check Teleinfo receiveThread status...\");\n+                logger.debug(\"isInitialized() = {}\", isInitialized());\n+                if (receiveThread != null) {\n+                    logger.debug(\"receiveThread.isAlive() = {}\", receiveThread.isAlive());\n+                }\n+                if (isInitialized() && (receiveThread == null || (receiveThread != null && !receiveThread.isAlive()))) {\n+                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                    logger.info(\"Try to restart Teleinfo receiving...\");\n+                    stopReceivingAndCloseSerialPort();\n+                    openSerialPortAndStartReceiving();\n+                }\n+            }\n+        }, 60000, 60000);\n+\n+        if (ThingStatus.OFFLINE.equals(getThing().getStatus())) {\n+            logger.info(\"Teleinfo Serial is initialized, but the bridge is currently OFFLINE due to errors\");\n+        } else {\n+            logger.info(\"Teleinfo Serial is initialized\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.info(\"Teleinfo Serial is stopping...\");\n+        keepAliveThread.cancel();\n+        keepAliveThread = null;\n+        stopReceivingAndCloseSerialPort();\n+        logger.info(\"Teleinfo Serial is stopped\");\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoReceiveThread receiveThread, @NonNull Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(@NonNull TeleinfoReceiveThread receiveThread,\n+            @NonNull TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+        logger.debug(\"startReceiving [start]\");\n+\n+        config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport == null || StringUtils.isBlank(config.serialport)) {\n+            logger.error(\"Teleinfo port is not set.\");\n+            return;\n+        }\n+\n+        logger.info(\"Connecting to serial port '{}'...\", config.serialport);\n+        String currentOwner = null;\n+        try {\n+            final SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(config.serialport);\n+            logger.debug(\"portIdentifier = {}\", portIdentifier);\n+            if (portIdentifier == null) {\n+                logger.error(\"No port identifier for '{}'\", config.serialport);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        ERROR_OFFLINE_SERIAL_NOT_FOUND);\n+                return;\n+            }\n+            logger.debug(\"Opening portIdentifier\");\n+            currentOwner = portIdentifier.getCurrentOwner();\n+            logger.debug(\"portIdentifier.getCurrentOwner() = {}\", currentOwner);\n+            SerialPort commPort = portIdentifier.open(\"org.openhab.binding.teleinfo\", 5000);\n+            serialPort = commPort;\n+\n+            serialPort.setSerialPortParams(1200, SerialPort.DATABITS_7, SerialPort.STOPBITS_1, SerialPort.PARITY_EVEN);\n+            serialPort.enableReceiveThreshold(1);\n+            serialPort.enableReceiveTimeout(SERIAL_RECEIVE_TIMEOUT);\n+            logger.debug(\"Starting receive thread\");\n+            receiveThread = new TeleinfoReceiveThread(serialPort, this, config.autoRepairInvalidADPSgroupLine);\n+            receiveThread.start();\n+\n+            // RXTX serial port library causes high CPU load\n+            // Start event listener, which will just sleep and slow down event loop\n+            serialPort.addEventListener(receiveThread);\n+            serialPort.notifyOnDataAvailable(true);\n+            logger.info(\"Connected to serial port '{}'\", config.serialport);\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    ERROR_OFFLINE_SERIAL_INUSE);\n+            logger.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM2ODIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1MzoxMlrOGkswpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDozOTo1MlrOGl_bSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTI2OA==", "bodyText": "Can you write your last name in normal letters?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441135268", "createdAt": "2020-06-16T20:53:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"teleinfo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Teleinfo Binding</name>\n+\t<description>The Teleinfo binding decodes the electrical statistics from an ENEDIS/ERDF Electricity Meter</description>\n+\t<author>Nicolas SIBERIL</author>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4OTY3NA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442489674", "createdAt": "2020-06-18T20:39:52Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"teleinfo\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Teleinfo Binding</name>\n+\t<description>The Teleinfo binding decodes the electrical statistics from an ENEDIS/ERDF Electricity Meter</description>\n+\t<author>Nicolas SIBERIL</author>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTI2OA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM2OTE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/i18n/teleinfo_xx_XX.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1MzozMVrOGksxUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo0MDoxN1rOGl_cIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTQ0MQ==", "bodyText": "Can this file be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441135441", "createdAt": "2020-06-16T20:53:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/i18n/teleinfo_xx_XX.properties", "diffHunk": "@@ -0,0 +1,17 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4OTg5MQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442489891", "createdAt": "2020-06-18T20:40:17Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/i18n/teleinfo_xx_XX.properties", "diffHunk": "@@ -0,0 +1,17 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTQ0MQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM3MzQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmBaseOptionElectricityMeter.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NDo0OVrOGksz_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo0MDozN1rOGl_c0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjEyNQ==", "bodyText": "Labels should be <20 characters. You could use the description tag.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441136125", "createdAt": "2020-06-16T20:54:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmBaseOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,30 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_base_electricitymeter\" listed=\"false\">\n+\t\t<label>Single-phase Electricity meter with BASE option - CBEMM (aka \"Compteur Bleu Electronique Monophas\u00e9 Multitarif\")</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5MDA2Nw==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442490067", "createdAt": "2020-06-18T20:40:37Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmBaseOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,30 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_base_electricitymeter\" listed=\"false\">\n+\t\t<label>Single-phase Electricity meter with BASE option - CBEMM (aka \"Compteur Bleu Electronique Monophas\u00e9 Multitarif\")</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjEyNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM3NzM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmEjpElectricityMeter.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1NjowMFrOGks2hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo0MDo1OFrOGl_deA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjc3Mg==", "bodyText": "Can this be removed? Same for below", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441136772", "createdAt": "2020-06-16T20:56:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmEjpElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,43 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_ejp_electricitymeter\" listed=\"false\">\n+\t\t<label>Single-phase Electricity meter with EJP option - CBEMM (aka \"Compteur Bleu Electronique Monophas\u00e9 Multitarif\")</label>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"isousc\" typeId=\"isouscType\" />\n+\t\t\t<channel id=\"ptec\" typeId=\"ptecType\" />\n+\t\t\t<channel id=\"imax\" typeId=\"imaxType\" />\n+\t\t\t<channel id=\"adps\" typeId=\"adpsType\" />\n+\t\t\t<channel id=\"iinst\" typeId=\"iinstType\" />\n+\t\t\t<channel id=\"currentPower\" typeId=\"currentPowerType\" />\n+\t\t\t<channel id=\"pejp\" typeId=\"pejpType\" />\n+\t\t\t<channel id=\"ejphpm\" typeId=\"ejphpmType\" />\n+\t\t\t<channel id=\"ejphn\" typeId=\"ejphnType\" />\n+\t\t\t<channel id=\"lastUpdate\" typeId=\"lastUpdateType\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"adco\" type=\"text\" required=\"true\" pattern=\"^\\w{12}$\">\n+\t\t\t\t<label>ADCO</label>\n+\t\t\t\t<description>Electricity meter identifier (format: 12 characters / e.g: '031528042289')</description>\n+\t\t\t\t<limitToOptions>false</limitToOptions>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t\t<!-- <config-description> -->\n+\t\t<!-- <parameter name=\"hchcKWhPricing\" type=\"integer\" required=\"true\" min=\"0\"> -->\n+\t\t<!-- <label>Pricing of 1 kWh during HCHC period</label> -->\n+\t\t<!-- <unitLabel>euro</unitLabel> -->\n+\t\t<!-- </parameter> -->\n+\t\t<!-- <parameter name=\"hchpKWhPricing\" type=\"integer\" required=\"true\" min=\"0\"> -->\n+\t\t<!-- <label>Pricing of 1 kWh during HCHP period</label> -->\n+\t\t<!-- <unitLabel>euro</unitLabel> -->\n+\t\t<!-- </parameter> -->\n+\t\t<!-- </config-description> -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5MDIzMg==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442490232", "createdAt": "2020-06-18T20:40:58Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmEjpElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,43 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_ejp_electricitymeter\" listed=\"false\">\n+\t\t<label>Single-phase Electricity meter with EJP option - CBEMM (aka \"Compteur Bleu Electronique Monophas\u00e9 Multitarif\")</label>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"isousc\" typeId=\"isouscType\" />\n+\t\t\t<channel id=\"ptec\" typeId=\"ptecType\" />\n+\t\t\t<channel id=\"imax\" typeId=\"imaxType\" />\n+\t\t\t<channel id=\"adps\" typeId=\"adpsType\" />\n+\t\t\t<channel id=\"iinst\" typeId=\"iinstType\" />\n+\t\t\t<channel id=\"currentPower\" typeId=\"currentPowerType\" />\n+\t\t\t<channel id=\"pejp\" typeId=\"pejpType\" />\n+\t\t\t<channel id=\"ejphpm\" typeId=\"ejphpmType\" />\n+\t\t\t<channel id=\"ejphn\" typeId=\"ejphnType\" />\n+\t\t\t<channel id=\"lastUpdate\" typeId=\"lastUpdateType\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"adco\" type=\"text\" required=\"true\" pattern=\"^\\w{12}$\">\n+\t\t\t\t<label>ADCO</label>\n+\t\t\t\t<description>Electricity meter identifier (format: 12 characters / e.g: '031528042289')</description>\n+\t\t\t\t<limitToOptions>false</limitToOptions>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t\t<!-- <config-description> -->\n+\t\t<!-- <parameter name=\"hchcKWhPricing\" type=\"integer\" required=\"true\" min=\"0\"> -->\n+\t\t<!-- <label>Pricing of 1 kWh during HCHC period</label> -->\n+\t\t<!-- <unitLabel>euro</unitLabel> -->\n+\t\t<!-- </parameter> -->\n+\t\t<!-- <parameter name=\"hchpKWhPricing\" type=\"integer\" required=\"true\" min=\"0\"> -->\n+\t\t<!-- <label>Pricing of 1 kWh during HCHP period</label> -->\n+\t\t<!-- <unitLabel>euro</unitLabel> -->\n+\t\t<!-- </parameter> -->\n+\t\t<!-- </config-description> -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNjc3Mg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM4Nzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbetmHcOptionElectricityMeter.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMDo1OToyMVrOGks9PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo0MToyM1rOGl_eOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzODQ5Mg==", "bodyText": "You could declare the config description once and reference to that here with e.g. <config-description-ref uri=\"thing-type:teleinfo:adco\"/>.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441138492", "createdAt": "2020-06-16T20:59:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbetmHcOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbetm_hc_electricitymeter\" listed=\"false\">\n+\t\t<label>Three-phase Electricity meter with HC option - CBETM (aka \"Compteur Bleu Electronique Triphas\u00e9 Multitarif\")</label>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"frameType\" typeId=\"frameTypeType\" />\n+\t\t\t<channel id=\"isousc\" typeId=\"isouscType\" />\n+\t\t\t<channel id=\"ptec\" typeId=\"ptecType\" />\n+\t\t\t<channel id=\"iinst1\" typeId=\"iinst1Type\" />\n+\t\t\t<channel id=\"iinst2\" typeId=\"iinst2Type\" />\n+\t\t\t<channel id=\"iinst3\" typeId=\"iinst3Type\" />\n+\t\t\t<channel id=\"currentPower1\" typeId=\"currentPower1Type\" />\n+\t\t\t<channel id=\"currentPower2\" typeId=\"currentPower2Type\" />\n+\t\t\t<channel id=\"currentPower3\" typeId=\"currentPower3Type\" />\n+\t\t\t<channel id=\"imax1\" typeId=\"imax1Type\" />\n+\t\t\t<channel id=\"imax2\" typeId=\"imax2Type\" />\n+\t\t\t<channel id=\"imax3\" typeId=\"imax3Type\" />\n+\t\t\t<channel id=\"pmax\" typeId=\"pmaxType\" />\n+\t\t\t<channel id=\"papp\" typeId=\"pappType\" />\n+\t\t\t<channel id=\"ppot\" typeId=\"ppotType\" />\n+\t\t\t<channel id=\"adir1\" typeId=\"adir1Type\" />\n+\t\t\t<channel id=\"adir2\" typeId=\"adir2Type\" />\n+\t\t\t<channel id=\"adir3\" typeId=\"adir3Type\" />\n+\t\t\t<channel id=\"lastUpdate\" typeId=\"lastUpdateType\" />\n+\t\t\t<channel id=\"hchc\" typeId=\"hchcType\" />\n+\t\t\t<channel id=\"hchp\" typeId=\"hchpType\" />\n+\t\t\t<channel id=\"hhphc\" typeId=\"hhphcType\" />\n+\t\t</channels>\n+\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5MDQyNQ==", "bodyText": "Nice", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442490425", "createdAt": "2020-06-18T20:41:23Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbetmHcOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,44 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbetm_hc_electricitymeter\" listed=\"false\">\n+\t\t<label>Three-phase Electricity meter with HC option - CBETM (aka \"Compteur Bleu Electronique Triphas\u00e9 Multitarif\")</label>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"frameType\" typeId=\"frameTypeType\" />\n+\t\t\t<channel id=\"isousc\" typeId=\"isouscType\" />\n+\t\t\t<channel id=\"ptec\" typeId=\"ptecType\" />\n+\t\t\t<channel id=\"iinst1\" typeId=\"iinst1Type\" />\n+\t\t\t<channel id=\"iinst2\" typeId=\"iinst2Type\" />\n+\t\t\t<channel id=\"iinst3\" typeId=\"iinst3Type\" />\n+\t\t\t<channel id=\"currentPower1\" typeId=\"currentPower1Type\" />\n+\t\t\t<channel id=\"currentPower2\" typeId=\"currentPower2Type\" />\n+\t\t\t<channel id=\"currentPower3\" typeId=\"currentPower3Type\" />\n+\t\t\t<channel id=\"imax1\" typeId=\"imax1Type\" />\n+\t\t\t<channel id=\"imax2\" typeId=\"imax2Type\" />\n+\t\t\t<channel id=\"imax3\" typeId=\"imax3Type\" />\n+\t\t\t<channel id=\"pmax\" typeId=\"pmaxType\" />\n+\t\t\t<channel id=\"papp\" typeId=\"pappType\" />\n+\t\t\t<channel id=\"ppot\" typeId=\"ppotType\" />\n+\t\t\t<channel id=\"adir1\" typeId=\"adir1Type\" />\n+\t\t\t<channel id=\"adir2\" typeId=\"adir2Type\" />\n+\t\t\t<channel id=\"adir3\" typeId=\"adir3Type\" />\n+\t\t\t<channel id=\"lastUpdate\" typeId=\"lastUpdateType\" />\n+\t\t\t<channel id=\"hchc\" typeId=\"hchcType\" />\n+\t\t\t<channel id=\"hchp\" typeId=\"hchpType\" />\n+\t\t\t<channel id=\"hhphc\" typeId=\"hhphcType\" />\n+\t\t</channels>\n+\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzODQ5Mg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM5MzE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowMTowNFrOGktAug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTo0OToxNVrOGpl4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM4Ng==", "bodyText": "From the usability perspective it would be great if you write the same text for the parameter here as in the readme.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441139386", "createdAt": "2020-06-16T21:01:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"baseType\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>BASE</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5MjM2Ng==", "bodyText": "Ok (README.md file to update)", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442492366", "createdAt": "2020-06-18T20:45:31Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"baseType\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>BASE</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM4Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTIyNQ==", "bodyText": "@fwolter @nokyyz Can you explain? Do I need to copy the description field from the table in the readme to the <description> field in the xml? Or is it a problem of uppercase/lowercase for the label?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r446169225", "createdAt": "2020-06-26T13:01:12Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"baseType\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>BASE</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM4Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1NzkyNw==", "bodyText": "Yes, copying the description field from the readme into <description> would be great.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r446257927", "createdAt": "2020-06-26T15:35:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"baseType\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>BASE</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM4Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2NTM5Mw==", "bodyText": "Thanks! nokyyz remark about updating readme confused me.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r446265393", "createdAt": "2020-06-26T15:49:15Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-base-channel-types.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"baseType\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>BASE</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzOTM4Ng=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODM5OTIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowMzoxNlrOGktE3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTozNDoxNVrOGrrEgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MDQ0NA==", "bodyText": "Did you test what happens if the user displays the value in kW?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<state pattern=\"%d W\" readOnly=\"true\" />\n          \n          \n            \n            \t\t<state pattern=\"%d %unit%\" readOnly=\"true\" />", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441140444", "createdAt": "2020-06-16T21:03:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2OTYwOA==", "bodyText": "@fwolter Ok for your suggestion, but in this case, all updateState() operations shall be updated to set the unit data, no ?\nE.g: updateState(CHANNEL_CBEMM_ISOUSC, new DecimalType(frame.getIsousc()));", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r447169608", "createdAt": "2020-06-29T18:29:29Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MDQ0NA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0NzYxOA==", "bodyText": "Yes, instead of DecimalType, QuantityType must be used.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r448447618", "createdAt": "2020-07-01T15:34:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MDQ0NA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODQwNTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowNToxNVrOGktIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMFQyMToxMzo0N1rOGmoXQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MTQyNg==", "bodyText": "Actually \"power factor\" describes the phase shift in AC systems. Are you sure this is a good wording?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441141426", "createdAt": "2020-06-16T21:05:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />\n+\t\t<config-description>\n+\t\t\t<parameter name=\"powerFactor\" type=\"integer\">\n+\t\t\t\t<label>Power factor</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODU1Mw==", "bodyText": "I'm not an electricity expert. My work is based on this blog: http://www.magdiblog.fr/gpio/teleinfo-edf-suivi-conso-de-votre-compteur-electrique/\nThis blog references the \"Facteur de puissance\" in Wikipedia: https://fr.wikipedia.org/wiki/Facteur_de_puissance (https://en.wikipedia.org/wiki/Power_factor in English)", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442498553", "createdAt": "2020-06-18T20:58:04Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />\n+\t\t<config-description>\n+\t\t\t<parameter name=\"powerFactor\" type=\"integer\">\n+\t\t\t\t<label>Power factor</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MTQyNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwNDY5Ng==", "bodyText": "I think a good wording could be \"Nominal Voltage\". Power factor is the cosinus of phase shift:  a real number between 0 and 1. The technical name is \"rms (root mean square) voltage\" but perhaps it is too technical. I will make the change in \"Nominal Voltage\" if it suits everybody.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442804696", "createdAt": "2020-06-19T12:13:37Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />\n+\t\t<config-description>\n+\t\t\t<parameter name=\"powerFactor\" type=\"integer\">\n+\t\t\t\t<label>Power factor</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MTQyNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1Njk4Ng==", "bodyText": "I think that suits better.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443156986", "createdAt": "2020-06-20T20:16:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />\n+\t\t<config-description>\n+\t\t\t<parameter name=\"powerFactor\" type=\"integer\">\n+\t\t\t\t<label>Power factor</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MTQyNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2MDM4Ng==", "bodyText": "You seem more expert than me about this subject :-) Ok for me", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443160386", "createdAt": "2020-06-20T21:13:47Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-cbemm-channel-types.xml", "diffHunk": "@@ -0,0 +1,54 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"imaxType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IMAX</label>\n+\t\t<description>IMAX</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"iinstType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>IINST</label>\n+\t\t<description>IINST</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"currentPowerType\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>currentpower</label>\n+\t\t<description>Instantaneous power</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d W\" readOnly=\"true\" />\n+\t\t<config-description>\n+\t\t\t<parameter name=\"powerFactor\" type=\"integer\">\n+\t\t\t\t<label>Power factor</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MTQyNg=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODQxMzM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowNzo1MFrOGktNuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMDoxNjo1OFrOGqgn0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ==", "bodyText": "From the user's perspective, it would be better if you translate these values in the tag content...", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441142715", "createdAt": "2020-06-16T21:07:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNTkzMw==", "bodyText": "Teleinfo is a french protocol. Here, the \"TH\" value is an abbreviation for \"Toutes les Heures\".\nFor me, it is problematic to use french words in OpenHAB.\nIHMO, the user can edit a .map file to translate these values.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442505933", "createdAt": "2020-06-18T21:13:34Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE1NzA5NQ==", "bodyText": "What about translating them into English?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443157095", "createdAt": "2020-06-20T20:18:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE2MTI3Mw==", "bodyText": "By doing so, we are moving away from the Teleinfo protocol. I don't think it's a good idea.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443161273", "createdAt": "2020-06-20T21:29:51Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5MjgzNQ==", "bodyText": "No harm in making a protocol user friendly. Just for clarification, I only suggest to make the UI representation readable <option value=\"TH\">Hourly</option>. If you want to stick with it, it should be ok.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r443192835", "createdAt": "2020-06-21T07:53:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTUwOQ==", "bodyText": "I think that, for the moment, we must stick strictly to the Teleinfo protocol", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r447059509", "createdAt": "2020-06-29T15:29:47Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyNzg1OQ==", "bodyText": "OK, commit 9307337 reverted by b787e33", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r447227859", "createdAt": "2020-06-29T20:16:58Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0MjcxNQ=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODQxNDI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTowODowN1rOGktOTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxMzo0N1rOGmAbJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0Mjg2MA==", "bodyText": "Words in labels should be capitalized. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441142860", "createdAt": "2020-06-16T21:08:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>\n+\t\t\t\t<option value=\"HC\">HC</option>\n+\t\t\t\t<option value=\"HP\">HP</option>\n+\t\t\t\t<option value=\"HN\">HN</option>\n+\t\t\t\t<option value=\"PM\">PM</option>\n+\t\t\t\t<option value=\"HCJB\">HCJB</option>\n+\t\t\t\t<option value=\"HCJW\">HCJW</option>\n+\t\t\t\t<option value=\"HCJR\">HCJR</option>\n+\t\t\t\t<option value=\"HPJB\">HPJB</option>\n+\t\t\t\t<option value=\"HPJW\">HPJW</option>\n+\t\t\t\t<option value=\"HPJR\">HPJR</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"hhphcType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>HHPHC</label>\n+\t\t<description>HHPHC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"A\">A</option>\n+\t\t\t\t<option value=\"C\">C</option>\n+\t\t\t\t<option value=\"D\">D</option>\n+\t\t\t\t<option value=\"E\">E</option>\n+\t\t\t\t<option value=\"Y\">Y</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastUpdateType\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last update</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNjAyMA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r442506020", "createdAt": "2020-06-18T21:13:47Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/common-channel-types.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"isouscType\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>ISOUSC</label>\n+\t\t<description>ISOUSC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%d A\" readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"ptecType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PTEC</label>\n+\t\t<description>PTEC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"TH\">TH</option>\n+\t\t\t\t<option value=\"HC\">HC</option>\n+\t\t\t\t<option value=\"HP\">HP</option>\n+\t\t\t\t<option value=\"HN\">HN</option>\n+\t\t\t\t<option value=\"PM\">PM</option>\n+\t\t\t\t<option value=\"HCJB\">HCJB</option>\n+\t\t\t\t<option value=\"HCJW\">HCJW</option>\n+\t\t\t\t<option value=\"HCJR\">HCJR</option>\n+\t\t\t\t<option value=\"HPJB\">HPJB</option>\n+\t\t\t\t<option value=\"HPJW\">HPJW</option>\n+\t\t\t\t<option value=\"HPJR\">HPJR</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"hhphcType\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>HHPHC</label>\n+\t\t<description>HHPHC</description>\n+\t\t<category>Energy</category>\n+\t\t<state pattern=\"%s\" readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"A\">A</option>\n+\t\t\t\t<option value=\"C\">C</option>\n+\t\t\t\t<option value=\"D\">D</option>\n+\t\t\t\t<option value=\"E\">E</option>\n+\t\t\t\t<option value=\"Y\">Y</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lastUpdateType\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last update</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0Mjg2MA=="}, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODQyNjUxOnYy", "diffSide": "RIGHT", "path": "bundles/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMToxMTo0NVrOGktVwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMToxMTo0NVrOGktVwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NDc3MA==", "bodyText": "Can you remove this formatting from your PR?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441144770", "createdAt": "2020-06-16T21:11:45Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -232,7 +232,8 @@\n     <module>org.openhab.binding.systeminfo</module>\n     <module>org.openhab.binding.tado</module>\n     <module>org.openhab.binding.tankerkoenig</module>\n-    <module>org.openhab.binding.telegram</module>\n+    <module>org.openhab.binding.telegram</module>    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODQ4Njk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTozMjozN1rOGkt8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTozMjozN1rOGkt8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1NDY0Ng==", "bodyText": "Can you fix the usage of deprecated API?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r441154646", "createdAt": "2020-06-16T21:32:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/TeleinfoDiscoveryService.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.common.AbstractUID;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoControllerHandlerListener;\n+import org.openhab.binding.teleinfo.internal.reader.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.reader.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.reader.common.FrameAdco;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoDiscoveryService} class is the service to discover a skeleton for controller handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+// @Component(service = DiscoveryService.class, immediate = false, configurationPid = \"discovery.teleinfo\")\n+public class TeleinfoDiscoveryService extends AbstractDiscoveryService implements TeleinfoControllerHandlerListener {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES = Stream.of(THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID, THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID).collect(Collectors.toSet());\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoDiscoveryService.class);\n+    private final TeleinfoAbstractControllerHandler controllerHandler;\n+\n+    public TeleinfoDiscoveryService(TeleinfoAbstractControllerHandler controllerHandler, int timeout) {\n+        super(timeout);\n+        this.controllerHandler = controllerHandler;\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES;\n+    }\n+\n+    public void activate() {\n+        logger.debug(\"Teleinfo discovery: Active {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        logger.debug(\"Teleinfo discovery: Deactivate {}\", controllerHandler.getThing().getUID());\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Teleinfo discovery: Start {}\", controllerHandler.getThing().getUID());\n+\n+        // Start the search for new devices\n+        controllerHandler.addListener(this);\n+    }\n+\n+    @Override\n+    public synchronized void abortScan() {\n+        logger.debug(\"Teleinfo discovery: Abort {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.abortScan();\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        logger.debug(\"Teleinfo discovery: Stop {}\", controllerHandler.getThing().getUID());\n+        controllerHandler.removeListener(this);\n+        super.stopScan();\n+    }\n+\n+    @Override\n+    public void onFrameReceived(@NonNull TeleinfoAbstractControllerHandler controllerHandler, @NonNull Frame frame) {\n+        detectNewElectricityMeterFromReceivedFrame(frame);\n+    }\n+\n+    private void detectNewElectricityMeterFromReceivedFrame(final Frame frameSample) {\n+        logger.debug(\"New eletricity meter detection from frame {}\", frameSample.getId());\n+        if (frameSample instanceof FrameAdco == false) {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + frameSample.getClass());\n+        }\n+        final FrameAdco frameAdco = (FrameAdco) frameSample;\n+\n+        ThingUID thingUID = getThingUID(frameAdco);\n+\n+        final Map<String, Object> properties = getThingProperties(thingUID.getThingTypeUID(), frameAdco);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eae65be047b51608937a2ad75000649066aa90e"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTU1NTYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowNDo0MlrOGsWQLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowNDo0MlrOGsWQLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1NTExOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | SerialController | serialPort | Path to the serial controller         | /dev/ttyXXXX     |\n          \n          \n            \n            | electricitymeter | adco       | Electricity meter identifier          | 12 digits number |\n          \n          \n            \n            | `serialcontroller` | `serialport` | Path to the serial controller         | /dev/ttyXXXX     |\n          \n          \n            \n            | `*_electricitymeter` | `adco`       | Electricity meter identifier          | 12 digits number |", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449155118", "createdAt": "2020-07-02T17:04:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/README.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# Teleinfo Binding\n+\n+The Teleinfo binding supports an interface to ENEDIS/ERDF [Teleinfo protocol](http://www.linuxembarque.free.fr/electro/compt_energie/specifications_techniques_edf_teleinfo.pdf) for (French) Electricity Meter. This binding works with a Teleinfo modem plugged to the I1 and I2 terminals of your electricity meter. Teleinfo modems can be ordered (see the [list of tested hardware](#tested-hardware) below) or build by yourself (see [this example](http://bernard.lefrancois.free.fr)).\n+\n+Teleinfo is a protocol to read many electrical statistics of your electricity meter: instantaneous power consumption, current price period, meter reading... \n+These values can be used to\n+\n+- send your meter reading to your electricity provider with a simple copy/paste,\n+- improve your rules and minimize electricity costs,\n+- check if your subscription is relevant for your needs,\n+- monitor your electricity consumption,\n+\n+## Supported Things\n+\n+The Teleinfo binding provides support for both single phase and three phase connection, ICC evolution and the following pricing modes:\n+\n+- HCHP mode\n+- Base mode\n+- Tempo mode\n+- EJP mode\n+\n+| Thing type                                 | Connection   | Pricing mode | ICC evolution |\n+|--------------------------------------------|--------------|--------------|---------------|\n+| cbemm_base_electricitymeter                | single-phase | Base         |               |\n+| cbemm_ejp_electricitymeter                 | single-phase | EJP          |               |\n+| cbemm_hc_electricitymeter                  | single-phase | HCHP         |               |\n+| cbemm_tempo_electricitymeter               | single-phase | Tempo        |               |\n+| cbemm_evolution_icc_base_electricitymeter  | single-phase | Base         | [x]           |\n+| cbemm_evolution_icc_ejp_electricitymeter   | single-phase | EJP          | [x]           |\n+| cbemm_evolution_icc_hc_electricitymeter    | single-phase | HCHP         | [x]           |\n+| cbemm_evolution_icc_tempo_electricitymeter | single-phase | Tempo        | [x]           |\n+| cbetm_base_electricitymeter                | three-phase  | Base         |               |\n+| cbetm_ejp_electricitymeter                 | three-phase  | EJP          |               |\n+| cbetm_hc_electricitymeter                  | three-phase  | HCHP         |               |\n+| cbetm_tempo_electricitymeter               | three-phase  | Tempo        |               |\n+\n+## Discovery\n+\n+Before the binding can be used, a serial controller must be added. This needs to be done manually. Select __Teleinfo Serial Controller__ and enter the serial port. Once the serial controller added, electricity meters will automatically appear when trying to add a new thing, with default label __Teleinfo ADCO #adco__ where __#adco__ is  your electricity meter identifier.\n+\n+## Thing Configuration\n+\n+| Thing type       | Parameter  | Meaning                               | Possible values  |\n+|------------------|------------|---------------------------------------|------------------|\n+| SerialController | serialPort | Path to the serial controller         | /dev/ttyXXXX     |\n+| electricitymeter | adco       | Electricity meter identifier          | 12 digits number |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTU1Nzk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowNToyMVrOGsWRpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzowNToyMVrOGsWRpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE1NTQ5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Channel availabity depends on the electricity connection (single or three phase) and on the pricing mode (Base, HCHP, EJP or Tempo).\n          \n          \n            \n            Channel availability depends on the electricity connection (single or three phase) and on the pricing mode (Base, HCHP, EJP or Tempo).", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449155492", "createdAt": "2020-07-02T17:05:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/README.md", "diffHunk": "@@ -0,0 +1,121 @@\n+# Teleinfo Binding\n+\n+The Teleinfo binding supports an interface to ENEDIS/ERDF [Teleinfo protocol](http://www.linuxembarque.free.fr/electro/compt_energie/specifications_techniques_edf_teleinfo.pdf) for (French) Electricity Meter. This binding works with a Teleinfo modem plugged to the I1 and I2 terminals of your electricity meter. Teleinfo modems can be ordered (see the [list of tested hardware](#tested-hardware) below) or build by yourself (see [this example](http://bernard.lefrancois.free.fr)).\n+\n+Teleinfo is a protocol to read many electrical statistics of your electricity meter: instantaneous power consumption, current price period, meter reading... \n+These values can be used to\n+\n+- send your meter reading to your electricity provider with a simple copy/paste,\n+- improve your rules and minimize electricity costs,\n+- check if your subscription is relevant for your needs,\n+- monitor your electricity consumption,\n+\n+## Supported Things\n+\n+The Teleinfo binding provides support for both single phase and three phase connection, ICC evolution and the following pricing modes:\n+\n+- HCHP mode\n+- Base mode\n+- Tempo mode\n+- EJP mode\n+\n+| Thing type                                 | Connection   | Pricing mode | ICC evolution |\n+|--------------------------------------------|--------------|--------------|---------------|\n+| cbemm_base_electricitymeter                | single-phase | Base         |               |\n+| cbemm_ejp_electricitymeter                 | single-phase | EJP          |               |\n+| cbemm_hc_electricitymeter                  | single-phase | HCHP         |               |\n+| cbemm_tempo_electricitymeter               | single-phase | Tempo        |               |\n+| cbemm_evolution_icc_base_electricitymeter  | single-phase | Base         | [x]           |\n+| cbemm_evolution_icc_ejp_electricitymeter   | single-phase | EJP          | [x]           |\n+| cbemm_evolution_icc_hc_electricitymeter    | single-phase | HCHP         | [x]           |\n+| cbemm_evolution_icc_tempo_electricitymeter | single-phase | Tempo        | [x]           |\n+| cbetm_base_electricitymeter                | three-phase  | Base         |               |\n+| cbetm_ejp_electricitymeter                 | three-phase  | EJP          |               |\n+| cbetm_hc_electricitymeter                  | three-phase  | HCHP         |               |\n+| cbetm_tempo_electricitymeter               | three-phase  | Tempo        |               |\n+\n+## Discovery\n+\n+Before the binding can be used, a serial controller must be added. This needs to be done manually. Select __Teleinfo Serial Controller__ and enter the serial port. Once the serial controller added, electricity meters will automatically appear when trying to add a new thing, with default label __Teleinfo ADCO #adco__ where __#adco__ is  your electricity meter identifier.\n+\n+## Thing Configuration\n+\n+| Thing type       | Parameter  | Meaning                               | Possible values  |\n+|------------------|------------|---------------------------------------|------------------|\n+| SerialController | serialPort | Path to the serial controller         | /dev/ttyXXXX     |\n+| electricitymeter | adco       | Electricity meter identifier          | 12 digits number |\n+\n+## Channels\n+\n+Channel availabity depends on the electricity connection (single or three phase) and on the pricing mode (Base, HCHP, EJP or Tempo).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTYzMzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyNzoyMFrOGsXAZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzoyNzoyMFrOGsXAZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2NzQ2Mg==", "bodyText": "Can you make these all upper case and final?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449167462", "createdAt": "2020-07-02T17:27:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY2NzI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozODowNFrOGsXVeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMDoxNzowMlrOGtEnZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3Mjg1Ng==", "bodyText": "If I understand correctly, the tasks submitted to this executor will only block for 3,3sec.. Then, you should use openHAB's scheduler. The BaseThingHandlers have a scheduler field for this purpose.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449172856", "createdAt": "2020-07-02T17:38:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2MTgzNg==", "bodyText": "How can I get a BaseThingHandler at this place?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449261836", "createdAt": "2020-07-02T20:55:57Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3Mjg1Ng=="}, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI4NjkzNw==", "bodyText": "You could use this way: TeleinfoSerialControllerHandler -> TeleinfoReceiveThread -> TeleinfoInputStream", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449286937", "createdAt": "2020-07-02T22:07:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3Mjg1Ng=="}, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc2OTgzMg==", "bodyText": "TeleinfoInputStream must be/stay independent of Openhab classes (= no openhab classes in imports section): this is an API. So, if you want set a different implementation of ExecutorService class (or equivalent), you must define a new constructor or add a setter with an ExecutorService parameter.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449769832", "createdAt": "2020-07-04T12:36:15Z", "author": {"login": "nokyyz"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3Mjg1Ng=="}, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkxNDcyNQ==", "bodyText": "Thanks! Done with a new constructor.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449914725", "createdAt": "2020-07-05T20:17:02Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3Mjg1Ng=="}, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY3MDk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOToxMlrOGsXXlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOToxMlrOGsXXlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzM5OQ==", "bodyText": "You could make the method return the exception and throw it here. Then, the return can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449173399", "createdAt": "2020-07-02T17:39:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized @Nullable Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+\n+        // seek the next header frame\n+        Future<@Nullable Void> seekNextHeaderFrameTask = executorService.submit(() -> {\n+            while (!isHeaderFrame(groupLine)) {\n+                groupLine = bufferedReader.readLine();\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+                }\n+                if (groupLine == null) { // end of stream\n+                    logger.trace(\"end of stream reached !\");\n+                    return null;\n+                }\n+            }\n+\n+            logger.trace(\"header frame found !\");\n+            return null;\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);\n+        } catch (ExecutionException e) {\n+            rethrowTaskExecutionException(e);\n+            return null; // FIXME best way ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTY3MzgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOTo1NlrOGsXZLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOTo1NlrOGsXZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzgwNg==", "bodyText": "The suffix Ms stands for milliseconds. Us would be microseconds.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449173806", "createdAt": "2020-07-02T17:39:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized @Nullable Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+\n+        // seek the next header frame\n+        Future<@Nullable Void> seekNextHeaderFrameTask = executorService.submit(() -> {\n+            while (!isHeaderFrame(groupLine)) {\n+                groupLine = bufferedReader.readLine();\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+                }\n+                if (groupLine == null) { // end of stream\n+                    logger.trace(\"end of stream reached !\");\n+                    return null;\n+                }\n+            }\n+\n+            logger.trace(\"header frame found !\");\n+            return null;\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTcxNjc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzo1MzoyNlrOGsXzxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzo1MzoyNlrOGsXzxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDYxMw==", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be warn or debug. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449180613", "createdAt": "2020-07-02T17:53:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.defaultTimeoutNextHeaderFrame * 100,\n+                TeleinfoInputStream.defaultTimeoutReadingFrame * 100, autoRepairInvalidADPSgroupLine)) {\n+            while (!interrupted()) {\n+                TeleinfoReceiveThreadListener listener = this.listener;\n+                if (listener != null) {\n+                    try {\n+                        Frame nextFrame = teleinfoStream.readNextFrame();\n+                        if (nextFrame != null)\n+                            listener.onFrameReceived(this, nextFrame);\n+                    } catch (InvalidFrameException e) {\n+                        logger.error(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc0NjA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMjowNlrOGsYF6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMjowNlrOGsYF6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTI1OQ==", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently). When dispose() is invoked concurrently in this method, before the receiving thread has been created, it won't be stopped. The status should be set to unknown as one of the last actions.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449185259", "createdAt": "2020-07-02T18:02:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc1MDAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMzozMFrOGsYIZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowMzozMFrOGsYIZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTg5Mw==", "bodyText": "Created threads should be daemon.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    setDaemon(true);", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449185893", "createdAt": "2020-07-02T18:03:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine) {\n+        super(\"TeleinfoReceiveThread\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc1MzM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDozM1rOGsYKaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNDozM1rOGsYKaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjQwOQ==", "bodyText": "No harm in cancelling a task that is already cancelled. The if can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449186409", "createdAt": "2020-07-02T18:04:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                openSerialPortAndStartReceiving();\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            if (!keepAliveThreadRef.isCancelled())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc2MTI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNjo1OFrOGsYPVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNjo1OFrOGsYPVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NzY2OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449187668", "createdAt": "2020-07-02T18:06:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                openSerialPortAndStartReceiving();\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            if (!keepAliveThreadRef.isCancelled())\n+                keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+\n+        TeleinfoSerialControllerConfiguration config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport.trim().isEmpty()) {\n+            logger.error(\"Teleinfo port is not set.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc2MjYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNzoyNlrOGsYQLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNzoyNlrOGsYQLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Nzg4Nw==", "bodyText": "info should be used very rarely. You could make this debug or trace.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449187887", "createdAt": "2020-07-02T18:07:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                openSerialPortAndStartReceiving();\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            if (!keepAliveThreadRef.isCancelled())\n+                keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+\n+        TeleinfoSerialControllerConfiguration config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport.trim().isEmpty()) {\n+            logger.error(\"Teleinfo port is not set.\");\n+            return;\n+        }\n+\n+        logger.info(\"Connecting to serial port '{}'...\", config.serialport);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc2NjM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowODo0OFrOGsYSiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowODo0OFrOGsYSiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4ODQ4OQ==", "bodyText": "The message parameter of updateStatus() is logged by the framework. You could remove the log message.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449188489", "createdAt": "2020-07-02T18:08:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                openSerialPortAndStartReceiving();\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            if (!keepAliveThreadRef.isCancelled())\n+                keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+\n+        TeleinfoSerialControllerConfiguration config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport.trim().isEmpty()) {\n+            logger.error(\"Teleinfo port is not set.\");\n+            return;\n+        }\n+\n+        logger.info(\"Connecting to serial port '{}'...\", config.serialport);\n+        String currentOwner = null;\n+        try {\n+            final SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(config.serialport);\n+            logger.debug(\"portIdentifier = {}\", portIdentifier);\n+            if (portIdentifier == null) {\n+                logger.error(\"No port identifier for '{}'\", config.serialport);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        ERROR_OFFLINE_SERIAL_NOT_FOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc2ODY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowOToyOVrOGsYT6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowOToyOVrOGsYT6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4ODg0MQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449188841", "createdAt": "2020-07-02T18:09:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                openSerialPortAndStartReceiving();\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            if (!keepAliveThreadRef.isCancelled())\n+                keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+\n+        TeleinfoSerialControllerConfiguration config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport.trim().isEmpty()) {\n+            logger.error(\"Teleinfo port is not set.\");\n+            return;\n+        }\n+\n+        logger.info(\"Connecting to serial port '{}'...\", config.serialport);\n+        String currentOwner = null;\n+        try {\n+            final SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(config.serialport);\n+            logger.debug(\"portIdentifier = {}\", portIdentifier);\n+            if (portIdentifier == null) {\n+                logger.error(\"No port identifier for '{}'\", config.serialport);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        ERROR_OFFLINE_SERIAL_NOT_FOUND);\n+                return;\n+            }\n+            logger.debug(\"Opening portIdentifier\");\n+            currentOwner = portIdentifier.getCurrentOwner();\n+            logger.debug(\"portIdentifier.getCurrentOwner() = {}\", currentOwner);\n+            SerialPort commPort = portIdentifier.open(\"org.openhab.binding.teleinfo\", 5000);\n+            serialPort = commPort;\n+\n+            commPort.setSerialPortParams(1200, SerialPort.DATABITS_7, SerialPort.STOPBITS_1, SerialPort.PARITY_EVEN);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(SERIAL_RECEIVE_TIMEOUT);\n+            logger.debug(\"Starting receive thread\");\n+            TeleinfoReceiveThread receiveThread = new TeleinfoReceiveThread(commPort, this,\n+                    config.autoRepairInvalidADPSgroupLine);\n+            this.receiveThread = receiveThread;\n+            receiveThread.start();\n+\n+            logger.info(\"Connected to serial port '{}'\", config.serialport);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc4NTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNToxMlrOGsYeTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNToxMlrOGsYeTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MTUwMg==", "bodyText": "If I see correctly, you come here when TeleinfoSerialControllerHandler.stopReceivingAndCloseSerialPort() is invoked. The receiving thread needs to be interrupted, then, otherwise join() will block.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449191502", "createdAt": "2020-07-02T18:15:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static long defaultTimeoutNextHeaderFrame = 33400;\n+    public static long defaultTimeoutReadingFrame = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService = Executors.newFixedThreadPool(2);\n+    private long waitNextHeaderFrameTimeoutInMs;\n+    private long readingFrameTimeoutInMs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, defaultTimeoutNextHeaderFrame, defaultTimeoutReadingFrame,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        executorService.shutdownNow();\n+        super.close();\n+        logger.debug(\"close() [end]\");\n+    }\n+\n+    /**\n+     * Returns the next frame.\n+     *\n+     * @return the next frame or null if end of stream\n+     * @throws InvalidFrameException if the read data from\n+     * @throws TimeoutException if the delay to read a complete frame is expired (33,4 ms) or if the delay to find\n+     *             the\n+     *             header of next frame is expired (33,4 ms)\n+     * @throws IOException\n+     */\n+    public synchronized @Nullable Frame readNextFrame() throws InvalidFrameException, TimeoutException, IOException {\n+\n+        // seek the next header frame\n+        Future<@Nullable Void> seekNextHeaderFrameTask = executorService.submit(() -> {\n+            while (!isHeaderFrame(groupLine)) {\n+                groupLine = bufferedReader.readLine();\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"groupLine = {}\", groupLine);\n+                }\n+                if (groupLine == null) { // end of stream\n+                    logger.trace(\"end of stream reached !\");\n+                    return null;\n+                }\n+            }\n+\n+            logger.trace(\"header frame found !\");\n+            return null;\n+        });\n+        try {\n+            logger.debug(\"seeking the next header frame...\");\n+            logger.trace(\"waitNextHeaderFrameTimeoutInMs = {}\", waitNextHeaderFrameTimeoutInMs);\n+            seekNextHeaderFrameTask.get(waitNextHeaderFrameTimeoutInMs, TimeUnit.MICROSECONDS);\n+\n+            if (groupLine == null) { // end of stream\n+                return null;\n+            }\n+        } catch (InterruptedException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc5MDU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmEvolutionIccBaseOptionElectricityMeter.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNzowMFrOGsYhsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxNzowMFrOGsYhsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MjM2OA==", "bodyText": "Is the bracket intended?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449192368", "createdAt": "2020-07-02T18:17:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmEvolutionIccBaseOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,27 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_evolution_icc_base_electricitymeter\" listed=\"false\">\n+\t\t<label>CBEMM ICC BASE)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc5Nzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/serialController.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxOToyNlrOGsYmVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxOToyNlrOGsYmVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MzU1Nw==", "bodyText": "Words in labels should be capitalized. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449193557", "createdAt": "2020-07-02T18:19:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/serialController.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"serialcontroller\">\n+\t\t<label>Teleinfo Serial Controller</label>\n+\t\t<description>Teleinfo USB Stick with Serial Interface</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"invalidFrameCounter\" typeId=\"invalidFrameCounterType\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialport\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>Serial port of Teleinfo device (e.g.: /dev/ttyUSB0 on Linux, COM1 on Windows)</description>\n+\t\t\t\t<limitToOptions>false</limitToOptions>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"autoRepairInvalidADPSgroupLine\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Auto repair malformed ADPS data</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTc5ODQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/serialController.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxOTo0M1rOGsYmwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoxOTo0M1rOGsYmwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5MzY2NA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449193664", "createdAt": "2020-07-02T18:19:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/serialController.xml", "diffHunk": "@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<bridge-type id=\"serialcontroller\">\n+\t\t<label>Teleinfo Serial Controller</label>\n+\t\t<description>Teleinfo USB Stick with Serial Interface</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"invalidFrameCounter\" typeId=\"invalidFrameCounterType\"/>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialport\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>Serial port of Teleinfo device (e.g.: /dev/ttyUSB0 on Linux, COM1 on Windows)</description>\n+\t\t\t\t<limitToOptions>false</limitToOptions>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"autoRepairInvalidADPSgroupLine\" type=\"boolean\" required=\"false\">\n+\t\t\t\t<label>Auto repair malformed ADPS data</label>\n+\t\t\t\t<description>Try to auto repair malformed ADPS data from hardware issues (e.g: \"ADPS032\" instead of \"ADPS 032\"\n+\t\t\t\t\texpected/well-formed data)</description>\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\n+\t<channel-type id=\"invalidFrameCounterType\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Frames corrupted</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTgxMjQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmBaseOptionElectricityMeter.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoyNDozNFrOGsYv2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODoyNDozNFrOGsYv2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NTk5NQ==", "bodyText": "You could reference the allowed bridge types with <supported-bridge-type-refs>.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r449195995", "createdAt": "2020-07-02T18:24:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/resources/ESH-INF/thing/cbemmBaseOptionElectricityMeter.xml", "diffHunk": "@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"teleinfo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"cbemm_base_electricitymeter\" listed=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7badcc4ba5eaf14f014e53cb3ada47cfda34bd8d"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjc3NTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTozODowNlrOGu2kEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTozODowNlrOGu2kEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc4MTY1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInMs;\n          \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r451781651", "createdAt": "2020-07-08T19:38:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -120,20 +121,30 @@ public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long\n             throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n         }\n \n-        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c513782b3c5c3a9103f606389b9025408094e390"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjc4MTQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTo0MDoyMVrOGu2oPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTo0MDoyMVrOGu2oPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc4MjcxOA==", "bodyText": "The invocation of this constructor will indirectly create the thread pool in line 129.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r451782718", "createdAt": "2020-07-08T19:40:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -120,20 +121,30 @@ public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long\n             throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n         }\n \n-        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInMs;\n         this.readingFrameTimeoutInMs = readingFrameTimeoutInMs;\n         this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n \n         this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+        this.executorService = Executors.newFixedThreadPool(2);\n \n         groupLine = null;\n     }\n \n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInMs,\n+            long readingFrameTimeoutInMs, boolean autoRepairInvalidADPSgroupLine, ExecutorService executorService) {\n+        this(teleinfoInputStream, waitNextHeaderFrameTimeoutInMs, readingFrameTimeoutInMs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c513782b3c5c3a9103f606389b9025408094e390"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxNjc4NTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTo0MTozM1rOGu2qnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxOTo0MTozM1rOGu2qnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc4MzMyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInMs;\n          \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r451783324", "createdAt": "2020-07-08T19:41:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -256,19 +263,20 @@ public void close() throws IOException {\n \n             return frame;\n         } catch (InterruptedException e) {\n+            logger.warn(\"Got interrupted exception\", e);\n+            Thread.currentThread().interrupt();\n             throw new IllegalStateException(e);\n         } catch (ExecutionException e) {\n-            rethrowTaskExecutionException(e);\n-            return null; // FIXME best way ?\n+            throw rethrowTaskExecutionException(e);\n         }\n     }\n \n     public long getWaitNextHeaderFrameTimeoutInMs() {\n-        return waitNextHeaderFrameTimeoutInMs;\n+        return waitNextHeaderFrameTimeoutInUs;\n     }\n \n     public void setWaitNextHeaderFrameTimeoutInMs(long waitNextHeaderFrameTimeoutInMs) {\n-        this.waitNextHeaderFrameTimeoutInMs = waitNextHeaderFrameTimeoutInMs;\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c513782b3c5c3a9103f606389b9025408094e390"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODM1NDk3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0ODowOFrOGzdopA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0ODowOFrOGzdopA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNjEwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final long DEFAULT_TIMEOUT_NEXT_HEADER_FRAME = 33400;\n          \n          \n            \n                public static final long DEFAULT_TIMEOUT_READING_FRAME = 33400;\n          \n          \n            \n                public static final long DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US = 33400;\n          \n          \n            \n                public static final long DEFAULT_TIMEOUT_READING_FRAME_US = 33400;", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r456616100", "createdAt": "2020-07-17T18:48:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,689 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static final long DEFAULT_TIMEOUT_NEXT_HEADER_FRAME = 33400;\n+    public static final long DEFAULT_TIMEOUT_READING_FRAME = 33400;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a194548d7c0843df63ca92605ac7bdbc913eea9"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODM1Nzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0OToxM1rOGzdqfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0OToxM1rOGzdqfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNjU3Mw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r456616573", "createdAt": "2020-07-17T18:49:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private ExecutorService executorService;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine, ExecutorService scheduler) {\n+        super(\"TeleinfoReceiveThread\");\n+        setDaemon(true);\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+        this.executorService = scheduler;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_NEXT_HEADER_FRAME * 100,\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME * 100, autoRepairInvalidADPSgroupLine,\n+                executorService)) {\n+            while (!interrupted()) {\n+                TeleinfoReceiveThreadListener listener = this.listener;\n+                if (listener != null) {\n+                    try {\n+                        Frame nextFrame = teleinfoStream.readNextFrame();\n+                        if (nextFrame != null)\n+                            listener.onFrameReceived(this, nextFrame);\n+                    } catch (InvalidFrameException e) {\n+                        logger.warn(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());\n+                        listener.onInvalidFrameReceived(this, e);\n+                    } catch (TimeoutException e) {\n+                        logger.warn(\"Got timeout during frame reading\", e);\n+                        if (!listener.continueOnReadNextFrameTimeoutException(this, e)) {\n+                            break;\n+                        }\n+                        // skipInputStreamBuffer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a194548d7c0843df63ca92605ac7bdbc913eea9"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODM1OTQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0OTo0OVrOGzdrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0OTo0OVrOGzdrfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNjgyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n          \n          \n            \n                private static final int SERIAL_RECEIVE_TIMEOUT_MS = 250;", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r456616828", "createdAt": "2020-07-17T18:49:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a194548d7c0843df63ca92605ac7bdbc913eea9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODM3MTkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo1Mzo1NFrOGzdy9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo1Mzo1NFrOGzdy9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODc0MA==", "bodyText": "You might want to add a timeout parameter to join() in case something blocks the interrupt.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r456618740", "createdAt": "2020-07-17T18:53:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                openSerialPortAndStartReceiving();\n+                updateStatus(ThingStatus.UNKNOWN);\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }\n+    }\n+\n+    private void openSerialPortAndStartReceiving() {\n+        TeleinfoSerialControllerConfiguration config = getConfigAs(TeleinfoSerialControllerConfiguration.class);\n+\n+        if (config.serialport.trim().isEmpty()) {\n+            logger.warn(\"Teleinfo port is not set.\");\n+            return;\n+        }\n+\n+        logger.debug(\"Connecting to serial port '{}'...\", config.serialport);\n+        String currentOwner = null;\n+        try {\n+            final SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(config.serialport);\n+            logger.debug(\"portIdentifier = {}\", portIdentifier);\n+            if (portIdentifier == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        ERROR_OFFLINE_SERIAL_NOT_FOUND);\n+                return;\n+            }\n+            logger.debug(\"Opening portIdentifier\");\n+            currentOwner = portIdentifier.getCurrentOwner();\n+            logger.debug(\"portIdentifier.getCurrentOwner() = {}\", currentOwner);\n+            SerialPort commPort = portIdentifier.open(\"org.openhab.binding.teleinfo\", 5000);\n+            serialPort = commPort;\n+\n+            commPort.setSerialPortParams(1200, SerialPort.DATABITS_7, SerialPort.STOPBITS_1, SerialPort.PARITY_EVEN);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(SERIAL_RECEIVE_TIMEOUT);\n+            logger.debug(\"Starting receive thread\");\n+            TeleinfoReceiveThread receiveThread = new TeleinfoReceiveThread(commPort, this,\n+                    config.autoRepairInvalidADPSgroupLine, scheduler);\n+            this.receiveThread = receiveThread;\n+            receiveThread.start();\n+\n+            logger.debug(\"Connected to serial port '{}'\", config.serialport);\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    ERROR_OFFLINE_SERIAL_INUSE);\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    ERROR_OFFLINE_SERIAL_UNSUPPORTED);\n+        }\n+    }\n+\n+    private void stopReceivingAndCloseSerialPort() {\n+        TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+        if (receiveThreadRef != null) {\n+            receiveThreadRef.interrupt();\n+            try {\n+                receiveThreadRef.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a194548d7c0843df63ca92605ac7bdbc913eea9"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjUzNzE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/TeleinfoReaderListenerAdaptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowMDoxOFrOHJ8bfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowMDoxOFrOHJ8bfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4OTMxMQ==", "bodyText": "This looks like this could also be implemented by adding default methods to the TeleinfoReaderListener interface?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480189311", "createdAt": "2020-08-31T15:00:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/TeleinfoReaderListenerAdaptor.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+\n+/**\n+ * The {@link TeleinfoReaderListenerAdaptor} class defines an adaptor at {@link TeleinfoReaderListener} interface.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class TeleinfoReaderListenerAdaptor implements TeleinfoReaderListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU0MTg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/TeleinfoReader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowMToyNVrOHJ8ebA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowMToyNVrOHJ8ebA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5MDA2MA==", "bodyText": "Can be removed as it's already on the super interface?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480190060", "createdAt": "2020-08-31T15:01:25Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/TeleinfoReader.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link TeleinfoReader} interface defines a mechanism to read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface TeleinfoReader extends Closeable {\n+\n+    void open() throws IOException;\n+\n+    @Override\n+    void close() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU2ODA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowODoxMlrOHJ8unQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNTowODoxMlrOHJ8unQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5NDIwNQ==", "bodyText": "It is general suggested to store the configuration in a field. And only read it in initialize(). You can use a configuration data class and read it with getConfigAs() in initialize. If you would need different types of configuration you could add the class as generic to the class interface. Something like TeleinfoAbstractCbemmElectricityMeterHandler<MeterConfig>. At this moment it looks all devices have the same configuration parameters so no need to create different constants or classes than.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480194205", "createdAt": "2020-08-31T15:08:12Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/cbemm/TeleinfoBaseCbemmElectricityMeterHandler.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler.cbemm;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+\n+/**\n+ * The {@link TeleinfoBaseCbemmElectricityMeterHandler} class defines a handler for a BASE CBEMM Electricity Meters\n+ * thing.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ * @author Olivier MARCEAU - Change ADCO property to parameter\n+ */\n+@NonNullByDefault\n+public class TeleinfoBaseCbemmElectricityMeterHandler extends TeleinfoAbstractCbemmElectricityMeterHandler {\n+\n+    public TeleinfoBaseCbemmElectricityMeterHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoAbstractControllerHandler controllerHandler, Frame frame) {\n+        final FrameCbemmBaseOption frameCbemmBaseOption = (FrameCbemmBaseOption) frame;\n+\n+        String adco = (String) getThing().getConfiguration().get(THING_BASE_CBEMM_ELECTRICITY_METER_PROPERTY_ADCO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU3ODg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxMDo1NlrOHJ81TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxMDo1NlrOHJ81TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5NTkxNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!useOpenhabScheduler)\n          \n          \n            \n                        executorService.shutdownNow();\n          \n          \n            \n                    if (!useOpenhabScheduler) {\n          \n          \n            \n                        executorService.shutdownNow();\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nMaybe run mvn spotless:apply?", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480195917", "createdAt": "2020-08-31T15:10:56Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,689 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static final long DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US = 33400;\n+    public static final long DEFAULT_TIMEOUT_READING_FRAME_US = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService;\n+    private long waitNextHeaderFrameTimeoutInUs;\n+    private long readingFrameTimeoutInUs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private boolean useOpenhabScheduler;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US, DEFAULT_TIMEOUT_READING_FRAME_US, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US, DEFAULT_TIMEOUT_READING_FRAME_US,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n+            long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n+        this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+        this.executorService = Executors.newFixedThreadPool(2);\n+        this.useOpenhabScheduler = false;\n+\n+        groupLine = null;\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n+            long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine, ExecutorService executorService) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n+        this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+        this.executorService = executorService;\n+        this.useOpenhabScheduler = true;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+\n+        groupLine = null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        logger.debug(\"close() [start]\");\n+        bufferedReader.close();\n+        if (!useOpenhabScheduler)\n+            executorService.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU4OTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxMzozMVrOHJ87nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxMzozMVrOHJ87nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5NzUzMw==", "bodyText": "Can you give the thread a name similar to:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(\"TeleinfoReceiveThread\");\n          \n          \n            \n                    super(\"OH-binding-TeleinfoReceiveThread\");\n          \n      \n    \n    \n  \n\nAnd preferable also add the thing UID if multiple instances of this class would be running it would be possible to see to which thing this thread is associated.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480197533", "createdAt": "2020-08-31T15:13:31Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private ExecutorService executorService;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine, ExecutorService scheduler) {\n+        super(\"TeleinfoReceiveThread\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU5MTE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNDowM1rOHJ882Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNDowM1rOHJ882Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5Nzg0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.error(\"An error occurred during serial port input stream opening\", e);\n          \n          \n            \n                        logger.warn(\"An error occurred during serial port input stream opening\", e);", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480197849", "createdAt": "2020-08-31T15:14:03Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private ExecutorService executorService;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine, ExecutorService scheduler) {\n+        super(\"TeleinfoReceiveThread\");\n+        setDaemon(true);\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+        this.executorService = scheduler;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US * 100,\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME_US * 100, autoRepairInvalidADPSgroupLine,\n+                executorService)) {\n+            while (!interrupted()) {\n+                TeleinfoReceiveThreadListener listener = this.listener;\n+                if (listener != null) {\n+                    try {\n+                        Frame nextFrame = teleinfoStream.readNextFrame();\n+                        if (nextFrame != null)\n+                            listener.onFrameReceived(this, nextFrame);\n+                    } catch (InvalidFrameException e) {\n+                        logger.warn(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());\n+                        listener.onInvalidFrameReceived(this, e);\n+                    } catch (TimeoutException e) {\n+                        logger.warn(\"Got timeout during frame reading\", e);\n+                        if (!listener.continueOnReadNextFrameTimeoutException(this, e)) {\n+                            break;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"Got I/O exception. Detail: \\\"{}\\\"\", e.getLocalizedMessage(), e);\n+                        listener.onSerialPortInputStreamIOException(this, e);\n+                        break;\n+                    } catch (Exception e) {\n+                        logger.warn(\"Got exception\", e);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.error(\"An error occurred during serial port input stream opening\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjU5NTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNTowNlrOHJ8_rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToxNTowNlrOHJ8_rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5ODU3NA==", "bodyText": "Is someone throwing an Exception or is the a general catch? otherwise change to RuntimException or the specific exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480198574", "createdAt": "2020-08-31T15:15:06Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoReceiveThread.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.reader.io.TeleinfoInputStream;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoReceiveThread} class defines a thread to decode and fire Teleinfo frames for Serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoReceiveThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoReceiveThread.class);\n+\n+    private SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThreadListener listener;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private ExecutorService executorService;\n+\n+    public TeleinfoReceiveThread(SerialPort serialPort, final TeleinfoReceiveThreadListener listener,\n+            boolean autoRepairInvalidADPSgroupLine, ExecutorService scheduler) {\n+        super(\"TeleinfoReceiveThread\");\n+        setDaemon(true);\n+        this.serialPort = serialPort;\n+        this.listener = listener;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+        this.executorService = scheduler;\n+    }\n+\n+    @Override\n+    public void run() {\n+        try (TeleinfoInputStream teleinfoStream = new TeleinfoInputStream(serialPort.getInputStream(),\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US * 100,\n+                TeleinfoInputStream.DEFAULT_TIMEOUT_READING_FRAME_US * 100, autoRepairInvalidADPSgroupLine,\n+                executorService)) {\n+            while (!interrupted()) {\n+                TeleinfoReceiveThreadListener listener = this.listener;\n+                if (listener != null) {\n+                    try {\n+                        Frame nextFrame = teleinfoStream.readNextFrame();\n+                        if (nextFrame != null)\n+                            listener.onFrameReceived(this, nextFrame);\n+                    } catch (InvalidFrameException e) {\n+                        logger.warn(\"Got invalid frame. Detail: \\\"{}\\\"\", e.getLocalizedMessage());\n+                        listener.onInvalidFrameReceived(this, e);\n+                    } catch (TimeoutException e) {\n+                        logger.warn(\"Got timeout during frame reading\", e);\n+                        if (!listener.continueOnReadNextFrameTimeoutException(this, e)) {\n+                            break;\n+                        }\n+                    } catch (IOException e) {\n+                        logger.warn(\"Got I/O exception. Detail: \\\"{}\\\"\", e.getLocalizedMessage(), e);\n+                        listener.onSerialPortInputStreamIOException(this, e);\n+                        break;\n+                    } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMjYyNjYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToyMjo0OFrOHJ9SUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNToyMjo0OFrOHJ9SUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwMzM0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n          \n          \n            \n                        long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine) {\n          \n          \n            \n                    if (teleinfoInputStream == null) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n          \n          \n            \n                    this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n          \n          \n            \n                    this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n          \n          \n            \n            \n          \n          \n            \n                    this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n          \n          \n            \n                    this.executorService = Executors.newFixedThreadPool(2);\n          \n          \n            \n                    this.useOpenhabScheduler = false;\n          \n          \n            \n            \n          \n          \n            \n                    groupLine = null;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n          \n          \n            \n                        long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine, ExecutorService executorService) {\n          \n          \n            \n                    if (teleinfoInputStream == null) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n          \n          \n            \n                    this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n          \n          \n            \n                    this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n          \n          \n            \n                    this.executorService = executorService;\n          \n          \n            \n                    this.useOpenhabScheduler = true;\n          \n          \n            \n            \n          \n          \n            \n                    this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n          \n          \n            \n            \n          \n          \n            \n                    groupLine = null;\n          \n          \n            \n                }\n          \n          \n            \n                public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n          \n          \n            \n                        long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine) {\n          \n          \n            \n                    this(teleinfoInputStream, waitNextHeaderFrameTimeoutInUs, readingFrameTimeoutInUs, autoRepairInvalidADPSgroupLine, null);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n          \n          \n            \n                        long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine, @Nullable ExecutorService executorService) {\n          \n          \n            \n                    if (teleinfoInputStream == null) {\n          \n          \n            \n                        throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n          \n          \n            \n                    this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n          \n          \n            \n                    this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n          \n          \n            \n                    if (executorService == null) {\n          \n          \n            \n                        this.executorService = Executors.newFixedThreadPool(2);\n          \n          \n            \n                        this.useOwnScheduler = true;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        this.executorService = executorService;\n          \n          \n            \n                        this.useOwnScheduler = false;\n          \n          \n            \n                   }\n          \n          \n            \n            \n          \n          \n            \n                    this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n          \n          \n            \n            \n          \n          \n            \n                    groupLine = null;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480203347", "createdAt": "2020-08-31T15:22:48Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/reader/io/TeleinfoInputStream.java", "diffHunk": "@@ -0,0 +1,689 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.reader.io;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemm;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.FrameCbemmTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIcc;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbemm.evoicc.FrameCbemmEvolutionIccTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLong;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmLongTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.cbetm.FrameCbetmShort;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameBaseOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameEjpOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameHcOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.CouleurDemain;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit1;\n+import org.openhab.binding.teleinfo.internal.dto.common.FrameTempoOption.ProgrammeCircuit2;\n+import org.openhab.binding.teleinfo.internal.dto.common.Hhphc;\n+import org.openhab.binding.teleinfo.internal.dto.common.Ptec;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.ConversionException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.FrameUtil;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.Label;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.Converter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.CouleurDemainConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.FloatConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.HhphcConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.IntegerConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.PtecConverter;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.converter.StringConverter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * InputStream for Teleinfo {@link Frame} in serial port format.\n+ */\n+/**\n+ * The {@link TeleinfoInputStream} class is an {@link InputStream} to decode/read Teleinfo frames.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoInputStream extends InputStream {\n+\n+    public static final long DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US = 33400;\n+    public static final long DEFAULT_TIMEOUT_READING_FRAME_US = 33400;\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoInputStream.class);\n+    private static final Map<Class<?>, Converter> LABEL_VALUE_CONVERTERS;\n+\n+    private BufferedReader bufferedReader;\n+    private @Nullable String groupLine;\n+    private ExecutorService executorService;\n+    private long waitNextHeaderFrameTimeoutInUs;\n+    private long readingFrameTimeoutInUs;\n+    private boolean autoRepairInvalidADPSgroupLine;\n+    private boolean useOpenhabScheduler;\n+\n+    static {\n+        LABEL_VALUE_CONVERTERS = new HashMap<>();\n+        LABEL_VALUE_CONVERTERS.put(Integer.class, new IntegerConverter());\n+        LABEL_VALUE_CONVERTERS.put(String.class, new StringConverter());\n+        LABEL_VALUE_CONVERTERS.put(Float.class, new FloatConverter());\n+        LABEL_VALUE_CONVERTERS.put(Ptec.class, new PtecConverter());\n+        LABEL_VALUE_CONVERTERS.put(Hhphc.class, new HhphcConverter());\n+        LABEL_VALUE_CONVERTERS.put(CouleurDemain.class, new CouleurDemainConverter());\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US, DEFAULT_TIMEOUT_READING_FRAME_US, false);\n+    }\n+\n+    public TeleinfoInputStream(final InputStream teleinfoInputStream, boolean autoRepairInvalidADPSgroupLine) {\n+        this(teleinfoInputStream, DEFAULT_TIMEOUT_NEXT_HEADER_FRAME_US, DEFAULT_TIMEOUT_READING_FRAME_US,\n+                autoRepairInvalidADPSgroupLine);\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n+            long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n+        this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+        this.executorService = Executors.newFixedThreadPool(2);\n+        this.useOpenhabScheduler = false;\n+\n+        groupLine = null;\n+    }\n+\n+    public TeleinfoInputStream(final @Nullable InputStream teleinfoInputStream, long waitNextHeaderFrameTimeoutInUs,\n+            long readingFrameTimeoutInUs, boolean autoRepairInvalidADPSgroupLine, ExecutorService executorService) {\n+        if (teleinfoInputStream == null) {\n+            throw new IllegalArgumentException(\"Teleinfo inputStream is null\");\n+        }\n+\n+        this.waitNextHeaderFrameTimeoutInUs = waitNextHeaderFrameTimeoutInUs;\n+        this.readingFrameTimeoutInUs = readingFrameTimeoutInUs;\n+        this.autoRepairInvalidADPSgroupLine = autoRepairInvalidADPSgroupLine;\n+        this.executorService = executorService;\n+        this.useOpenhabScheduler = true;\n+\n+        this.bufferedReader = new BufferedReader(new InputStreamReader(teleinfoInputStream, StandardCharsets.US_ASCII));\n+\n+        groupLine = null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjg5ODgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzowODowOFrOHKn5uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzowODowOFrOHKn5uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMTU2Mw==", "bodyText": "I would move this sleep to the reader thread since a sleep should never be done in a scheduled task on the openHAB scheduler. To make sure it's clear this sleep is not associated with this class.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480901563", "createdAt": "2020-09-01T07:08:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/serial/TeleinfoSerialControllerHandler.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.serial;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.teleinfo.internal.dto.Frame;\n+import org.openhab.binding.teleinfo.internal.handler.TeleinfoAbstractControllerHandler;\n+import org.openhab.binding.teleinfo.internal.reader.io.serialport.InvalidFrameException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TeleinfoSerialControllerHandler} class defines a handler for serial controller.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TeleinfoSerialControllerHandler extends TeleinfoAbstractControllerHandler\n+        implements TeleinfoReceiveThreadListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TeleinfoSerialControllerHandler.class);\n+\n+    private static final int SERIAL_RECEIVE_TIMEOUT_MS = 250;\n+    private static final int SERIAL_PORT_DELAY_RETRY_IN_SECONDS = 60;\n+    private static final int RECEIVER_THREAD_JOIN_DELAY_MS = 500;\n+\n+    private SerialPortManager serialPortManager;\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable TeleinfoReceiveThread receiveThread;\n+    private @Nullable ScheduledFuture<?> keepAliveThread;\n+    private long invalidFrameCounter = 0;\n+\n+    public TeleinfoSerialControllerHandler(Bridge thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        invalidFrameCounter = 0;\n+\n+        keepAliveThread = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!isInitialized()) {\n+                openSerialPortAndStartReceiving();\n+                updateStatus(ThingStatus.UNKNOWN);\n+            }\n+            logger.debug(\"Check Teleinfo receiveThread status...\");\n+            logger.debug(\"isInitialized() = {}\", isInitialized());\n+            TeleinfoReceiveThread receiveThreadRef = receiveThread;\n+            if (receiveThreadRef != null) {\n+                logger.debug(\"receiveThread.isAlive() = {}\", receiveThreadRef.isAlive());\n+            }\n+            if (isInitialized() && (receiveThreadRef == null || !receiveThreadRef.isAlive())) {\n+                updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+                logger.info(\"Try to restart Teleinfo receiving...\");\n+                stopReceivingAndCloseSerialPort();\n+                openSerialPortAndStartReceiving();\n+            }\n+        }, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> keepAliveThreadRef = keepAliveThread;\n+        if (keepAliveThreadRef != null) {\n+            keepAliveThreadRef.cancel(true);\n+            keepAliveThread = null;\n+        }\n+        stopReceivingAndCloseSerialPort();\n+\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void onFrameReceived(TeleinfoReceiveThread receiveThread, Frame frame) {\n+        updateStatus(ThingStatus.ONLINE);\n+        fireOnFrameReceivedEvent(frame);\n+    }\n+\n+    @Override\n+    public void onInvalidFrameReceived(TeleinfoReceiveThread receiveThread, InvalidFrameException error) {\n+        invalidFrameCounter++;\n+        updateState(THING_SERIAL_CONTROLLER_CHANNEL_INVALID_FRAME_COUNTER, new DecimalType(invalidFrameCounter));\n+    }\n+\n+    @Override\n+    public void onSerialPortInputStreamIOException(TeleinfoReceiveThread receiveThread, IOException e) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+    }\n+\n+    @Override\n+    public boolean continueOnReadNextFrameTimeoutException(TeleinfoReceiveThread receiveThread, TimeoutException e) {\n+        logger.warn(\"Retry in progress. Next retry in {} seconds...\", SERIAL_PORT_DELAY_RETRY_IN_SECONDS);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, ERROR_UNKNOWN_RETRY_IN_PROGRESS);\n+        try {\n+            Thread.sleep(SERIAL_PORT_DELAY_RETRY_IN_SECONDS * 1000);\n+            return true;\n+        } catch (InterruptedException e1) {\n+            return false;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjkxMTYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzoxMDo0OVrOHKoBzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwNzo0MDozNFrOHNgWHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMzYyOQ==", "bodyText": "Please implement the registration of the discovery service as a ThingHandlerService. I've a pr on the documentation that explains how to implement it. This is a link to the preview documentation: https://deploy-preview-1262--openhab-docs-preview.netlify.app/docs/developer/bindings/#discovery-that-is-bound-to-a-thing", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r480903629", "createdAt": "2020-09-01T07:10:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgyOTY0OQ==", "bodyText": "@Hilbrand I'm trying to follow the documentation, but the bridge handler is still null when startScan is called. Do I miss something? Have you a working example?\nedit: it seems that the discovery service instance launched by paper ui is not the instance where the bridge handler is set...", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r483829649", "createdAt": "2020-09-04T20:23:40Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMzYyOQ=="}, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2OTcxMw==", "bodyText": "You need to have the 2 interfaces added to the discovery service class as shown in the tutorial.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r483869713", "createdAt": "2020-09-04T22:35:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMzYyOQ=="}, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzkyMzQ4Ng==", "bodyText": "You're right! I forgot to implement DiscoverService.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r483923486", "createdAt": "2020-09-05T07:40:34Z", "author": {"login": "olivierkeke"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        TeleinfoAbstractControllerHandler controller = null;\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            controller = new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+\n+            TeleinfoDiscoveryService discoveryService = new TeleinfoDiscoveryService(controller, 60);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkwMzYyOQ=="}, "originalCommit": {"oid": "8095684a2036e2fad2bd784d4f778b3a7e4e68ab"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNzQ4OTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowMzoyMVrOHNrVhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowMzoyMVrOHNrVhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwMzU1OA==", "bodyText": "This whole method can be removed here as the unregistering of the discovery sevice is handled by the ThingHandlerService now", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r484103558", "createdAt": "2020-09-06T19:03:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Reference\n+    protected void setSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    protected void unsetSerialPortManager(final SerialPortManager serialPortManager) {\n+        this.serialPortManager = null;\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_SERIAL_CONTROLLER.equals(thingTypeUID)) {\n+            return new TeleinfoSerialControllerHandler((Bridge) thing, serialPortManager);\n+        }\n+\n+        if (THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbemmEvoIccElectricityMeterHandler(thing);\n+        } else if (THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoBaseCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoHcCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoTempoCbetmLongElectricityMeterHandler(thing);\n+        } else if (THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID.equals(thing.getThingTypeUID())) {\n+            return new TeleinfoEjpCbetmLongElectricityMeterHandler(thing);\n+        } else {\n+            throw new IllegalStateException(\"Teleinfo frame type not supported: \" + thing.getThingTypeUID());\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"null\")\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "415f354b15ae61eb05629145bdc1f315b5a7b82f"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNzQ5MDAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowMzo0MVrOHNrVnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowMzo0MVrOHNrVnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwMzU4MA==", "bodyText": "This can also be removed. See other comment.", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r484103580", "createdAt": "2020-09-06T19:03:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "415f354b15ae61eb05629145bdc1f315b5a7b82f"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNzQ5MTYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowNTo1NVrOHNrWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxOTowNTo1NVrOHNrWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwMzc3NA==", "bodyText": "One more comment (since you need to modify this file for the other comment). Can you inject the SerialPortManager in the constuctor. The the field can be final and you can remove the set and unset methods::\n@Ativate`\npublic TeleinfoThingHandlerFactory(@Reference SerialPortManager serialPortManager) {\n...", "url": "https://github.com/openhab/openhab-addons/pull/7744#discussion_r484103774", "createdAt": "2020-09-06T19:05:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.teleinfo/src/main/java/org/openhab/binding/teleinfo/internal/handler/TeleinfoThingHandlerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.teleinfo.internal.handler;\n+\n+import static org.openhab.binding.teleinfo.internal.TeleinfoBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.teleinfo.internal.TeleinfoDiscoveryService;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoBaseCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoEjpCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoHcCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.TeleinfoTempoCbemmElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoBaseCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoEjpCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoHcCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbemm.evoicc.TeleinfoTempoCbemmEvoIccElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoBaseCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoEjpCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoHcCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.handler.cbetm.TeleinfoTempoCbetmLongElectricityMeterHandler;\n+import org.openhab.binding.teleinfo.internal.serial.TeleinfoSerialControllerHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TeleinfoThingHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Nicolas SIBERIL - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.teleinfo\", service = ThingHandlerFactory.class)\n+public class TeleinfoThingHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Stream.of(THING_TYPE_SERIAL_CONTROLLER,\n+            THING_HC_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBEMM_EVO_ICC_ELECTRICITY_METER_TYPE_UID,\n+            THING_HC_CBETM_ELECTRICITY_METER_TYPE_UID, THING_BASE_CBETM_ELECTRICITY_METER_TYPE_UID,\n+            THING_TEMPO_CBETM_ELECTRICITY_METER_TYPE_UID, THING_EJP_CBETM_ELECTRICITY_METER_TYPE_UID)\n+            .collect(Collectors.toSet());\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "415f354b15ae61eb05629145bdc1f315b5a7b82f"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 109, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}