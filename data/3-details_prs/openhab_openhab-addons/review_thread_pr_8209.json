{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2ODIwOTc5", "number": 8209, "reviewThreads": {"totalCount": 46, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxMzo1N1rOEeypyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNjozNlrOElNJTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzIyNjMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxMzo1N1rOHKrKtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxMzo1N1rOHKrKtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NTA2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>2.5.8-SNAPSHOT</version>\n          \n          \n            \n                <version>2.5.9-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480955060", "createdAt": "2020-09-01T08:13:57Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/pom.xml", "diffHunk": "@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.8-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzIzMDI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNDo1OFrOHKrNLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNDo1OFrOHKrNLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NTY5NQ==", "bodyText": "This looks like it's not formatted correctly. Can you run mvn spotless:apply on your code.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480955695", "createdAt": "2020-09-01T08:14:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandlerFactory.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link WlanThermoHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.wlanthermo\", service = ThingHandlerFactory.class)\n+public class WlanThermoHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = new HashSet<ThingTypeUID>(Arrays.asList(WlanThermoBindingConstants.THING_TYPE_WLANTHERMO_NANO, WlanThermoBindingConstants.THING_TYPE_WLANTHERMO_MINI));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzIzNTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNjowN1rOHKrQFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNjowN1rOHKrQFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NjQzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @NonNullByDefault({})\n          \n          \n            \n                private String ipAddress;\n          \n          \n            \n                private String ipAddress = \"\";", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480956439", "createdAt": "2020-09-01T08:16:07Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniConfiguration {\n+\n+    /**\n+     * IP Address of WlanThermo.\n+     */\n+    @NonNullByDefault({})\n+    private String ipAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzIzNjUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNjoyOVrOHKrQ1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxNjoyOVrOHKrQ1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NjYyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private String username;\n          \n          \n            \n                private @Nullable String username;", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480956628", "createdAt": "2020-09-01T08:16:29Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniConfiguration {\n+\n+    /**\n+     * IP Address of WlanThermo.\n+     */\n+    @NonNullByDefault({})\n+    private String ipAddress;\n+\n+    /**\n+     * Username of WlanThermo user.\n+     */\n+    @Nullable\n+    private String username;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzI2NjIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoyNDoxN1rOHKri1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzowNzo1NVrOHL46qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA==", "bodyText": "Don't create your own client, but pass the client via the factory with HttpClientFactory and get a client via httpClientFactory.getCommonHttpClient().", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480961238", "createdAt": "2020-09-01T08:24:17Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NDE0Mw==", "bodyText": "Can you give a few more details on that? How do I obtain the HttpClientFactory in the Factory class?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481454143", "createdAt": "2020-09-01T21:55:27Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyODkwNA==", "bodyText": "See some other bindings. Here ia a good example: https://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ojelectronics/src/main/java/org/openhab/binding/ojelectronics/internal/OJCloudHandlerFactory.java", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482228904", "createdAt": "2020-09-02T17:07:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzI2ODU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoyNDo1NVrOHKrkRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzoxMDozMlrOHQ2URA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw==", "bodyText": "Why not use the scheduler from the parent class?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480961607", "createdAt": "2020-09-01T08:24:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NjYxNw==", "bodyText": "I had a lot of problems with RejectedExecutionExceptions, similar to #1078. Implemented is as suggested in that ticket and got no errors since...", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481456617", "createdAt": "2020-09-01T22:01:25Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MDI0Mw==", "bodyText": "I don't  know why you got those errors. But your code doesnt look more complex than the average binding that uses the scheduler without problems. That means i suspect something else might be wrong. What i do see is in the method checkConnection you cancel the pollers in certain conditions. However this method is called from within those scheduled threads, meaning the call to cancle would cancel the thread its running on itself, and that might cause some problems. I would suggest  to have a look at how the flow goes and see if you can improve this and try using the provided scheduler. Or if you still have problems show some loging to see if we can find the cause.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482240243", "createdAt": "2020-09-02T17:22:08Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTE4OA==", "bodyText": "In order to get this in the last 2.5 release, I'd prefer to leave it as it is - running.\nWill conduct some tests later and check if this can be reverted to the common scheduler, ok?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487429188", "createdAt": "2020-09-12T17:10:32Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzI4MzE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoyODozMVrOHKrtLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowNjo1NlrOHQ2TKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2Mzg4NA==", "bodyText": "If you have 2 configurations that are the same than use 1 class.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480963884", "createdAt": "2020-09-01T08:28:31Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoConfiguration.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyODkwNw==", "bodyText": "Configurations are actually different. Removed Copy&Paste errors ;)", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487428907", "createdAt": "2020-09-12T17:06:56Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoConfiguration.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2Mzg4NA=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzI4NzM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoyOTozNVrOHKrv2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNzoyNzowMVrOHL5yJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ==", "bodyText": "If you don't explicitly initialize gson to do something with the Expose annotation you should not annotate fields with Expose. It's then by default exposed.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480964569", "createdAt": "2020-09-01T08:29:35Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODE0Nw==", "bodyText": "The Gson objects are auto-generated from the json-output.\nIf this is not a blocker for you, I'd rather like to keep them as they are. This will allow an easier update of these classes in case of future JSON changes.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481458147", "createdAt": "2020-09-01T22:05:11Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MzEwOQ==", "bodyText": "Ok  no problem, maybe you can document this in the code somewhere and how you generated the files.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482243109", "createdAt": "2020-09-02T17:27:01Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzI5MTgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODozMDo0MVrOHKrygQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjowNTo1MVrOHLJ5AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NTI0OQ==", "bodyText": "If the variable name is the same as the serialized name than serialized name can be omitted. This is also better for readability of the code.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480965249", "createdAt": "2020-09-01T08:30:41Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODQzMg==", "bodyText": "Same as above.\nIf this is not a blocker, I'd like to keep it as auto-generated from the JSON to make future updates more easy.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481458432", "createdAt": "2020-09-01T22:05:51Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NTI0OQ=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzMwNzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODozNDoxOVrOHKr7Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODozNDoxOVrOHKr7Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NzUxMA==", "bodyText": "Remove the element required as it is deprecated. Set it as attibute:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"ipAddress\" type=\"text\">\n          \n          \n            \n            \t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480967510", "createdAt": "2020-09-01T08:34:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzMxNDM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODozNjowNFrOHKr_fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODozNjowNFrOHKr_fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2ODU3NA==", "bodyText": "In the configuration class for the mini it also has a username/password but I don't see them here?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480968574", "createdAt": "2020-09-01T08:36:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"username\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t\t<context>password</context>\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini</label>\n+\t\t<description>WlanThermo Mini</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_mini\" />\n+\t\t\t<channel-group id=\"channel0\" typeId=\"cg_temperature_mini0\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_mini1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_mini2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_mini3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_mini4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_mini5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_mini6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_mini7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_mini8\" />\n+\t\t\t<channel-group id=\"channel9\" typeId=\"cg_temperature_mini9\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_mini1\" />\n+\t\t\t<channel-group id=\"pit2\" typeId=\"cg_pitmaster_mini2\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzMyODY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo0MDowMlrOHKsIUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo0MDowMlrOHKsIUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk3MDgzNA==", "bodyText": "It looks like all these temperature groups are the same. In that case you should only define 1 channel-group-type: cg_temperature_nano. Same for cg_temperature_mini. In the group channel definition you can differentiate the label/description:\n<channel-group id=\"channel0\" typeId=\"cg_temperature_nano1\">\n\t<label>Temperature Probe 1</label>\n\t<description>This group contains all channels for temperature probe 1</description>\n</channel-group>", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480970834", "createdAt": "2020-09-01T08:40:02Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"username\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t\t<context>password</context>\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini</label>\n+\t\t<description>WlanThermo Mini</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_mini\" />\n+\t\t\t<channel-group id=\"channel0\" typeId=\"cg_temperature_mini0\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_mini1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_mini2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_mini3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_mini4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_mini5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_mini6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_mini7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_mini8\" />\n+\t\t\t<channel-group id=\"channel9\" typeId=\"cg_temperature_mini9\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_mini1\" />\n+\t\t\t<channel-group id=\"pit2\" typeId=\"cg_pitmaster_mini2\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- System Group Nano-->\n+\t<channel-group-type id=\"cg_system_nano\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"soc\" typeId=\"system.battery-level\" />\n+\t\t\t<channel id=\"charge\" typeId=\"charging\" />\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\" />\n+\t\t\t<channel id=\"rssi_signalstrength\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"online\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Online</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>RSSI in dBm</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<!-- System Group Mini -->\n+\t<channel-group-type id=\"cg_system_mini\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"cpu_load\" typeId=\"cpu_load\" />\n+\t\t\t<channel id=\"cpu_temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<!-- Temperature Group Nano-->\n+\t<channel-group-type id=\"cg_temperature_nano1\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzMzMzIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo0MToxMVrOHKsLHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo0MToxMVrOHKsLHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk3MTU1MA==", "bodyText": "These number patterns commonly include the unit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<state min=\"0\" pattern=\"%.1f\" readOnly=\"true\" />\n          \n          \n            \n            \t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\" />", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480971550", "createdAt": "2020-09-01T08:41:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"username\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t\t<context>password</context>\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini</label>\n+\t\t<description>WlanThermo Mini</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_mini\" />\n+\t\t\t<channel-group id=\"channel0\" typeId=\"cg_temperature_mini0\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_mini1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_mini2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_mini3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_mini4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_mini5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_mini6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_mini7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_mini8\" />\n+\t\t\t<channel-group id=\"channel9\" typeId=\"cg_temperature_mini9\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_mini1\" />\n+\t\t\t<channel-group id=\"pit2\" typeId=\"cg_pitmaster_mini2\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- System Group Nano-->\n+\t<channel-group-type id=\"cg_system_nano\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"soc\" typeId=\"system.battery-level\" />\n+\t\t\t<channel id=\"charge\" typeId=\"charging\" />\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\" />\n+\t\t\t<channel id=\"rssi_signalstrength\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"online\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Online</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>RSSI in dBm</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<!-- System Group Mini -->\n+\t<channel-group-type id=\"cg_system_mini\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"cpu_load\" typeId=\"cpu_load\" />\n+\t\t\t<channel id=\"cpu_temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<!-- Temperature Group Nano-->\n+\t<channel-group-type id=\"cg_temperature_nano1\">\n+\t\t<label>Temperature Probe 1</label>\n+\t\t<description>This group contains all channels for temperature probe 1</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano2\">\n+\t\t<label>Temperature Probe 2</label>\n+\t\t<description>This group contains all channels for temperature probe 2</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano3\">\n+\t\t<label>Temperature Probe 3</label>\n+\t\t<description>This group contains all channels for temperature probe 3</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano4\">\n+\t\t<label>Temperature Probe 4</label>\n+\t\t<description>This group contains all channels for temperature probe 4</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano5\">\n+\t\t<label>Temperature Probe 5</label>\n+\t\t<description>This group contains all channels for temperature probe 5</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano6\">\n+\t\t<label>Temperature Probe 6</label>\n+\t\t<description>This group contains all channels for temperature probe 6</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano7\">\n+\t\t<label>Temperature Probe 7</label>\n+\t\t<description>This group contains all channels for temperature probe 7</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_nano8\">\n+\t\t<label>Temperature Probe 8</label>\n+\t\t<description>This group contains all channels for temperature probe 8</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"typ\" typeId=\"typ\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device\" />\n+\t\t\t<channel id=\"alarm_push\" typeId=\"alarm_push\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!-- Channel Group Temperature Mini-->\n+\t<channel-group-type id=\"cg_temperature_mini0\">\n+\t\t<label>Temperature Probe 0</label>\n+\t\t<description>This group contains all channels for temperature probe 0</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini1\">\n+\t\t<label>Temperature Probe 1</label>\n+\t\t<description>This group contains all channels for temperature probe 1</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini2\">\n+\t\t<label>Temperature Probe 2</label>\n+\t\t<description>This group contains all channels for temperature probe 2</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini3\">\n+\t\t<label>Temperature Probe 3</label>\n+\t\t<description>This group contains all channels for temperature probe 3</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini4\">\n+\t\t<label>Temperature Probe 4</label>\n+\t\t<description>This group contains all channels for temperature probe 4</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini5\">\n+\t\t<label>Temperature Probe 5</label>\n+\t\t<description>This group contains all channels for temperature probe 5</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini6\">\n+\t\t<label>Temperature Probe 6</label>\n+\t\t<description>This group contains all channels for temperature probe 6</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini7\">\n+\t\t<label>Temperature Probe 7</label>\n+\t\t<description>This group contains all channels for temperature probe 7</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini8\">\n+\t\t<label>Temperature Probe 8</label>\n+\t\t<description>This group contains all channels for temperature probe 8</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<channel-group-type id=\"cg_temperature_mini9\">\n+\t\t<label>Temperature Probe 9</label>\n+\t\t<description>This group contains all channels for temperature probe 9</description>\n+\t\t<category>Sensor</category>\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name_ro\" />\n+\t\t\t<channel id=\"temp\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"min\" typeId=\"temperature_min_ro\" />\n+\t\t\t<channel id=\"max\" typeId=\"temperature_max_ro\" />\n+\t\t\t<channel id=\"alarm_device\" typeId=\"alarm_device_ro\" />\n+\t\t\t<channel id=\"alarm_openhab\" typeId=\"alarm_openhab\" />\n+\t\t\t<channel id=\"alarm_openhab_low\" typeId=\"alarm_openhab_low\" />\n+\t\t\t<channel id=\"alarm_openhab_high\" typeId=\"alarm_openhab_high\" />\n+\t\t\t<channel id=\"color\" typeId=\"color_ro\" />\n+\t\t\t<channel id=\"color_name\" typeId=\"color_name_ro\" />\n+\t\t</channels>\n+\t</channel-group-type>\n+\n+\t<!-- Fundamental channel types -->\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f\" readOnly=\"true\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 509}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA2Njg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMToxM1rOHLGfzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxMToxM1rOHLGfzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjgzMQ==", "bodyText": "Is this Exception thrown? otherwise you should catch the specific exception.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481402831", "createdAt": "2020-09-01T20:11:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA5MDUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODowMVrOHLGtpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODowMVrOHLGtpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjM3NA==", "bodyText": "Only log to error is this is a serious bug. This looks more like a user error and should probably be a warn or info log.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406374", "createdAt": "2020-09-01T20:18:01Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA5MjMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODozNFrOHLGuxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODozNFrOHLGuxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjY2MA==", "bodyText": "lots of empty lines in this area.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406660", "createdAt": "2020-09-01T20:18:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA5MzQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODo1OVrOHLGveQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoxODo1OVrOHLGveQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjg0MQ==", "bodyText": "Is this exception thrown? or can you make it the specific eception?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406841", "createdAt": "2020-09-01T20:18:59Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDA5ODY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMDoyNlrOHLGybA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMDoyNlrOHLGybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNzU5Ng==", "bodyText": "This should probably be shown to the user in the thing status. In general the user should not have to look into the log to find out what the problem is. If you set the status this log can be reduced to debug.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481407596", "createdAt": "2020-09-01T20:20:26Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEwMTEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMTowOVrOHLGz7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMTowOVrOHLGz7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNzk4MQ==", "bodyText": "Same comment here as aboce regarding settting status/ log level usage.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481407981", "createdAt": "2020-09-01T20:21:09Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEwMTUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMToxOVrOHLG0Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyMToxOVrOHLG0Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwODA1OA==", "bodyText": "Same comment here as aboce regarding settting status/ log level usage.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481408058", "createdAt": "2020-09-01T20:21:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDExNTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNToxMVrOHLG8OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowNzo1OFrOHQ2Teg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDEwNA==", "bodyText": "In general the thing status should represent the online status of the device and not a separate channel. Is there a reason to have separate channel other than a channel can be handled easier?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481410104", "createdAt": "2020-09-01T20:25:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"username\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t\t<context>password</context>\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini</label>\n+\t\t<description>WlanThermo Mini</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_mini\" />\n+\t\t\t<channel-group id=\"channel0\" typeId=\"cg_temperature_mini0\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_mini1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_mini2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_mini3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_mini4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_mini5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_mini6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_mini7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_mini8\" />\n+\t\t\t<channel-group id=\"channel9\" typeId=\"cg_temperature_mini9\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_mini1\" />\n+\t\t\t<channel-group id=\"pit2\" typeId=\"cg_pitmaster_mini2\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- System Group Nano-->\n+\t<channel-group-type id=\"cg_system_nano\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"soc\" typeId=\"system.battery-level\" />\n+\t\t\t<channel id=\"charge\" typeId=\"charging\" />\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\" />\n+\t\t\t<channel id=\"rssi_signalstrength\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyODk4Ng==", "bodyText": "It was requested by users of the binding in order to have a conditional view, e.g. in Basic UI", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487428986", "createdAt": "2020-09-12T17:07:58Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,735 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"nano\">\n+\t\t<label>WlanThermo Nano</label>\n+\t\t<description>WlanThermo Nano V1/V1+</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_nano\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_nano1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_nano2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_nano3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_nano4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_nano5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_nano6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_nano7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_nano8\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_nano1\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"username\" type=\"text\">\n+\t\t\t\t<label>Username</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">\n+\t\t\t\t<context>password</context>\n+\t\t\t\t<label>Password</label>\n+\t\t\t\t<description>Optional, only required for write access. Default: 'admin'</description>\n+\t\t\t\t<required>false</required>\n+\t\t\t\t<default>admin</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini</label>\n+\t\t<description>WlanThermo Mini</description>\n+\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"system\" typeId=\"cg_system_mini\" />\n+\t\t\t<channel-group id=\"channel0\" typeId=\"cg_temperature_mini0\" />\n+\t\t\t<channel-group id=\"channel1\" typeId=\"cg_temperature_mini1\" />\n+\t\t\t<channel-group id=\"channel2\" typeId=\"cg_temperature_mini2\" />\n+\t\t\t<channel-group id=\"channel3\" typeId=\"cg_temperature_mini3\" />\n+\t\t\t<channel-group id=\"channel4\" typeId=\"cg_temperature_mini4\" />\n+\t\t\t<channel-group id=\"channel5\" typeId=\"cg_temperature_mini5\" />\n+\t\t\t<channel-group id=\"channel6\" typeId=\"cg_temperature_mini6\" />\n+\t\t\t<channel-group id=\"channel7\" typeId=\"cg_temperature_mini7\" />\n+\t\t\t<channel-group id=\"channel8\" typeId=\"cg_temperature_mini8\" />\n+\t\t\t<channel-group id=\"channel9\" typeId=\"cg_temperature_mini9\" />\n+\t\t\t<channel-group id=\"pit1\" typeId=\"cg_pitmaster_mini1\" />\n+\t\t\t<channel-group id=\"pit2\" typeId=\"cg_pitmaster_mini2\" />\n+\t\t</channel-groups>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Network Address</label>\n+\t\t\t\t<description>Network address of the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"1\" step=\"1\" unit=\"s\">\n+\t\t\t\t<label>Polling Interval</label>\n+\t\t\t\t<description>Seconds between fetching values from the WlanThermo.</description>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- System Group Nano-->\n+\t<channel-group-type id=\"cg_system_nano\">\n+\t\t<label>System Channel</label>\n+\t\t<description>This group contains all system channels</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"soc\" typeId=\"system.battery-level\" />\n+\t\t\t<channel id=\"charge\" typeId=\"charging\" />\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\" />\n+\t\t\t<channel id=\"rssi_signalstrength\" typeId=\"system.signal-strength\" />\n+\t\t\t<channel id=\"online\" typeId=\"online\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDEwNA=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDExNzgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNTo1OFrOHLG9rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNTo1OFrOHLG9rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDQ3OQ==", "bodyText": "No need to set status in dispose the framework takes care of this.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481410479", "createdAt": "2020-09-01T20:25:58Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        } \n+        updateStatus(ThingStatus.REMOVED);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }\n+        for (Channel channel : thing.getChannels()) {\n+            if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                updateState(channel.getUID(), OnOffType.OFF);\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDExOTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNjoyMlrOHLG-ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNjoyMlrOHLG-ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDY4Mw==", "bodyText": "In dispose you should not set channel states.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481410683", "createdAt": "2020-09-01T20:26:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        } \n+        updateStatus(ThingStatus.REMOVED);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }\n+        for (Channel channel : thing.getChannels()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEyMTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNzoxMFrOHLHAMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyNzoxMFrOHLHAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMTEyMg==", "bodyText": "Remove this implementation. It is handled by the dispose method.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481411122", "createdAt": "2020-09-01T20:27:10Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEyNTUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyODoxOFrOHLHCaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDoyODoxOFrOHLHCaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMTY4OA==", "bodyText": "This error should be reflected in the thing status and log to debug.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481411688", "createdAt": "2020-09-01T20:28:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEzMjYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMDoyNFrOHLHGqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowOToxNFrOHQ2TzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjc3OA==", "bodyText": "Almost all comments regarding WlanThermoNanoHandler also apply here. Maybe you can make a shared parent class to have the shared code in 1 place.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481412778", "createdAt": "2020-09-01T20:30:24Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTA2OA==", "bodyText": "As the underlying API and data objects differ, the common code is in fact quite small. As some methods have been removed, it became even smaller.\nLeft it with 2 independent handlers.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487429068", "createdAt": "2020-09-12T17:09:14Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjc3OA=="}, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEzNTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMToxOFrOHLHIRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMToxOFrOHLHIRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMzE5MQ==", "bodyText": "Can you format the tables. You can use http://markdowntable.com/", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481413191", "createdAt": "2020-09-01T20:31:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/README.md", "diffHunk": "@@ -0,0 +1,534 @@\n+# WlanThermo Binding\n+\n+This binding add support for the WlanThermo BBQ Thermometer.  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDEzNzY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMjowNFrOHLHJyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMDozMjowNFrOHLHJyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMzU3OQ==", "bodyText": "Please put each sentence on a single line. That makes reviewing changes more easy.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481413579", "createdAt": "2020-09-01T20:32:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/README.md", "diffHunk": "@@ -0,0 +1,534 @@\n+# WlanThermo Binding\n+\n+This binding add support for the WlanThermo BBQ Thermometer.  \n+| Nano | Mini |\n+|---|---|\n+| ![WlanThermo Nano V1+](doc/nano.jpg) | ![WlanThermo Mini V2](doc/mini.jpg)\n+\n+## Supported Things\n+\n+This binding supports the following version of WlanThermo:\n+\n+ - Nano V1 (untested, but should be working)\n+ - Nano V1+\n+ - Mini V1 (untested, but should be working)\n+ - Mini V2\n+\n+ Pitmaster support is currently only enabled for Mini V1/V2.  \n+ If you have a WlanThermo Nano with Pitmaster, please contact the author of this binding to include the support in future releases.\n+\n+## Discovery\n+\n+There is no auto-discovery of WlanThermo Things. \n+Things must be created manually, e.g. via PaperUI.\n+\n+## Thing Configuration\n+\n+WlanThermo things require you to specify the IP-address of your WlanThermo device (the one you enter into your browser to access the WebUI)\n+The configuration of username/password is optional. If ommitted, the binding data will be read-only for all channels. WlanThermo Mini things do not require a username/password and will always be read-only!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aaf5c2e7048246293a24c2ab1dff59cee289f274"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTkxMDY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/UtilNano.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowMzowMFrOHRMsNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowMzowMFrOHRMsNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5NTc2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Map<String, String> colorMappings = createColorMap();\n          \n          \n            \n                private static final Map<String, String> COLOR_MAPPINGS = createColorMap();", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487795766", "createdAt": "2020-09-14T10:03:00Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/UtilNano.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilNano} class provides conversion functions for the WlanThermo Nano\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilNano {\n+\n+    private static final Map<String, String> colorMappings = createColorMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTkyODI0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/Channel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowNzozNFrOHRM2dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowNzozNFrOHRM2dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5ODM5MQ==", "bodyText": "Can you remove the package here?", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487798391", "createdAt": "2020-09-14T10:07:34Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/Channel.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {\n+\n+    @SerializedName(\"0\")\n+    @Expose\n+    private org.openhab.binding.wlanthermo.internal.api.mini.builtin.Data _0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTkzMDk2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/UtilMini.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowODoxOVrOHRM4Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDowODoxOVrOHRM4Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5ODc5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Map<String, String> colorMappings = createColorMap();\n          \n          \n            \n                private static final Map<String, String> COLOR_MAPPINGS = createColorMap();", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487798798", "createdAt": "2020-09-14T10:08:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/UtilMini.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilMini} class provides conversion functions for the WlanThermo Mini\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilMini {\n+    private static final Map<String, String> colorMappings = createColorMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTkzOTI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxMDoyNlrOHRM9BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOTozOTowOFrOHUZqhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMDA2OQ==", "bodyText": "I assume these methods are not auto generated. It might be better to move them out of this class to keep this generated code as much as possible as was generated. Just a suggestion.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487800069", "createdAt": "2020-09-14T10:10:26Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ * Be careful to not overwrite the getState/getTrigger function mapping the Data to OH channels!\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")\n+    @Expose\n+    private Pit pit;\n+    @SerializedName(\"pit2\")\n+    @Expose\n+    private Pit pit2;\n+    @SerializedName(\"cpu_load\")\n+    @Expose\n+    private Double cpuLoad;\n+    @SerializedName(\"cpu_temp\")\n+    @Expose\n+    private Double cpuTemp;\n+    @SerializedName(\"channel\")\n+    @Expose\n+    private Channel channel;\n+    @SerializedName(\"timestamp\")\n+    @Expose\n+    private String timestamp;\n+\n+    /**\n+     * No args constructor for use in serialization\n+     * \n+     */\n+    public App() {\n+    }\n+\n+    /**\n+     * \n+     * @param cpuLoad\n+     * @param pit2\n+     * @param tempUnit\n+     * @param channel\n+     * @param pit\n+     * @param cpuTemp\n+     * @param timestamp\n+     */\n+    public App(String tempUnit, Pit pit, Pit pit2, Double cpuLoad, Double cpuTemp, Channel channel, String timestamp) {\n+        super();\n+        this.tempUnit = tempUnit;\n+        this.pit = pit;\n+        this.pit2 = pit2;\n+        this.cpuLoad = cpuLoad;\n+        this.cpuTemp = cpuTemp;\n+        this.channel = channel;\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getTempUnit() {\n+        return tempUnit;\n+    }\n+\n+    public void setTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+    }\n+\n+    public App withTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+        return this;\n+    }\n+\n+    public Pit getPit() {\n+        return pit;\n+    }\n+\n+    public void setPit(Pit pit) {\n+        this.pit = pit;\n+    }\n+\n+    public App withPit(Pit pit) {\n+        this.pit = pit;\n+        return this;\n+    }\n+\n+    public Pit getPit2() {\n+        return pit2;\n+    }\n+\n+    public void setPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+    }\n+\n+    public App withPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+        return this;\n+    }\n+\n+    public Double getCpuLoad() {\n+        return cpuLoad;\n+    }\n+\n+    public void setCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+    }\n+\n+    public App withCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+        return this;\n+    }\n+\n+    public Double getCpuTemp() {\n+        return cpuTemp;\n+    }\n+\n+    public void setCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+    }\n+\n+    public App withCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+        return this;\n+    }\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    public void setChannel(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public App withChannel(Channel channel) {\n+        this.channel = channel;\n+        return this;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public App withTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+        return this;\n+    }\n+\n+    public State getState(ChannelUID channelUID, WlanThermoMiniHandler wlanThermoHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1NDA1Mw==", "bodyText": "Done. Command Handling has been moved to a dedicated class instead.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491154053", "createdAt": "2020-09-18T19:39:08Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ * Be careful to not overwrite the getState/getTrigger function mapping the Data to OH channels!\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")\n+    @Expose\n+    private Pit pit;\n+    @SerializedName(\"pit2\")\n+    @Expose\n+    private Pit pit2;\n+    @SerializedName(\"cpu_load\")\n+    @Expose\n+    private Double cpuLoad;\n+    @SerializedName(\"cpu_temp\")\n+    @Expose\n+    private Double cpuTemp;\n+    @SerializedName(\"channel\")\n+    @Expose\n+    private Channel channel;\n+    @SerializedName(\"timestamp\")\n+    @Expose\n+    private String timestamp;\n+\n+    /**\n+     * No args constructor for use in serialization\n+     * \n+     */\n+    public App() {\n+    }\n+\n+    /**\n+     * \n+     * @param cpuLoad\n+     * @param pit2\n+     * @param tempUnit\n+     * @param channel\n+     * @param pit\n+     * @param cpuTemp\n+     * @param timestamp\n+     */\n+    public App(String tempUnit, Pit pit, Pit pit2, Double cpuLoad, Double cpuTemp, Channel channel, String timestamp) {\n+        super();\n+        this.tempUnit = tempUnit;\n+        this.pit = pit;\n+        this.pit2 = pit2;\n+        this.cpuLoad = cpuLoad;\n+        this.cpuTemp = cpuTemp;\n+        this.channel = channel;\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getTempUnit() {\n+        return tempUnit;\n+    }\n+\n+    public void setTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+    }\n+\n+    public App withTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+        return this;\n+    }\n+\n+    public Pit getPit() {\n+        return pit;\n+    }\n+\n+    public void setPit(Pit pit) {\n+        this.pit = pit;\n+    }\n+\n+    public App withPit(Pit pit) {\n+        this.pit = pit;\n+        return this;\n+    }\n+\n+    public Pit getPit2() {\n+        return pit2;\n+    }\n+\n+    public void setPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+    }\n+\n+    public App withPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+        return this;\n+    }\n+\n+    public Double getCpuLoad() {\n+        return cpuLoad;\n+    }\n+\n+    public void setCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+    }\n+\n+    public App withCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+        return this;\n+    }\n+\n+    public Double getCpuTemp() {\n+        return cpuTemp;\n+    }\n+\n+    public void setCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+    }\n+\n+    public App withCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+        return this;\n+    }\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    public void setChannel(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public App withChannel(Channel channel) {\n+        this.channel = channel;\n+        return this;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public App withTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+        return this;\n+    }\n+\n+    public State getState(ChannelUID channelUID, WlanThermoMiniHandler wlanThermoHandler) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMDA2OQ=="}, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk1NTEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNDozMVrOHRNGWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNDozMVrOHRNGWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjQ1Ng==", "bodyText": "You should not call start on the common client. Remove this code.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802456", "createdAt": "2020-09-14T10:14:31Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk1NjU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNDo1NVrOHRNHLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNDo1NVrOHRNHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjY2OA==", "bodyText": "When you remove the start call you can also remove this exception catch.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802668", "createdAt": "2020-09-14T10:14:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk1ODAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNToxOVrOHRNICA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNToxOVrOHRNICA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjg4OA==", "bodyText": "Remove this part. You should not call stop on the common client.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802888", "createdAt": "2020-09-14T10:15:19Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Mini!\");\n+            logger.debug(\"Failed to initialize WlanThermo Mini!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri(\"/app.php\")).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = app.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        }\n+        // Mini is read only!\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/app.php\")).getContentAsString();\n+            app = gson.fromJson(json, App.class);\n+            logger.debug(\"Received at /app.php: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = app.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    String trigger = app.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk2MDYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNTo1NVrOHRNJlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNTo1NVrOHRNJlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMzI4NA==", "bodyText": "Same comment here about start", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487803284", "createdAt": "2020-09-14T10:15:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk2MTc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNjoxOFrOHRNKTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNjoxOFrOHRNKTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMzQ3MA==", "bodyText": "Same comment here about exception catching related to start removal.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487803470", "createdAt": "2020-09-14T10:16:18Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTk2NTU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNzoyMFrOHRNMmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMDoxNzoyMFrOHRNMmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwNDA1OA==", "bodyText": "Remove this part. You should not call stop on the common client.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487804058", "createdAt": "2020-09-14T10:17:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.warn(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status,\n+                            uri.toString());\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device!\");\n+                logger.warn(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjE3NTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMToxOToyMVrOHRPKCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMToxOToyMVrOHRPKCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNjE3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channelUID.getId().startsWith(\"system#\")) {\n          \n          \n            \n                    if (\"system\".equals(channelUID.getGroupId())) {", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487836171", "createdAt": "2020-09-14T11:19:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ * Be careful to not overwrite the getState/getTrigger function mapping the Data to OH channels!\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")\n+    @Expose\n+    private Pit pit;\n+    @SerializedName(\"pit2\")\n+    @Expose\n+    private Pit pit2;\n+    @SerializedName(\"cpu_load\")\n+    @Expose\n+    private Double cpuLoad;\n+    @SerializedName(\"cpu_temp\")\n+    @Expose\n+    private Double cpuTemp;\n+    @SerializedName(\"channel\")\n+    @Expose\n+    private Channel channel;\n+    @SerializedName(\"timestamp\")\n+    @Expose\n+    private String timestamp;\n+\n+    /**\n+     * No args constructor for use in serialization\n+     * \n+     */\n+    public App() {\n+    }\n+\n+    /**\n+     * \n+     * @param cpuLoad\n+     * @param pit2\n+     * @param tempUnit\n+     * @param channel\n+     * @param pit\n+     * @param cpuTemp\n+     * @param timestamp\n+     */\n+    public App(String tempUnit, Pit pit, Pit pit2, Double cpuLoad, Double cpuTemp, Channel channel, String timestamp) {\n+        super();\n+        this.tempUnit = tempUnit;\n+        this.pit = pit;\n+        this.pit2 = pit2;\n+        this.cpuLoad = cpuLoad;\n+        this.cpuTemp = cpuTemp;\n+        this.channel = channel;\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getTempUnit() {\n+        return tempUnit;\n+    }\n+\n+    public void setTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+    }\n+\n+    public App withTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+        return this;\n+    }\n+\n+    public Pit getPit() {\n+        return pit;\n+    }\n+\n+    public void setPit(Pit pit) {\n+        this.pit = pit;\n+    }\n+\n+    public App withPit(Pit pit) {\n+        this.pit = pit;\n+        return this;\n+    }\n+\n+    public Pit getPit2() {\n+        return pit2;\n+    }\n+\n+    public void setPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+    }\n+\n+    public App withPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+        return this;\n+    }\n+\n+    public Double getCpuLoad() {\n+        return cpuLoad;\n+    }\n+\n+    public void setCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+    }\n+\n+    public App withCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+        return this;\n+    }\n+\n+    public Double getCpuTemp() {\n+        return cpuTemp;\n+    }\n+\n+    public void setCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+    }\n+\n+    public App withCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+        return this;\n+    }\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    public void setChannel(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public App withChannel(Channel channel) {\n+        this.channel = channel;\n+        return this;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public App withTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+        return this;\n+    }\n+\n+    public State getState(ChannelUID channelUID, WlanThermoMiniHandler wlanThermoHandler) {\n+        State state = null;\n+        if (channelUID.getId().startsWith(\"system#\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTQ2MTgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMDo1MTozNlrOHUH_4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOTozODowMVrOHUZo7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NDYxMA==", "bodyText": "When having a configuration error you should set the state to OFFLINE.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r490864610", "createdAt": "2020-09-18T10:51:36Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzY0NA==", "bodyText": "Removed Exception block anyways", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491153644", "createdAt": "2020-09-18T19:38:01Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NDYxMA=="}, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MTQ4MTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMDo1Njo1NlrOHUIK1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOTozNzo0M1rOHUZoaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NzQxNA==", "bodyText": "It you have an InterruptedException it means this thread should stop and you should probably not reschedule anything.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r490867414", "createdAt": "2020-09-18T10:56:56Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzUxMg==", "bodyText": "The update-thread may get interrupted, but the reconnect-thread gets scheduled than. Looks fine for me...", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491153512", "createdAt": "2020-09-18T19:37:43Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NzQxNA=="}, "originalCommit": {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDI4MzEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwNjo0ODoyMVrOHUiXDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNToxOVrOHUkXzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI5NjUyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491296525", "createdAt": "2020-09-19T06:48:21Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTQ4Nw==", "bodyText": "Sorry, missed that one...", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329487", "createdAt": "2020-09-19T08:25:19Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI5NjUyNQ=="}, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDQzNDIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODowMzowM1rOHUj6cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwOTowMDowNlrOHUk_-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMTk2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (pollingScheduler != null) {\n          \n          \n            \n                                pollingScheduler.cancel(false);\n          \n          \n            \n                            }\n          \n          \n            \n                            ScheduledFuture<?> oldScheduler = pollingScheduler;\n          \n          \n            \n                            if (oldScheduler != null) {\n          \n          \n            \n                                oldScheduler.cancel(false);\n          \n          \n            \n                            }\n          \n      \n    \n    \n  \n\nThis should fix\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java:[76,2910] Potential null pointer access: this expression has a '@Nullable' type\n\nAlso applies below in l. 88-90, l. 129-131 and l.141.143. In case you do not immediately re-init the scheduler, set the pollingScheduler = null;. Probably also in the other handler.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491321968", "createdAt": "2020-09-19T08:03:03Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.WlanThermoMiniCommandHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+    private final WlanThermoMiniCommandHandler wlanThermoMiniCommandHandler = new WlanThermoMiniCommandHandler();\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+        logger.debug(\"Finished initializing WlanThermo Mini!\");\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri(\"/app.php\")).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(false);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzOTc3MQ==", "bodyText": "That indeed removed the warning. Changed it!", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491339771", "createdAt": "2020-09-19T09:00:06Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.WlanThermoMiniCommandHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+    private final WlanThermoMiniCommandHandler wlanThermoMiniCommandHandler = new WlanThermoMiniCommandHandler();\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+        logger.debug(\"Finished initializing WlanThermo Mini!\");\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri(\"/app.php\")).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(false);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMTk2OA=="}, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDQ3ODIzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNDo1MVrOHUkXKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwOTowMDoyNlrOHUlAYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTMyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n          \n          \n            \n                   data.getChannel().forEach(c -> {\n          \n      \n    \n    \n  \n\nAlso removes the necessity for the fully qualified class name.", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329322", "createdAt": "2020-09-19T08:24:51Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzOTg3NQ==", "bodyText": "Like that, done!", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491339875", "createdAt": "2020-09-19T09:00:26Z", "author": {"login": "CSchlipp"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTMyMg=="}, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDQ4MDQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNTo1NlrOHUkYlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNTo1NlrOHUkYlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTY4NA==", "bodyText": "Not needed, thing status changes are logged anyway, If you want to log something, maybe log the content response at TRACE or DEBUG level (if it adds useful information),", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329684", "createdAt": "2020-09-19T08:25:56Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3NDQ4MTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNjozNlrOHUkZLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwODoyNjozNlrOHUkZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTgzOA==", "bodyText": "See above, thing status changes are always logged. You could reduce the exception stack trace to DEBUG or TRACE", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329838", "createdAt": "2020-09-19T08:26:36Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.warn(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status,\n+                            uri.toString());\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device!\");\n+                logger.warn(\"Failed to update channel {} on device\", c.getName(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b"}, "originalPosition": 191}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4525, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}