{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNTMzMDQ2", "number": 7189, "title": "[alarmdecoder] Initial contribution", "bodyText": "This PR is for a new OH2 version of the OH1 alarmdecoder binding. It has been developed jointly with @billfor.\nThe original OH1 version of this binding was contributed by @berndpfrommer. A significant amount of code has been retained from the original binding, although it may not be immediately obvious due to the extensive changes and restructuring required to fit the OH2 binding model and to meet current code requirements.\nThe binding is fully functional, but has been through only limited testing.\nCloses #7081", "createdAt": "2020-03-18T16:16:21Z", "url": "https://github.com/openhab/openhab-addons/pull/7189", "merged": true, "mergeCommit": {"oid": "36491aa344afa914a79da37f99feaa47de6ae500"}, "closed": true, "closedAt": "2020-04-30T08:34:03Z", "author": {"login": "bobadair"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRNOVWgH2gAyMzkwNTMzMDQ2OmJkYTdmMjdhYzllMDZjMzIzMmVkMDZhNGQ0NjIzZDBlMDZlNDk5NzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcca6uNAFqTQwMjgyNzg4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/bda7f27ac9e06c3232ed06a4d4623d0e06e49975", "committedDate": "2020-03-25T20:07:13Z", "message": "[alarmdecoder] Initial commit of OH2 version\n\nSigned-off-by: Bob Adair <bob.github@att.net>\nAlso-by: Bill Forsyth (github: billfor)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "526f16ff6353858040787e3b376fa6d5cd20c2ca", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/526f16ff6353858040787e3b376fa6d5cd20c2ca", "committedDate": "2020-03-25T20:07:13Z", "message": "[alarmdecoder] Update pom.xml files\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "committedDate": "2020-03-25T20:07:13Z", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c288ca19dedbd4ebbfddb7cea8961d116e375cef", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/c288ca19dedbd4ebbfddb7cea8961d116e375cef", "committedDate": "2020-03-18T18:01:55Z", "message": "[alarmdecoder] Update pom.xml files\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}, "afterCommit": {"oid": "bd2338a2a253257adeb8764a478430959d53cd16", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/bd2338a2a253257adeb8764a478430959d53cd16", "committedDate": "2020-03-25T20:07:13Z", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/c0e92a4a86be44bdc06a397c9057f3d3d7983f8b", "committedDate": "2020-03-29T17:29:08Z", "message": "[alarmdecoder] Update to LRR msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c376c907d7f913bebbeb0d14d1574c6928bc9337", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/c376c907d7f913bebbeb0d14d1574c6928bc9337", "committedDate": "2020-03-31T20:08:28Z", "message": "[alarmdecoder] Update to KP msg parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/f97e80b5dcb7e7977ca7f9e3a4f6cf0517b333a7", "committedDate": "2020-04-04T22:13:44Z", "message": "[alarmdecoder] Don't update keypad channels on repeated messages\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d72a334168728bd56c07aa1e928e58fa4d6c493", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/1d72a334168728bd56c07aa1e928e58fa4d6c493", "committedDate": "2020-04-08T02:15:56Z", "message": "[alarmdecoder] Update to README and thing-type.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e9b18163906e36ac88e1caea8ce58e9933bd904", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/7e9b18163906e36ac88e1caea8ce58e9933bd904", "committedDate": "2020-04-09T15:33:30Z", "message": "[alarmdecoder] Minor clean-up\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99c6bb2b3edce8a2534d0d694d6c44daece8a175", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/99c6bb2b3edce8a2534d0d694d6c44daece8a175", "committedDate": "2020-04-09T16:00:26Z", "message": "[alarmdecoder] Move off of gnu.io for serial bridge\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/79bce4d41c750de5b53188bb8694c9a7dfd3af25", "committedDate": "2020-04-10T18:21:20Z", "message": "[alarmdecoder] Flag write exceptions\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzM3OTU1", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-391737955", "createdAt": "2020-04-11T05:26:11Z", "commit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNToyNjoxMVrOGEKjug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNjozODo0M1rOGEK56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMDQ3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              <name>openHAB Add-ons :: Bundles :: alarmdecoder Binding</name>\n          \n          \n            \n              <name>openHAB Add-ons :: Bundles :: Alarmdecoder Binding</name>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407020474", "createdAt": "2020-04-11T05:26:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/pom.xml", "diffHunk": "@@ -0,0 +1,16 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.4-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.alarmdecoder</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: alarmdecoder Binding</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n          \n          \n            \n                protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022327", "createdAt": "2020-04-11T05:50:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjMzOA==", "bodyText": "use it or lose it", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022338", "createdAt": "2020-04-11T05:50:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected abstract void initDeviceState();\n+\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE\n+                && getThing().getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE) {\n+            initDeviceState();\n+\n+        } else if (bridgeStatusInfo.getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+            // thingOfflineNotify();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMjU0Mw==", "bodyText": "Why do you need these fields if you can just pull them from the config instance?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407022543", "createdAt": "2020-04-11T05:52:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzA0Ng==", "bodyText": "Why not just put this logic on line 92 so you can do away with the connectionSuccess variable?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023046", "createdAt": "2020-04-11T05:59:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    /** hostname for the alarmdecoder process */\n+    private @Nullable String tcpHostName = null;\n+    /** port for the alarmdecoder process */\n+    private int tcpPort;\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+        tcpHostName = config.hostname;\n+        tcpPort = config.tcpPort;\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        boolean connectionSuccess = false;\n+\n+        try {\n+            disconnect(); // make sure we are disconnected\n+            writeException = false;\n+            if (tcpHostName != null && tcpPort > 0 && tcpPort < 65536) {\n+                socket = new Socket(tcpHostName, tcpPort);\n+                reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n+                logger.debug(\"connected to {}:{}\", tcpHostName, tcpPort);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+                connectionSuccess = true;\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"invalid hostname/tcpPort configured\");\n+            }\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", tcpHostName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", tcpHostName, tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+\n+        // Start connection check job\n+        if (connectionSuccess) {\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzIyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023225", "createdAt": "2020-04-11T06:01:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private @NonNullByDefault({}) KeypadConfig config;\n+    private boolean singleAddress;\n+    private Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyMzc3NQ==", "bodyText": "You still need to handle a RefreshType command if possible.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407023775", "createdAt": "2020-04-11T06:09:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/LRRHandler.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.LRRConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LRRHandler} is responsible for handling long range radio (LRR) messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(LRRHandler.class);\n+\n+    private @NonNullByDefault({}) LRRConfig config;\n+\n+    public LRRHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the supplied partition.\n+     * This is true is this handler's partition is 0 (all), the supplied partition is 0 (all), or if this handler's\n+     * partition matches the supplied partition.\n+     */\n+    public Boolean responsibleFor(final int partition) {\n+        return (config.partition == partition || config.partition == 0 || partition == 0);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(LRRConfig.class);\n+\n+        if (config.partition < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"LRR handler initializing for partition {}\", config.partition);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"LRR handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RLL partition {}\", config.partition);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            updateStatus(ThingStatus.ONLINE);\n+            initChannelState();\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // All channels are read-only, so ignore all commands.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE0Mg==", "bodyText": "you can remove this annotation, it serves no purpose here", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024142", "createdAt": "2020-04-11T06:13:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDE5Ng==", "bodyText": "not even a refresh command?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024196", "createdAt": "2020-04-11T06:14:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/RFZoneHandler.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.RFZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RFZoneHandler} is responsible for handling wired zones (i.e. RFX messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(RFZoneHandler.class);\n+\n+    private @NonNullByDefault({}) RFZoneConfig config;\n+\n+    public RFZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int serial) {\n+        return (config.serial != null && config.serial.equals(serial));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RFZoneConfig.class);\n+\n+        if (config.serial == null || config.serial < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"RF Zone handler initializing for serial {}\", config.serial);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"RF Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for RF Zone {}\", config.serial);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel states to \"UNDEF\" at init time. The real states will be set either when the first message\n+     * arrives for the zone, or they will be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_RF_LOWBAT, state);\n+        updateState(CHANNEL_RF_SUPERVISION, state);\n+        updateState(CHANNEL_RF_LOOP1, state);\n+        updateState(CHANNEL_RF_LOOP2, state);\n+        updateState(CHANNEL_RF_LOOP3, state);\n+        updateState(CHANNEL_RF_LOOP4, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"RF Zone handler for {} received panel ready notification.\", config.serial);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_RF_LOOP1, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP2, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP3, OpenClosedType.CLOSED);\n+            updateState(CHANNEL_RF_LOOP4, OpenClosedType.CLOSED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Does not accept any commands", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDIzNg==", "bodyText": "remove", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024236", "createdAt": "2020-04-11T06:15:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.osgi.service.component.annotations.Activate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    @Activate\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Serial device name not configured\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"port name not configured\");\n+            }\n+        } catch (PortInUseException e) {\n+            logger.debug(\"Cannot open serial port: {}, it is already in use\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Serial port already in use\");\n+        } catch (UnsupportedCommOperationException | IOException | IllegalStateException e) {\n+            logger.debug(\"Error connecting to serial port: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void disconnect() {\n+        logger.trace(\"Disconnecting\");\n+        if (serialPort != null) {\n+            logger.trace(\"Closing serial port\");\n+            serialPort.close();\n+            serialPort = null;\n+        }\n+\n+        stopMsgReader();\n+\n+        if (reader != null) {\n+            logger.trace(\"Closing reader\");\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.info(\"IO Exception closing reader: {}\", e.getMessage());\n+            } finally {\n+                reader = null;\n+            }\n+        }\n+        if (writer != null) {\n+            logger.trace(\"Closing writer\");\n+            try {\n+                // writer.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDUxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(command);\n          \n          \n            \n                    return command;", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024516", "createdAt": "2020-04-11T06:18:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADCommand.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link ADCCommand} class represents an alarm decoder command, and contains the static methods and definitions\n+ * used to construct one. Not all supported AD commands are necessarily used by the current binding.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class ADCommand {\n+\n+    public static final String SPECIAL_KEY_1 = \"\\u0001\\u0001\\u0001\";\n+    public static final String SPECIAL_KEY_2 = \"\\u0002\\u0002\\u0002\";\n+    public static final String SPECIAL_KEY_3 = \"\\u0003\\u0003\\u0003\";\n+    public static final String SPECIAL_KEY_4 = \"\\u0004\\u0004\\u0004\";\n+    public static final String SPECIAL_KEY_5 = \"\\u0005\\u0005\\u0005\";\n+    public static final String SPECIAL_KEY_6 = \"\\u0006\\u0006\\u0006\";\n+    public static final String SPECIAL_KEY_7 = \"\\u0007\\u0007\\u0007\";\n+    public static final String SPECIAL_KEY_8 = \"\\u0008\\u0008\\u0008\";\n+\n+    // public static final String KEYPAD_COMMAND_CHARACTERS = \"0123456789*#<>\";\n+    public static final String KEYPAD_COMMAND_REGEX = \"^[0-9A-H*#<>]+$\";\n+\n+    private static final String TERM = \"\\r\\n\";\n+\n+    private static final String COMMAND_REBOOT = \"=\";\n+    private static final String COMMAND_CONFIG = \"C\";\n+    private static final String COMMAND_ZONE = \"L\";\n+    private static final String COMMAND_ERROR = \"E\";\n+    private static final String COMMAND_VERSION = \"V\";\n+    private static final String COMMAND_ADDRMSG = \"K\";\n+    private static final String COMMAND_ACKCRC = \"R\";\n+\n+    public final String command;\n+\n+    public ADCommand(String command) {\n+        this.command = command + TERM;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDYwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(message);\n          \n          \n            \n                    return message;", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024606", "createdAt": "2020-04-11T06:20:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMessage.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Superclass for all Alarm Decoder protocol message types.\n+ * Includes code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADMessage {\n+\n+    protected static final Pattern SPLIT_REGEX = Pattern.compile(\"[^\\\\,\\\"]+|\\\"[^\\\"]*\\\"\");\n+\n+    /** string containing the original unparsed message */\n+    public final String message;\n+\n+    public ADMessage(String message) {\n+        this.message = message;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new String(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024803", "createdAt": "2020-04-11T06:22:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/EXPMessage.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link EXPMessage} class represents a parsed zone (EXP or REL) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class EXPMessage extends ADMessage {\n+\n+    // Example: !EXP:07,01,01\n+    // Example: !REL:12,01,01\n+\n+    /** Address number */\n+    public final int address;\n+\n+    /** Channel number */\n+    public final int channel;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public EXPMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in EXP message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 3) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in EXP message\");\n+        }\n+\n+        try {\n+            address = Integer.parseInt(parts.get(0));\n+            channel = Integer.parseInt(parts.get(1));\n+            data = Integer.parseInt(parts.get(2));\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"EXP message contains invalid number: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\");\n          \n          \n            \n                            throw new IllegalArgumentException(\"Unable to parse integer in mapping\", e);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024817", "createdAt": "2020-04-11T06:23:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();\n+\n+        String mstring = mappingString.replace(\"POUND\", \"#\");\n+        String[] elements = mstring.split(\",\");\n+        for (String element : elements) {\n+            String[] kvPair = element.split(\"=\");\n+            if (kvPair.length != 2) {\n+                throw new IllegalArgumentException(\"Invalid key-value pair format\");\n+            }\n+\n+            Matcher matcher = validCommandPattern.matcher(kvPair[1]);\n+            if (!matcher.matches()) {\n+                throw new IllegalArgumentException(\"Invalid command characters in mapping\");\n+            }\n+\n+            try {\n+                commandMap.put(Integer.parseInt(kvPair[0]), kvPair[1]);\n+            } catch (NumberFormatException e) {\n+                throw new IllegalArgumentException(\"Unable to parse integer in mapping\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDgzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n          \n          \n            \n                private static final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024838", "createdAt": "2020-04-11T06:23:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private final Pattern validCommandPattern = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNDk0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407024945", "createdAt": "2020-04-11T06:24:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTAzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025035", "createdAt": "2020-04-11T06:25:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);\n+            }\n+            partition = p;\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"LRR msg contains invalid number: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNTA3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());\n          \n          \n            \n                        throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage(), e);", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407025074", "createdAt": "2020-04-11T06:26:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/RFXMessage.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFXMessage} class represents a parsed RF zone (RFX) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFXMessage extends ADMessage {\n+\n+    // Example: !RFX:0180036,80\n+\n+    public static final int BIT_LOWBAT = 0x02;\n+    public static final int BIT_SUPER = 0x04;\n+    public static final int BIT_LOOP3 = 0x10;\n+    public static final int BIT_LOOP2 = 0x20;\n+    public static final int BIT_LOOP4 = 0x40;\n+    public static final int BIT_LOOP1 = 0x80;\n+\n+    /** Address serial number */\n+    public final int serial;\n+\n+    /** Message data */\n+    public final int data;\n+\n+    public RFXMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"Multiple colons found in RFX message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        if (parts.size() != 2) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in RFX message\");\n+        }\n+\n+        try {\n+            serial = Integer.parseInt(parts.get(0));\n+            data = Integer.parseInt(parts.get(1), 16);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"RFX message contains invalid number: \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNjExMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Serial or USB Port</label>\n          \n          \n            \n            \t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n          \n          \n            \n            \t\t\t\t<label>Serial or USB Port</label>\n          \n          \n            \n            \t\t\t\t<context>serial-port</context>\n          \n          \n            \n            \t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407026111", "createdAt": "2020-04-11T06:38:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,326 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<description>The hostname of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received. Set to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNjE1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Host Name</label>\n          \n          \n            \n            \t\t\t\t<description>The hostname of the Alarm Decoder device</description>\n          \n          \n            \n            \t\t\t\t<label>Host Name</label>\n          \n          \n            \n            \t\t\t\t<context>network-address</context>\n          \n          \n            \n            \t\t\t\t<description>The hostname of the Alarm Decoder device</description>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407026153", "createdAt": "2020-04-11T06:38:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,326 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<description>The hostname of the Alarm Decoder device</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79bce4d41c750de5b53188bb8694c9a7dfd3af25"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "310488e29c2265cef1367c2bf3a4ef30a4a853ae", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/310488e29c2265cef1367c2bf3a4ef30a4a853ae", "committedDate": "2020-04-11T17:58:43Z", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/dbd1f70710e0ef73f0aecb9684bd9fbc3c01c0b5", "committedDate": "2020-04-11T20:17:15Z", "message": "[alarmdecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27", "committedDate": "2020-04-11T20:42:55Z", "message": "[alarmdecoder] Doc update\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODI0MTI1", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-391824125", "createdAt": "2020-04-12T05:53:34Z", "commit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwNTo1MzozNFrOGESf8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwNDoxNTozM1rOGHlguQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE1MDU3Nw==", "bodyText": "couldn't this have been checked in the initialize method instead?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r407150577", "createdAt": "2020-04-12T05:53:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname parameter not supplied\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            if (config.hostname != null && config.tcpPort > 0 && config.tcpPort < 65536) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODA2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Boolean responsibleFor(final int address, final int channel) {\n          \n          \n            \n                public boolean responsibleFor(final int address, final int channel) {", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598060", "createdAt": "2020-04-18T03:51:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public Boolean responsibleFor(final int address, final int channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5ODIwOQ==", "bodyText": "use or lose", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410598209", "createdAt": "2020-04-18T03:52:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // serialPort.disableReceiveFraming();\n+                // serialPort.disableReceiveThreshold();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTgzNg==", "bodyText": "Shouldn't his logic be in the initialize method?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599836", "createdAt": "2020-04-18T03:55:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410599893", "createdAt": "2020-04-18T03:56:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMTQ5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    commandMap = new HashMap<Integer, String>();\n          \n          \n            \n                    commandMap = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410601497", "createdAt": "2020-04-18T03:59:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    public IntCommandMap(String mappingString) throws IllegalArgumentException {\n+        commandMap = new HashMap<Integer, String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzA5Ng==", "bodyText": "You should override the .equals(Object obj) method instead of overloading.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603096", "createdAt": "2020-04-18T04:04:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);\n+    }\n+\n+    /**\n+     * Returns the value of an individual bit in the status field\n+     *\n+     * @param bit status field bit to test\n+     * @return true if bit is 1, false if bit is 0\n+     */\n+    public boolean getStatus(int bit) {\n+        int v = (status >> bit) & 0x1;\n+        return (v == 0) ? false : true;\n+    }\n+\n+    /**\n+     * Returns true if the READY status bit is set\n+     */\n+    public boolean panelClear() {\n+        return ((status & (1 << BIT_READY)) != 0);\n+    }\n+\n+    /**\n+     * Returns a string containing the address mask of the message in hex\n+     */\n+    public String getAddressMask() {\n+        return rawData.substring(3, 11);\n+    }\n+\n+    /**\n+     * Returns an int containing the address mask of the message\n+     */\n+    public int getIntAddressMask() {\n+        return Integer.parseInt(getAddressMask(), 16);\n+    }\n+\n+    /**\n+     * Compares two KeypadMessage objects\n+     *\n+     * @param other KeypadMessage to compare against\n+     * @return true if messages are equal, false if other is null or messages are not equal\n+     */\n+    public boolean equals(@Nullable KeypadMessage other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzI4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new String(alphaMessage);\n          \n          \n            \n                    return alphaMessage;", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603282", "createdAt": "2020-04-18T04:04:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }\n+            this.numericCode = numeric;\n+\n+            this.upper = Integer.parseInt(parts.get(0).substring(1, 6), 2);\n+            this.nbeeps = Integer.parseInt(parts.get(0).substring(6, 7));\n+            this.lower = Integer.parseInt(parts.get(0).substring(7, 17), 2);\n+            this.status = ((upper & 0x1F) << 13) | ((nbeeps & 0x3) << 10) | lower;\n+\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keypad msg contains invalid number: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    public int getZone() {\n+        return numericCode;\n+    }\n+\n+    /**\n+     * Returns a string containing the keypad text\n+     */\n+    public String getText() {\n+        return new String(alphaMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwMzcyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (parts.size() == 4) {\n          \n          \n            \n                        reportCode = parts.get(3);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        reportCode = \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    reportCode = parts.size() == 4 ? parts.get(3) : \"\";", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410603725", "createdAt": "2020-04-18T04:05:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+\n+        if (parts.size() == 4) {\n+            reportCode = parts.get(3);\n+        } else {\n+            reportCode = \"\";\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzgwMQ==", "bodyText": "Please make sure to set the thread as daemon.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410607801", "createdAt": "2020-04-18T04:15:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 129}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/3f1c94b167fb28c8921cf7c88adf5b1974f6473b", "committedDate": "2020-04-18T19:07:36Z", "message": "[alarmdecoder] Address review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTcxNTE4", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-395971518", "createdAt": "2020-04-19T03:19:26Z", "commit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwMzoxOToyNlrOGHxYsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNDoxNDoyNlrOGHx25Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMjM1NQ==", "bodyText": "You should specify the Charset that these streams should use.\nThe default charset varies from system to system so it is better to specify it yourself instead of using the default.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410802355", "createdAt": "2020-04-19T03:19:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) IPBridgeConfig config;\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwMzc3NA==", "bodyText": "Since the name of the port is configured by the user beforehand it should be expected that the serial port exists and is available at the time of handler initialization. The binding should fail-fast with regards to configuration errors otherwise you are wasting the user's time.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410803774", "createdAt": "2020-04-19T03:29:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge configuration missing\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                // Exit if no identifiers exist to work around possible bug\n+                Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+                if (!serialPortIdentifiers.findAny().isPresent()) {\n+                    logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+                    return;\n+                }\n+\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU5OTg5Mw=="}, "originalCommit": {"oid": "72440d4de487f1fe02c0a9f53d9a0c98bfa8cb27"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNDEzNg==", "bodyText": "This logic should be abstracted into the ADBridgeHandler. The ADBridgeHandler should be responsible for opening and closing the input/output streams leaving the subclasses only having to handle sending and parsing messages.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410804136", "createdAt": "2020-04-19T03:31:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/SerialBridgeHandler.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.alarmdecoder.internal.config.SerialBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via a serial port with the Nu Tech Alarm Decoder device.\n+ * Based on code from the original OH1 alarmdecoder binding. Some OHC serial transport code taken from the Zigbee\n+ * binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding and rewrote to use OHC serial transport.\n+ */\n+@NonNullByDefault\n+public class SerialBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SerialBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) SerialBridgeConfig config;\n+    private final SerialPortManager serialPortManager;\n+\n+    /** name of serial device */\n+    private String serialDeviceName = \"\";\n+    private @NonNullByDefault({}) SerialPort serialPort = null;\n+    private int serialPortSpeed = 115200;\n+\n+    public SerialBridgeHandler(Bridge bridge, SerialPortManager serialPortManager) {\n+        super(bridge);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing serial bridge handler\");\n+        config = getConfigAs(SerialBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.serialPort == null || config.serialPort.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"no serial port configured\");\n+            return;\n+        } else {\n+            serialDeviceName = config.serialPort;\n+        }\n+\n+        if (config.bitrate > 0) {\n+            serialPortSpeed = config.bitrate;\n+        }\n+\n+        // Exit if no identifiers exist to work around possible library bug. May not be needed in 3.0.\n+        Stream<SerialPortIdentifier> serialPortIdentifiers = serialPortManager.getIdentifiers();\n+        if (!serialPortIdentifiers.findAny().isPresent()) {\n+            logger.debug(\"No serial communication ports found. Cannot connect to [{}]\", serialDeviceName);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No serial ports found\");\n+            return;\n+        }\n+\n+        connect();\n+\n+        logger.trace(\"Finished initializing serial bridge handler\");\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        try {\n+            if (!serialDeviceName.isEmpty()) {\n+                SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialDeviceName);\n+                if (portIdentifier == null) {\n+                    logger.debug(\"Serial Error: Port {} does not exist.\", serialDeviceName);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Configured serial port does not exist\");\n+                    return;\n+                }\n+\n+                serialPort = portIdentifier.open(\"org.openhab.binding.alarmdecoder\", 100);\n+\n+                serialPort.setSerialPortParams(serialPortSpeed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1,\n+                        SerialPort.PARITY_NONE);\n+                serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_RTSCTS_IN | SerialPort.FLOWCONTROL_RTSCTS_OUT);\n+                // Note: The V1 code called disableReceiveFraming() and disableReceiveThreshold() here\n+\n+                reader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n+                writer = new BufferedWriter(new OutputStreamWriter(serialPort.getOutputStream()));\n+                logger.debug(\"connected to serial port: {}\", serialDeviceName);\n+                panelReadyReceived = false;\n+                startMsgReader();\n+                updateStatus(ThingStatus.ONLINE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw==", "bodyText": "There is nothing the user could do about this even if you informed him. I suggest changing the logging level to debug.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410806323", "createdAt": "2020-04-19T03:47:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODgyNQ==", "bodyText": "Right now you have this designed such that the bridge searches out handlers that should process a given message. This requires the bridge to have knowledge of all of the ADHandler subclasses and also a two step approach:\n\nBridge must identify which handlers could handle a message.\nBridge then passes on message to handlers found in step 1\n\nI think it would be simpler if instead you just send the message to all of the handlers and let the handlers decide whether or not they want to handle it. This allows the bridge to be ignorant of the types of handlers as well as possibly allowing the bridge to be ignorant of the message type as well. Also instead of each handler having to implement 2 methods (one to judge if it can handle the message and another to actually handle it), each handler would only have to implement a single method which optionally handles the message.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410808825", "createdAt": "2020-04-19T04:05:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        // Notify appropriate KeypadHandlers\n+        Collection<KeypadHandler> handlers = findKeypadHandlers(kpm.getIntAddressMask());\n+        for (KeypadHandler handler : handlers) {\n+            handler.handleUpdate(kpm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        ZoneHandler handler = findZoneHandler(expm.address, expm.channel);\n+        if (handler != null) {\n+            handler.handleUpdate(expm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        RFZoneHandler handler = findRFZoneHandler(rfxm.serial);\n+        if (handler != null) {\n+            handler.handleUpdate(rfxm.data);\n+        }\n+\n+        if (discovery && discoveryService != null) {\n+            discoveryService.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        // Notify appropriate LRRHandlers\n+        Collection<LRRHandler> handlers = findLRRHandlers(lrrm.partition);\n+        for (LRRHandler handler : handlers) {\n+            handler.handleUpdate(lrrm);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify all child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * channels are initialized into the UNDEF state. This method is called when there is reason to assume that there\n+     * are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received updates\n+     * can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                if (thing.getHandler() instanceof ZoneHandler || thing.getHandler() instanceof RFZoneHandler) {\n+                    ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                    if (handler != null) {\n+                        handler.notifyPanelReady();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the ZoneHandler for the given address and channel, or null if no handler exists and is initialized.\n+     */\n+    private @Nullable ZoneHandler findZoneHandler(int address, int channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTM4OQ==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809389", "createdAt": "2020-04-19T04:09:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Returns true if this handler is responsible for the zone with the supplied address and channel.\n+     */\n+    public boolean responsibleFor(final int address, final int channel) {\n+        return (config.address != null && config.channel != null && config.address.equals(address)\n+                && config.channel.equals(channel));\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address == null || config.channel == null || config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state for Zone {},{}\", config.address, config.channel);\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            firstUpdateReceived.set(false);\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Set contact channel state to \"UNDEF\" at init time. The real state will be set either when the first message\n+     * arrives for the zone, or it should be set to \"CLOSED\" the first time the panel goes into the \"READY\" state.\n+     */\n+    @Override\n+    public void initChannelState() {\n+        UnDefType state = UnDefType.UNDEF;\n+        updateState(CHANNEL_CONTACT, state);\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        logger.trace(\"Zone handler for {},{} received panel ready notification.\", config.address, config.channel);\n+        if (firstUpdateReceived.compareAndSet(false, true)) {\n+            updateState(CHANNEL_CONTACT, OpenClosedType.CLOSED);\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwOTczOQ==", "bodyText": "please put static fields before non-static fields", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410809739", "createdAt": "2020-04-19T04:12:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/IntCommandMap.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link IntCommandMap} class contains an integer to command map used by the keypad intcommand channel.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IntCommandMap {\n+    private final Map<Integer, String> commandMap;\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxMDA4NQ==", "bodyText": "How would you know this is correct if you are given a hexadecimal number that doesn't have any letters in it?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r410810085", "createdAt": "2020-04-19T04:14:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/LRRMessage.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link LRRMessage} class represents a parsed LRR message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer and Lucky Mallari.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LRRMessage extends ADMessage {\n+\n+    // Example: !LRR:012,1,CID_1441,ff\n+\n+    /** Event data contains user number or zone number for the event */\n+    public final String eventData;\n+\n+    /** Partition event applies to. 0 means all partitions. */\n+    public final int partition;\n+\n+    /** CID message for event as defined in SIA DC-05-1999.09 standard */\n+    public final String cidMessage;\n+\n+    /** Report code */\n+    public final String reportCode;\n+\n+    public LRRMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+\n+        String topLevel[] = message.split(\":\");\n+        if (topLevel.length != 2) {\n+            throw new IllegalArgumentException(\"multiple colons in LRR message\");\n+        }\n+\n+        List<String> parts = splitMsg(topLevel[1]);\n+\n+        // Apparently the 4th part of the LRR message may not be included depending on version\n+        if (parts.size() < 3 || parts.size() > 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in LRR message\");\n+        }\n+\n+        eventData = parts.get(0);\n+        cidMessage = parts.get(2);\n+        reportCode = parts.size() == 4 ? parts.get(3) : \"\";\n+\n+        try {\n+            int p = 0;\n+            try {\n+                p = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                p = Integer.parseInt(parts.get(1), 16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "931d565f12f9dce717c720505077d35cc30c53a1", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/931d565f12f9dce717c720505077d35cc30c53a1", "committedDate": "2020-04-19T17:48:09Z", "message": "[alarmdecoder] Address a few more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "463495df30a70361a0618afa8e0d4f5e25c76791", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/463495df30a70361a0618afa8e0d4f5e25c76791", "committedDate": "2020-04-19T23:47:16Z", "message": "[alarmdecoder] Minor update to SerialBridgeHandler\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7491fe7def52bb535d9a6dc95348281bf7f21567", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/7491fe7def52bb535d9a6dc95348281bf7f21567", "committedDate": "2020-04-21T02:40:26Z", "message": "[alarmdecoder] Change message dispatching model\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/9a6cc7eff73212e1fb22bff25a9cda69832a7d9a", "committedDate": "2020-04-21T16:55:52Z", "message": "[alarmdecoder] Update to LRR message parsing\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjkwNDEz", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-397690413", "createdAt": "2020-04-21T21:30:10Z", "commit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTozMDoxMFrOGJZUyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0OTo0NFrOGJZ9aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNTI5MA==", "bodyText": "There has been a consensus among the addon maintainers to not allow use of @NonNullByDefault({}) on config fields. There are several alternatives that are allowed:\n\nmake field nullable\nwrap config in a non-null Optional field\nmake config field non-null by initializing to a default configuration.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412505290", "createdAt": "2020-04-21T21:30:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private @NonNullByDefault({}) ZoneConfig config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwNjMyMw==", "bodyText": "Please either make these fields nullable or provide a default value for them. Do not use @NonNullByDefault({}) in any config classes.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412506323", "createdAt": "2020-04-21T21:32:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/ZoneConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+\n+/**\n+ * The {@link ZoneConfig} class contains fields mapping thing configuration parameters for {@link ZoneHandler}.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneConfig {\n+    public @NonNullByDefault({}) Integer address;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTE3NA==", "bodyText": "Is this handled properly?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412509174", "createdAt": "2020-04-21T21:37:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/KeypadMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link KeypadMessage} class represents a parsed keypad (KPM) message.\n+ * Based partly on code from the OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadMessage extends ADMessage {\n+\n+    // Example: [00110011000000003A--],010,[f70700000010808c18020000000000],\"ARMED ***STAY** ZONE BYPASSED \"\n+\n+    public static final int BIT_READY = 17;\n+    public static final int BIT_ARMEDAWAY = 16;\n+    public static final int BIT_ARMEDHOME = 15;\n+    public static final int BIT_BACKLIGHT = 14;\n+    public static final int BIT_PRORGAM = 13;\n+    public static final int BIT_BYPASSED = 9;\n+    public static final int BIT_ACPOWER = 8;\n+    public static final int BIT_CHIME = 7;\n+    public static final int BIT_ALARMOCCURRED = 6;\n+    public static final int BIT_ALARM = 5;\n+    public static final int BIT_LOWBAT = 4;\n+    public static final int BIT_DELAYOFF = 3;\n+    public static final int BIT_FIRE = 2;\n+    public static final int BIT_SYSFAULT = 1;\n+    public static final int BIT_PERIMETER = 0;\n+\n+    public final String bitField;\n+    public final int numericCode;\n+    public final String rawData;\n+    public final String alphaMessage;\n+    public final int nbeeps;\n+    public final int status;\n+\n+    private final int upper;\n+    private final int lower;\n+\n+    public KeypadMessage(String message) throws IllegalArgumentException {\n+        super(message);\n+        List<String> parts = splitMsg(message);\n+\n+        if (parts.size() != 4) {\n+            throw new IllegalArgumentException(\"Invalid number of parts in keypad message\");\n+        }\n+        if (parts.get(0).length() != 22) {\n+            throw new IllegalArgumentException(\"Invalid field length in keypad message\");\n+        }\n+\n+        bitField = parts.get(0);\n+        rawData = parts.get(2);\n+        alphaMessage = parts.get(3).replaceAll(\"^\\\"|\\\"$\", \"\");\n+\n+        try {\n+            int numeric = 0;\n+            try {\n+                numeric = Integer.parseInt(parts.get(1));\n+            } catch (NumberFormatException e) {\n+                numeric = Integer.parseInt(parts.get(1), 16);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTY4OQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412515689", "createdAt": "2020-04-21T21:49:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/protocol/ADMsgType.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.protocol;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The various message types that come from the ad2usb/ad2pi interface\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1)\n+ * @author Bob Adair - Re-factored and removed methods unused in OH2 binding\n+ */\n+public enum ADMsgType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a6cc7eff73212e1fb22bff25a9cda69832a7d9a"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "605e2624207e1806c20ed0e515fc447652ff5656", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/605e2624207e1806c20ed0e515fc447652ff5656", "committedDate": "2020-04-21T23:45:58Z", "message": "[alarmdecoder] Change null annotations in config classes\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33b706af73c1b1f0704478f9e386513dffcd2e15", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/33b706af73c1b1f0704478f9e386513dffcd2e15", "committedDate": "2020-04-21T23:50:02Z", "message": "[alarmdecoder] Bump version in pom.xml\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODgxMzE3", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-397881317", "createdAt": "2020-04-22T06:35:10Z", "commit": {"oid": "33b706af73c1b1f0704478f9e386513dffcd2e15"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNToxMFrOGJlrXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwNjozNToxMFrOGJlrXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzY3Nw==", "bodyText": "Almost all of the of the handlers implement this method the same way, is it possible to have it refactored?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r412707677", "createdAt": "2020-04-22T06:35:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ZoneHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.alarmdecoder.internal.config.ZoneConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZoneHandler} is responsible for handling wired zones (i.e. REL & EXP messages).\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZoneHandler extends ADThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZoneHandler.class);\n+\n+    private ZoneConfig config = new ZoneConfig();\n+\n+    public ZoneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /** Construct zone id from address and channel */\n+    public static final String zoneID(int address, int channel) {\n+        return String.format(\"%d-%d\", address, channel);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(ZoneConfig.class);\n+\n+        if (config.address < 0 || config.channel < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid address/channel setting\");\n+            return;\n+        }\n+        logger.debug(\"Zone handler initializing for address {} channel {}\", config.address, config.channel);\n+\n+        String id = zoneID(config.address, config.channel);\n+        updateProperty(PROPERTY_ID, id); // set representation property used by discovery\n+\n+        initDeviceState();\n+        logger.trace(\"Zone handler finished initializing\");\n+    }\n+\n+    @Override\n+    protected void initDeviceState() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33b706af73c1b1f0704478f9e386513dffcd2e15"}, "originalPosition": 72}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/8a4be504a4c3bdf74696491625be23fbb73704fa", "committedDate": "2020-04-22T16:22:53Z", "message": "[alarmecoder] Move device state init to handler superclass\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NDM2ODgy", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-398436882", "createdAt": "2020-04-22T17:53:23Z", "commit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzo1MzoyM1rOGKDXZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODowNTozM1rOGKD5yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5NDA4Ng==", "bodyText": "It is very easy to get a NPE here if another thread sets reader to null in-between your null check and your readLine call.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413194086", "createdAt": "2020-04-22T17:53:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5ODAzOA==", "bodyText": "Please cache bridgeStatusInfo.getStatus() in a local variable for reuse.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413198038", "createdAt": "2020-04-22T17:58:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADThingHandler.class);\n+    protected final AtomicBoolean firstUpdateReceived = new AtomicBoolean(false);\n+\n+    public ADThingHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Initialize device state and set status for handler. Should be called at the end of initialize(). Calls\n+     * initChannelState() to initialize channels if setting status to ONLINE.\n+     */\n+    protected void initDeviceState() {\n+        logger.trace(\"Initializing device state\");\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No bridge configured\");\n+        } else if (bridge.getStatus() == ThingStatus.ONLINE) {\n+            initChannelState();\n+            updateStatus(ThingStatus.ONLINE);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+        }\n+    }\n+\n+    /**\n+     * Initialize channel states if necessary\n+     */\n+    public abstract void initChannelState();\n+\n+    /**\n+     * Notify handler that panel is in ready state so that any un-updated contact channels can be set to default\n+     * (closed).\n+     */\n+    public abstract void notifyPanelReady();\n+\n+    /**\n+     * Notify handler of a message from the AD via the bridge\n+     *\n+     * @param msg The ADMessage to handle\n+     */\n+    public abstract void handleUpdate(ADMessage msg);\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        logger.debug(\"Bridge status changed to {} for AD handler\", bridgeStatusInfo.getStatus());\n+\n+        if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMDY2NA==", "bodyText": "For instance, the warnings on the following two lines can be fixed like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        Socket socket = new Socket(config.hostname, config.tcpPort);\n          \n          \n            \n                        this.socket = socket;", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413200664", "createdAt": "2020-04-22T18:02:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMjg4OQ==", "bodyText": "This is how you fix the warning here. It can be annoying, but it makes the code much more thread-safe. You get the general idea though, so I'll let you fix the rest.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {\n          \n          \n            \n                    Thread msgReaderThread = this.msgReaderThread;\n          \n          \n            \n                    if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413202889", "createdAt": "2020-04-22T18:05:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            socket = new Socket(config.hostname, config.tcpPort);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(config.reconnect); // Possibly a retryable error. Try again later.\n+        }\n+    }\n+\n+    protected synchronized void connectionCheck() {\n+        logger.trace(\"Connection check job running\");\n+\n+        if (msgReaderThread != null && !msgReaderThread.isAlive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4be504a4c3bdf74696491625be23fbb73704fa"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/7f7facd7ac5b1cb9445343c9c19a949a9184c3fc", "committedDate": "2020-04-22T20:27:49Z", "message": "[alarmecoder] Fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a7995bb300539cf99378c2a13fd93d4eb046ce1", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/4a7995bb300539cf99378c2a13fd93d4eb046ce1", "committedDate": "2020-04-22T21:02:21Z", "message": "[alarmecoder] Run spotless apply\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NTk0MjQ2", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-398594246", "createdAt": "2020-04-22T21:14:06Z", "commit": {"oid": "4a7995bb300539cf99378c2a13fd93d4eb046ce1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMToxNDowNlrOGKMHcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMToxNDowNlrOGKMHcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzQ1Nw==", "bodyText": "This would solve the only warning left.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void reboot() {\n          \n          \n            \n                    if (bridge != null) {\n          \n          \n            \n                public void reboot() {\n          \n          \n            \n                    ADBridgeHandler bridge = this.bridge;\n          \n          \n            \n                    if (bridge != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r413337457", "createdAt": "2020-04-22T21:14:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n+    public void reboot() {\n+        if (bridge != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a7995bb300539cf99378c2a13fd93d4eb046ce1"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/09dcd28ca6a4f6bae03b7ffc888f607a2084fccd", "committedDate": "2020-04-22T21:29:03Z", "message": "[alarmecoder] Really fix all compiler warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjEwMDQ1", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-398610045", "createdAt": "2020-04-22T21:40:17Z", "commit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTUwODc3", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-400150877", "createdAt": "2020-04-24T17:46:54Z", "commit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNzo0Njo1NFrOGLij-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOToyNzoyOFrOGLmFew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1Mzc4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **ipbridge** - Supports TCP connection to the AD.\n          \n          \n            \n            * `ipbridge` - Supports TCP connection to the AD.\n          \n      \n    \n    \n  \n\nWe use this notation for thing/channel/parameter names. Please also change the other occurences", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414753786", "createdAt": "2020-04-24T17:46:54Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/README.md", "diffHunk": "@@ -0,0 +1,267 @@\n+# Alarm Decoder Binding\n+\n+The [Alarm Decoder](http://www.alarmdecoder.com) from Nu Tech Software Solutions is a hardware adapter that interfaces with Ademco/Honeywell and DSC alarm panels.\n+It acts essentially like a keypad, reading and writing messages on the serial bus that connects keypads with the main panel.\n+\n+There are several versions of the adapter available: \n+\n+* *AD2PI* or *AD2PHAT* - A board that plugs into a Raspberry Pi and offers network-based TCP connectivity\n+* *AD2SERIAL* - Attaches to a host via a serial port\n+* *AD2USB* - Attaches to a host via USB\n+\n+This binding allows openHAB to access the state of wired or wireless contacts and motion detectors connected to supported alarm panels, as well as the state of attached keypads and the messages send to attached LRR devices.\n+Support is also available for sending keypad commands, including special/programmable keys supported by your panel.\n+\n+For those upgrading from the OH1 version of the binding, the [original OH1 README](doc/README_OH1.md) file is available for reference.\n+\n+## Supported Things\n+\n+The binding supports the following thing types:\n+\n+* **ipbridge** - Supports TCP connection to the AD.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1NTE0MA==", "bodyText": "What is this file for?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414755140", "createdAt": "2020-04-24T17:49:06Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/doc/README_OH1.md", "diffHunk": "@@ -0,0 +1,264 @@\n+# Alarm Decoder Binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4Mzg2Ng==", "bodyText": "Does this pass the codestyle-check without warning?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414783866", "createdAt": "2020-04-24T18:37:41Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/AlarmDecoderDiscoveryService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ZoneHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link AlarmDecoderDiscoveryService} handles discovery of devices as they are identified by the bridge handler.\n+ * Requests from the framework to startScan() are ignored, since no active scanning is possible.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AlarmDecoderDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(AlarmDecoderDiscoveryService.class);\n+\n+    private ADBridgeHandler bridgeHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NTc1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")\n          \n          \n            \n                @RuleAction(label = \"Reboot\", description = \"Reboot the Alarm Decoder device\")", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414785752", "createdAt": "2020-04-24T18:40:54Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/actions/BridgeActions.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.actions;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.handler.ADBridgeHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link BridgeActions} class defines thing actions for alarmdecoder bridges.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@ThingActionsScope(name = \"alarmdecoder\")\n+@NonNullByDefault\n+public class BridgeActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BridgeActions.class);\n+\n+    private @Nullable ADBridgeHandler bridge;\n+\n+    public BridgeActions() {\n+        logger.trace(\"Alarm Decoder bridge actions service created\");\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ADBridgeHandler) {\n+            this.bridge = (ADBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridge;\n+    }\n+\n+    /**\n+     * Reboot thing action\n+     */\n+    @RuleAction(label = \"reboot\", description = \"Reboot the Alarm Decoder device\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4NzU2Mg==", "bodyText": "I don't think this is a valid serial port. Wouldn't it be better to use @nullable here?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414787562", "createdAt": "2020-04-24T18:43:51Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/SerialBridgeConfig.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link SerialBridgeConfig} class contains fields mapping thing configuration parameters for SerialBridgeHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SerialBridgeConfig {\n+    public String serialPort = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4ODkyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ADMsgType mt = ADMsgType.getMsgType(msg);\n          \n          \n            \n                            ADMsgType msgType = ADMsgType.getMsgType(msg);\n          \n      \n    \n    \n  \n\nuse meaningful names where possible", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414788929", "createdAt": "2020-04-24T18:46:13Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4OTk2Nw==", "bodyText": "If this is something that should be reported, I would suggest to include that in the message (e.e. \"This is a bug and should be reported\") and increase to WARN", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414789967", "createdAt": "2020-04-24T18:48:05Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            if (writer != null) {\n+                writer.write(command.toString());\n+                writer.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            msgReaderThread = new Thread(this::readerThread, \"AD Reader\");\n+            msgReaderThread.setDaemon(true);\n+            msgReaderThread.start();\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            if (msgReaderThread != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                msgReaderThread.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwNjMyMw=="}, "originalCommit": {"oid": "3f1c94b167fb28c8921cf7c88adf5b1974f6473b"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MDM2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    KeypadMessage kpm;\n          \n          \n            \n                    KeypadMessage keyPadMessage;\n          \n      \n    \n    \n  \n\nIt would be nice if you could check other occurences of two/three letter variable/field/parameter names and refactor them to something more readable.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414790362", "createdAt": "2020-04-24T18:48:46Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MzI1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                    getThing().getThings().forEach(thing -> {", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414793257", "createdAt": "2020-04-24T18:53:55Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NTU2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (Thing thing : getThing().getThings()) {\n          \n          \n            \n                            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n          \n          \n            \n                            if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n          \n          \n            \n                                handler.notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        getThing().getThings().stream().map(Thing::getHandler).filter(Objects::nonNull).forEach(handler -> {\n          \n          \n            \n                            if (handler instanceof ZoneHandler || handler instanceof RFZoneHandler) {\n          \n          \n            \n                                ((ADThingHandler) handler).notifyPanelReady();\n          \n          \n            \n                            }\n          \n          \n            \n                        });", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414795567", "createdAt": "2020-04-24T18:57:54Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADBridgeHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.AlarmDecoderDiscoveryService;\n+import org.openhab.binding.alarmdecoder.internal.actions.BridgeActions;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMsgType;\n+import org.openhab.binding.alarmdecoder.internal.protocol.EXPMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.LRRMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.RFXMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.VersionMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract base class for bridge handlers responsible for communicating with the Nu Tech Alarm Decoder devices.\n+ * Based partly on and including code from the original OH1 alarmdecoder binding by Bernd Pfrommer.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public abstract class ADBridgeHandler extends BaseBridgeHandler {\n+    protected static final String AD_CHARSET_NAME = \"UTF-8\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(ADBridgeHandler.class);\n+\n+    protected @Nullable BufferedReader reader = null;\n+    protected @Nullable BufferedWriter writer = null;\n+    protected @Nullable Thread msgReaderThread = null;\n+    private final Object msgReaderThreadLock = new Object();\n+    protected @Nullable AlarmDecoderDiscoveryService discoveryService;\n+    protected boolean discovery;\n+    protected boolean panelReadyReceived = false;\n+    protected volatile @Nullable Date lastReceivedTime;\n+    protected volatile boolean writeException;\n+\n+    protected @Nullable ScheduledFuture<?> connectionCheckJob;\n+    protected @Nullable ScheduledFuture<?> connectRetryJob;\n+\n+    public ADBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose called\");\n+        disconnect();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(BridgeActions.class);\n+    }\n+\n+    public void setDiscoveryService(AlarmDecoderDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // Accepts no commands, so do nothing.\n+    }\n+\n+    /**\n+     * Send a command to the alarm decoder using a buffered writer. This could block if the buffer is full, so it should\n+     * eventually be replaced with a queuing mechanism and a separate writer thread.\n+     *\n+     * @param command Command string to send including terminator\n+     */\n+    public void sendADCommand(ADCommand command) {\n+        logger.debug(\"Sending AD command: {}\", command);\n+        try {\n+            BufferedWriter bw = writer;\n+            if (bw != null) {\n+                bw.write(command.toString());\n+                bw.flush();\n+            }\n+        } catch (IOException e) {\n+            logger.info(\"Exception while sending command: {}\", e.getMessage());\n+            writeException = true;\n+        }\n+    }\n+\n+    protected abstract void connect();\n+\n+    protected abstract void disconnect();\n+\n+    protected void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    protected void startMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = new Thread(this::readerThread, \"AD Reader\");\n+            mrt.setDaemon(true);\n+            mrt.start();\n+            msgReaderThread = mrt;\n+        }\n+    }\n+\n+    protected void stopMsgReader() {\n+        synchronized (msgReaderThreadLock) {\n+            Thread mrt = msgReaderThread;\n+            if (mrt != null) {\n+                logger.trace(\"Stopping reader thread.\");\n+                mrt.interrupt();\n+                msgReaderThread = null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method executed by message reader thread\n+     */\n+    private void readerThread() {\n+        logger.debug(\"Message reader thread started\");\n+        String msg = null;\n+        try {\n+            // Send version command to get device to respond with VER message.\n+            sendADCommand(ADCommand.getVersion());\n+            BufferedReader reader = this.reader;\n+            while (!Thread.interrupted() && reader != null && (msg = reader.readLine()) != null) {\n+                logger.trace(\"Received msg: {}\", msg);\n+                ADMsgType mt = ADMsgType.getMsgType(msg);\n+                if (mt != ADMsgType.INVALID) {\n+                    lastReceivedTime = new Date();\n+                }\n+                try {\n+                    switch (mt) {\n+                        case KPM:\n+                            parseKeypadMessage(msg);\n+                            break;\n+                        case REL:\n+                        case EXP:\n+                            parseRelayOrExpanderMessage(mt, msg);\n+                            break;\n+                        case RFX:\n+                            parseRFMessage(msg);\n+                            break;\n+                        case LRR:\n+                            parseLRRMessage(msg);\n+                            break;\n+                        case VER:\n+                            parseVersionMessage(msg);\n+                            break;\n+                        case INVALID:\n+                        default:\n+                            break;\n+                    }\n+                } catch (MessageParseException e) {\n+                    logger.info(\"Error {} while parsing message {}\", e.getMessage(), msg);\n+                }\n+            }\n+            if (msg == null) {\n+                logger.info(\"End of input stream detected\");\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Connection lost\");\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"I/O error while reading from stream: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Runtime exception in reader thread\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } finally {\n+            logger.debug(\"Message reader thread exiting\");\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle keypad messages\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseKeypadMessage(String msg) throws MessageParseException {\n+        KeypadMessage kpm;\n+\n+        // Parse the message\n+        try {\n+            kpm = new KeypadMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        if (kpm.panelClear()) {\n+            // the panel is clear, so we can assume that all contacts that we\n+            // have not heard from are open\n+            notifyChildHandlersPanelReady();\n+        }\n+\n+        notifyChildHandlers(kpm);\n+    }\n+\n+    /**\n+     * Parse and handle relay and expander messages. The REL and EXP messages have identical format.\n+     *\n+     * @param mt message type of incoming message\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRelayOrExpanderMessage(ADMsgType mt, String msg) throws MessageParseException {\n+        // mt is unused at the moment\n+        EXPMessage expm;\n+\n+        try {\n+            expm = new EXPMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(expm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processZone(expm.address, expm.channel);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle RFX messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseRFMessage(String msg) throws MessageParseException {\n+        RFXMessage rfxm;\n+\n+        try {\n+            rfxm = new RFXMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(rfxm);\n+\n+        AlarmDecoderDiscoveryService ds = discoveryService;\n+        if (discovery && ds != null) {\n+            ds.processRFZone(rfxm.serial);\n+        }\n+    }\n+\n+    /**\n+     * Parse and handle LRR messages.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseLRRMessage(String msg) throws MessageParseException {\n+        LRRMessage lrrm;\n+\n+        // Parse the message\n+        try {\n+            lrrm = new LRRMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        notifyChildHandlers(lrrm);\n+    }\n+\n+    /**\n+     * Parse and handle version (VER) message. This just updates bridge properties.\n+     *\n+     * @param msg string containing incoming message payload\n+     * @throws MessageParseException\n+     */\n+    private void parseVersionMessage(String msg) throws MessageParseException {\n+        VersionMessage verm;\n+\n+        try {\n+            verm = new VersionMessage(msg);\n+        } catch (IllegalArgumentException e) {\n+            throw new MessageParseException(e.getMessage());\n+        }\n+\n+        logger.trace(\"Processing version message sn:{} ver:{} cap:{}\", verm.serial, verm.version, verm.capabilities);\n+        Map<String, String> properties = editProperties();\n+        properties.put(PROPERTY_SERIALNUM, verm.serial);\n+        properties.put(PROPERTY_VERSION, verm.version);\n+        properties.put(PROPERTY_CAPABILITIES, verm.capabilities);\n+        updateProperties(properties);\n+    }\n+\n+    /**\n+     * Notify appropriate child thing handlers of an AD message by calling their handleUpdate() methods.\n+     *\n+     * @param msg message to forward to child handler(s)\n+     */\n+    private void notifyChildHandlers(ADMessage msg) {\n+        for (Thing thing : getThing().getThings()) {\n+            ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+            //@formatter:off\n+            if (handler != null && ((handler instanceof ZoneHandler && msg instanceof EXPMessage) ||\n+                                    (handler instanceof RFZoneHandler && msg instanceof RFXMessage) ||\n+                                    (handler instanceof KeypadHandler && msg instanceof KeypadMessage) ||\n+                                    (handler instanceof LRRHandler && msg instanceof LRRMessage))) {\n+                handler.handleUpdate(msg);\n+            }\n+            //@formatter:on\n+        }\n+    }\n+\n+    /**\n+     * Notify child thing handlers that the alarm panel is in the ready state. Since there is no way to poll, all\n+     * contact channels are initialized into the UNDEF state. This method is called when there is reason to assume that\n+     * there are no faulted zones, because the alarm panel is in state READY. Zone handlers that have not yet received\n+     * updates can then set their contact states to CLOSED. Only executes the first time panel is ready after bridge\n+     * connect/reconnect. Currently only notifies ZoneHandler and RFZoneHandler things.\n+     */\n+    private void notifyChildHandlersPanelReady() {\n+        if (!panelReadyReceived) {\n+            panelReadyReceived = true;\n+            logger.trace(\"Notifying child handlers that panel is in ready state\");\n+\n+            // Notify child zone handlers by calling notifyPanelReady() for each\n+            for (Thing thing : getThing().getThings()) {\n+                ADThingHandler handler = (ADThingHandler) thing.getHandler();\n+                if (handler != null && (handler instanceof ZoneHandler || handler instanceof RFZoneHandler)) {\n+                    handler.notifyPanelReady();\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5NjIxNQ==", "bodyText": "see above: does this pass the codestyle check?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414796215", "createdAt": "2020-04-24T18:59:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/ADThingHandler.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link ADThingHandler} is the abstract base class for all AD thing handlers.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class ADThingHandler extends BaseThingHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODYxMQ==", "bodyText": "better set StandardCharsets.UTF8 instead of the UTF-8 string.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798611", "createdAt": "2020-04-24T19:03:21Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5ODk4NQ==", "bodyText": "no need to add debug logging, thing status changes are already logged", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414798985", "createdAt": "2020-04-24T19:04:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5OTE5Mw==", "bodyText": "see above", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414799193", "createdAt": "2020-04-24T19:04:22Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/IPBridgeHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.util.Date;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.openhab.binding.alarmdecoder.internal.config.IPBridgeConfig;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Handler responsible for communicating via TCP with the Nu Tech Alarm Decoder device.\n+ * Based on and including code from the original OH1 alarmdecoder binding.\n+ *\n+ * @author Bernd Pfrommer - Initial contribution (OH1 version)\n+ * @author Bob Adair - Re-factored into OH2 binding\n+ */\n+@NonNullByDefault\n+public class IPBridgeHandler extends ADBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IPBridgeHandler.class);\n+\n+    private IPBridgeConfig config = new IPBridgeConfig();\n+\n+    private @Nullable Socket socket = null;\n+\n+    public IPBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing IP bridge handler\");\n+        config = getConfigAs(IPBridgeConfig.class);\n+        discovery = config.discovery;\n+\n+        if (config.hostname == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"hostname not configured\");\n+            return;\n+        }\n+        if (config.tcpPort <= 0 || config.tcpPort > 65535) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"invalid port number configured\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background connect task decide the real status.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    @Override\n+    protected synchronized void connect() {\n+        disconnect(); // make sure we are disconnected\n+        writeException = false;\n+        try {\n+            Socket socket = new Socket(config.hostname, config.tcpPort);\n+            this.socket = socket;\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), AD_CHARSET_NAME));\n+            writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream(), AD_CHARSET_NAME));\n+            logger.debug(\"connected to {}:{}\", config.hostname, config.tcpPort);\n+            panelReadyReceived = false;\n+            startMsgReader();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Start connection check job\n+            logger.debug(\"Scheduling connection check job with interval {} minutes.\", config.reconnect);\n+            lastReceivedTime = new Date();\n+            connectionCheckJob = scheduler.scheduleWithFixedDelay(this::connectionCheck, config.reconnect,\n+                    config.reconnect, TimeUnit.MINUTES);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"unknown hostname: {}\", config.hostname);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"unknown host\");\n+            disconnect();\n+        } catch (IOException e) {\n+            logger.debug(\"cannot open connection to {}:{} error: {}\", config.hostname, config.tcpPort, e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwMjUyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                    updateState(CHANNEL_KP_READY, OnOffType.from(kpm.getStatus(KeypadMessage.BIT_READY)));", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414802525", "createdAt": "2020-04-24T19:10:34Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/handler/KeypadHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.handler;\n+\n+import static org.openhab.binding.alarmdecoder.internal.AlarmDecoderBindingConstants.*;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.alarmdecoder.internal.config.KeypadConfig;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADCommand;\n+import org.openhab.binding.alarmdecoder.internal.protocol.ADMessage;\n+import org.openhab.binding.alarmdecoder.internal.protocol.IntCommandMap;\n+import org.openhab.binding.alarmdecoder.internal.protocol.KeypadMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link KeypadHandler} is responsible for handling keypad messages.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ * @author Bill Forsyth - Initial contribution\n+ */\n+@NonNullByDefault\n+public class KeypadHandler extends ADThingHandler {\n+\n+    private static final Pattern VALID_COMMAND_PATTERN = Pattern.compile(ADCommand.KEYPAD_COMMAND_REGEX);\n+\n+    private final Logger logger = LoggerFactory.getLogger(KeypadHandler.class);\n+\n+    private KeypadConfig config = new KeypadConfig();\n+    private boolean singleAddress;\n+    private @Nullable IntCommandMap intCommandMap;\n+    private @Nullable KeypadMessage previousMessage;\n+\n+    public KeypadHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(KeypadConfig.class);\n+\n+        if (config.addressMask < 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid addressMask setting\");\n+            return;\n+        }\n+        singleAddress = (Integer.bitCount(config.addressMask) == 1);\n+\n+        try {\n+            intCommandMap = new IntCommandMap(config.commandMapping);\n+        } catch (IllegalArgumentException e) {\n+            logger.warn(\"Invalid commmandMapping parameter supplied. Error: {}.\", e.getMessage());\n+            intCommandMap = null;\n+        }\n+\n+        logger.debug(\"Keypad handler initializing for address mask {}\", config.addressMask);\n+\n+        initDeviceState();\n+\n+        logger.trace(\"Keypad handler finished initializing\");\n+    }\n+\n+    @Override\n+    public void initChannelState() {\n+        previousMessage = null;\n+    }\n+\n+    @Override\n+    public void notifyPanelReady() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        IntCommandMap intCommandMap = this.intCommandMap;\n+\n+        if (channelUID.getId().equals(CHANNEL_KP_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = ((StringType) command).toString();\n+                handleKeypadCommand(cmd);\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_KP_INTCOMMAND)) {\n+            if (command instanceof Number) {\n+                int icmd = ((Number) command).intValue();\n+                if (intCommandMap != null) {\n+                    String cmd = intCommandMap.getCommand(icmd);\n+                    if (cmd != null) {\n+                        handleKeypadCommand(cmd);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void handleKeypadCommand(String command) {\n+        String cmd = command;\n+        if (cmd.length() > 0) {\n+            if (!config.sendCommands) {\n+                logger.info(\"Sending keypad commands is disabled. Enable using the sendCommands keypad parameter.\");\n+                return;\n+            }\n+\n+            // check that received command is valid\n+            Matcher matcher = VALID_COMMAND_PATTERN.matcher(cmd);\n+            if (!matcher.matches()) {\n+                logger.info(\"Invalid characters in command. Ignoring command: {}\", cmd);\n+                return;\n+            }\n+\n+            // Replace A-H in command string with special key strings\n+            cmd = cmd.replace(\"A\", ADCommand.SPECIAL_KEY_1);\n+            cmd = cmd.replace(\"B\", ADCommand.SPECIAL_KEY_2);\n+            cmd = cmd.replace(\"C\", ADCommand.SPECIAL_KEY_3);\n+            cmd = cmd.replace(\"D\", ADCommand.SPECIAL_KEY_4);\n+            cmd = cmd.replace(\"E\", ADCommand.SPECIAL_KEY_5);\n+            cmd = cmd.replace(\"F\", ADCommand.SPECIAL_KEY_6);\n+            cmd = cmd.replace(\"G\", ADCommand.SPECIAL_KEY_7);\n+            cmd = cmd.replace(\"H\", ADCommand.SPECIAL_KEY_8);\n+\n+            if (singleAddress) {\n+                sendCommand(ADCommand.addressedMessage(config.addressMask, cmd)); // send from keypad address\n+            } else {\n+                sendCommand(new ADCommand(cmd)); // send from AD address\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleUpdate(ADMessage msg) {\n+        // This will ignore a received message unless it is a KeypadMessage and either this handler's address mask is 0\n+        // (all), the message's address mask is 0 (all), or any bits in this handler's address mask match bits set in\n+        // the message's address mask.\n+        if (!(msg instanceof KeypadMessage)) {\n+            return;\n+        }\n+        KeypadMessage kpm = (KeypadMessage) msg;\n+        int addressMask = kpm.getIntAddressMask();\n+        if (!(((config.addressMask & addressMask) != 0) || config.addressMask == 0 || addressMask == 0)) {\n+            return;\n+        }\n+        logger.trace(\"Keypad handler for address mask {} received update: {}\", config.addressMask, kpm);\n+\n+        if (kpm.equals(previousMessage)) {\n+            return; // ignore repeated messages\n+        }\n+\n+        if (config.sendStar) {\n+            if (kpm.alphaMessage.contains(\"Hit * for faults\") || kpm.alphaMessage.contains(\"Press * to show faults\")\n+                    || kpm.alphaMessage.contains(\"Press * Key\")) {\n+                logger.debug(\"Sending * command to show faults.\");\n+                if (singleAddress) {\n+                    sendCommand(ADCommand.addressedMessage(config.addressMask, \"*\")); // send from keypad address\n+                } else {\n+                    sendCommand(new ADCommand(\"*\")); // send from AD address\n+                }\n+            }\n+        }\n+\n+        updateState(CHANNEL_KP_ZONE, new DecimalType(kpm.getZone()));\n+        updateState(CHANNEL_KP_TEXT, new StringType(kpm.alphaMessage));\n+\n+        updateState(CHANNEL_KP_READY, (kpm.getStatus(KeypadMessage.BIT_READY)) ? OnOffType.ON : OnOffType.OFF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwODIxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Serial or USB Port</label>\n          \n          \n            \n            \t\t\t\t<label>Serial Or USB Port</label>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414808214", "createdAt": "2020-04-24T19:21:11Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwODM4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n          \n          \n            \n            \t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device.</description>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414808388", "createdAt": "2020-04-24T19:21:30Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwODU4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n          \n          \n            \n            \t\t\t\t<description>Enable automatic discovery of zones and RF zones.</description>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414808588", "createdAt": "2020-04-24T19:21:53Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"bitrate\" type=\"integer\">\n+\t\t\t\t<label>Bitrate</label>\n+\t\t\t\t<default>115200</default>\n+\t\t\t\t<description>Speed of the serial connection</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwOTgwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Address</label>\n          \n          \n            \n            \t\t\t\t<description>Zone address</description>\n          \n          \n            \n            \t\t\t\t<label>Zone Address</label>\n          \n      \n    \n    \n  \n\nIf it's short enough, just use the label.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414809803", "createdAt": "2020-04-24T19:24:13Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"bitrate\" type=\"integer\">\n+\t\t\t\t<label>Bitrate</label>\n+\t\t\t\t<default>115200</default>\n+\t\t\t\t<description>Speed of the serial connection</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Zone Thing Type -->\n+\t<thing-type id=\"zone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Zone</label>\n+\t\t<description>Alarm Decoder REL or EXP zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"contact\" typeId=\"contact-channel\" />\n+\t\t</channels>\n+\n+\t\t<representation-property>id</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Zone address</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgwOTk0MQ==", "bodyText": "see above", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414809941", "createdAt": "2020-04-24T19:24:28Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"bitrate\" type=\"integer\">\n+\t\t\t\t<label>Bitrate</label>\n+\t\t\t\t<default>115200</default>\n+\t\t\t\t<description>Speed of the serial connection</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Zone Thing Type -->\n+\t<thing-type id=\"zone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Zone</label>\n+\t\t<description>Alarm Decoder REL or EXP zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"contact\" typeId=\"contact-channel\" />\n+\t\t</channels>\n+\n+\t\t<representation-property>id</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Zone address</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"channel\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Channel</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMDMxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<description>Keypad address mask</description>\n          \n          \n            \n            \t\t\t\t<description>Keypad address mask.</description>", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414810312", "createdAt": "2020-04-24T19:25:09Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"bitrate\" type=\"integer\">\n+\t\t\t\t<label>Bitrate</label>\n+\t\t\t\t<default>115200</default>\n+\t\t\t\t<description>Speed of the serial connection</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Zone Thing Type -->\n+\t<thing-type id=\"zone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Zone</label>\n+\t\t<description>Alarm Decoder REL or EXP zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"contact\" typeId=\"contact-channel\" />\n+\t\t</channels>\n+\n+\t\t<representation-property>id</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Zone address</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"channel\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Channel</label>\n+\t\t\t\t<description>Zone channel</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- RF Zone Thing Type -->\n+\t<thing-type id=\"rfzone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm RF Zone</label>\n+\t\t<description>Alarm Decoder RFX zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"lowbat\" typeId=\"system.low-battery\">\n+\t\t\t\t<label>Low Battery</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supervision\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Supervision Indicator</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop1\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop2\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop3\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop4\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 4</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\n+\t\t<representation-property>serial</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serial\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Serial</label>\n+\t\t\t\t<description>Serial number of the RF zone</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Keypad Thing Type -->\n+\t<thing-type id=\"keypad\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Keypad</label>\n+\t\t<description>Alarm Decoder keypad thing</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"zone\" typeId=\"number-channel\">\n+\t\t\t\t<label>Zone</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\">\n+\t\t\t\t<label>Keypad Message</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"ready\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Ready</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"armedaway\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Armed Away</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"armedhome\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Armed Stay</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"backlight\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Keypad Backlight</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"program\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Programming Mode</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"beeps\" typeId=\"number-channel\">\n+\t\t\t\t<label>Beeps</label>\n+\t\t\t\t<description>Number of beeps for message</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"bypassed\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Zone Bypassed</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"acpower\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>AC Power</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"chime\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Chime Enabled</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"alarmoccurred\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Alarm Occurred</label>\n+\t\t\t\t<description>Alarm has occurred in the past</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"alarm\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Alarm</label>\n+\t\t\t\t<description>Alarm is currently sounding</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"lowbat\" typeId=\"system.low-battery\">\n+\t\t\t\t<label>Low Battery</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"delayoff\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Entry Delay Off</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"fire\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Fire Detected</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sysfault\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>System Fault</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"perimeter\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Perimeter Only</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"command\" typeId=\"command-channel\">\n+\t\t\t\t<label>Keypad Command</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"intcommand\" typeId=\"int-command-channel\">\n+\t\t\t\t<label>Integer Mapped Keypad Command</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"addressMask\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address Mask</label>\n+\t\t\t\t<description>Keypad address mask</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMDc5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Contact</label>\n          \n          \n            \n            \t\t<description>Contact state</description>\n          \n          \n            \n            \t\t<label>Contact State</label>\n          \n      \n    \n    \n  \n\nAlso below", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414810796", "createdAt": "2020-04-24T19:25:59Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,330 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"alarmdecoder\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Alarm Decoder Bridge -->\n+\t<bridge-type id=\"ipbridge\">\n+\t\t<label>Alarm Decoder IP Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder IP Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostname\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host Name</label>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<description>The hostname or IP address of the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"tcpPort\" type=\"integer\">\n+\t\t\t\t<label>TCP Port</label>\n+\t\t\t\t<description>TCP port number for the Alarm Decoder connection</description>\n+\t\t\t\t<default>10000</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reconnect\" type=\"integer\" min=\"1\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Reconnect Interval</label>\n+\t\t\t\t<description>The period in minutes that the handler will wait between connection attempts and checks</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>2</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"timeout\" type=\"integer\" min=\"0\" max=\"60\" unit=\"min\">\n+\t\t\t\t<label>Message Receive Timeout</label>\n+\t\t\t\t<description>The period in minutes after which the connection will be reset if no valid messages have been received.\n+\t\t\t\t\tSet to 0 to disable.</description>\n+\t\t\t\t<unitLabel>minutes</unitLabel>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<bridge-type id=\"serialbridge\">\n+\t\t<label>Alarm Decoder Serial Bridge</label>\n+\t\t<description>Nu Tech Alarm Decoder Serial Bridge</description>\n+\t\t<properties>\n+\t\t\t<property name=\"vendor\">Nu Tech Software Solutions</property>\n+\t\t</properties>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Serial or USB Port</label>\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<description>The name of the serial port used to connect to the Alarm Decoder device</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"bitrate\" type=\"integer\">\n+\t\t\t\t<label>Bitrate</label>\n+\t\t\t\t<default>115200</default>\n+\t\t\t\t<description>Speed of the serial connection</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"discovery\" type=\"boolean\">\n+\t\t\t\t<label>Enable Discovery</label>\n+\t\t\t\t<description>Enable automatic discovery of zones and RF zones</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</bridge-type>\n+\n+\t<!-- Zone Thing Type -->\n+\t<thing-type id=\"zone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Zone</label>\n+\t\t<description>Alarm Decoder REL or EXP zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"contact\" typeId=\"contact-channel\" />\n+\t\t</channels>\n+\n+\t\t<representation-property>id</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"address\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Address</label>\n+\t\t\t\t<description>Zone address</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"channel\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Channel</label>\n+\t\t\t\t<description>Zone channel</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- RF Zone Thing Type -->\n+\t<thing-type id=\"rfzone\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm RF Zone</label>\n+\t\t<description>Alarm Decoder RFX zone</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"lowbat\" typeId=\"system.low-battery\">\n+\t\t\t\t<label>Low Battery</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"supervision\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Supervision Indicator</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop1\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 1</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop2\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 2</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop3\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 3</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"loop4\" typeId=\"contact-channel\">\n+\t\t\t\t<label>Loop 4</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\n+\t\t<representation-property>serial</representation-property>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serial\" type=\"integer\" required=\"true\">\n+\t\t\t\t<label>Serial</label>\n+\t\t\t\t<description>Serial number of the RF zone</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- Keypad Thing Type -->\n+\t<thing-type id=\"keypad\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Alarm Keypad</label>\n+\t\t<description>Alarm Decoder keypad thing</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"zone\" typeId=\"number-channel\">\n+\t\t\t\t<label>Zone</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"text\" typeId=\"text-channel\">\n+\t\t\t\t<label>Keypad Message</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"ready\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Ready</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"armedaway\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Armed Away</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"armedhome\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Armed Stay</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"backlight\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Keypad Backlight</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"program\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Programming Mode</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"beeps\" typeId=\"number-channel\">\n+\t\t\t\t<label>Beeps</label>\n+\t\t\t\t<description>Number of beeps for message</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"bypassed\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Zone Bypassed</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"acpower\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>AC Power</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"chime\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Chime Enabled</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"alarmoccurred\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Alarm Occurred</label>\n+\t\t\t\t<description>Alarm has occurred in the past</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"alarm\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Alarm</label>\n+\t\t\t\t<description>Alarm is currently sounding</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"lowbat\" typeId=\"system.low-battery\">\n+\t\t\t\t<label>Low Battery</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"delayoff\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Entry Delay Off</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"fire\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Fire Detected</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sysfault\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>System Fault</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"perimeter\" typeId=\"indicator-channel\">\n+\t\t\t\t<label>Perimeter Only</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"command\" typeId=\"command-channel\">\n+\t\t\t\t<label>Keypad Command</label>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"intcommand\" typeId=\"int-command-channel\">\n+\t\t\t\t<label>Integer Mapped Keypad Command</label>\n+\t\t\t</channel>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"addressMask\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Address Mask</label>\n+\t\t\t\t<description>Keypad address mask</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sendCommands\" type=\"boolean\">\n+\t\t\t\t<label>Send Commands</label>\n+\t\t\t\t<description>Allow keypad commands to be sent to the alarm system from openHAB. Enabling this means the alarm system\n+\t\t\t\t\twill be only as secure as your openHAB system.</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"sendStar\" type=\"boolean\">\n+\t\t\t\t<label>Send * for Fault Info</label>\n+\t\t\t\t<description>When disarmed, automatically send * character to obtain zone fault information.</description>\n+\t\t\t\t<default>false</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"commandMapping\" type=\"text\">\n+\t\t\t\t<label>Command Mapping for intcommand Channel</label>\n+\t\t\t\t<description>Comma separated list of key/value pairs mapping integers to command strings for intcommand channel.</description>\n+\t\t\t\t<default>0=0,1=1,2=2,3=3,4=4,5=5,6=6,7=7,8=8,9=9,10=*,11=#</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<!-- LRR Thing Type -->\n+\t<thing-type id=\"lrr\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"ipbridge\" />\n+\t\t\t<bridge-type-ref id=\"serialbridge\" />\n+\t\t</supported-bridge-type-refs>\n+\n+\t\t<label>Long Range Radio</label>\n+\t\t<description>Long range radio message handler</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"partition\" typeId=\"number-channel\">\n+\t\t\t\t<label>Partition</label>\n+\t\t\t\t<description>Partition number (0 = System)</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"eventdata\" typeId=\"number-channel\">\n+\t\t\t\t<label>Event Data</label>\n+\t\t\t\t<description>CID event data (user or zone)</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"cidmessage\" typeId=\"text-channel\">\n+\t\t\t\t<label>CID Message</label>\n+\t\t\t\t<description>SIA Contact ID Protocol message</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"reportcode\" typeId=\"text-channel\">\n+\t\t\t\t<label>Report Code</label>\n+\t\t\t\t<description>CID report code</description>\n+\t\t\t</channel>\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"partition\" type=\"integer\">\n+\t\t\t\t<label>Partition</label>\n+\t\t\t\t<description>Partition for which to receive LRR events (0=All)</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<!-- ===== Channel Type Definitions ===== -->\n+\n+\t<!-- Contact Channel Type -->\n+\t<channel-type id=\"contact-channel\">\n+\t\t<item-type>Contact</item-type>\n+\t\t<label>Contact</label>\n+\t\t<description>Contact state</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxMTUxNQ==", "bodyText": "After reading the code below, this seems to be an invalid value. Leave it out if that is correct", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r414811515", "createdAt": "2020-04-24T19:27:28Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/src/main/java/org/openhab/binding/alarmdecoder/internal/config/RFZoneConfig.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.alarmdecoder.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link RFZoneConfig} class contains fields mapping thing configuration parameters for RFZoneHandler.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RFZoneConfig {\n+    public int serial = -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96149fa6df32bfe52e14a63a7170e25596d7b9ca", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/96149fa6df32bfe52e14a63a7170e25596d7b9ca", "committedDate": "2020-04-24T23:51:50Z", "message": "[alarmecoder] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09de463dbcb35337177de90b967e8f4727c840ca", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/09de463dbcb35337177de90b967e8f4727c840ca", "committedDate": "2020-04-25T00:57:25Z", "message": "[alarmecoder] And a couple more\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzc3NDc3", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-400377477", "createdAt": "2020-04-25T09:43:19Z", "commit": {"oid": "09de463dbcb35337177de90b967e8f4727c840ca"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTo0MzoxOVrOGLzLjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwOTo0NDo1MVrOGLzMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNjA2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the bridge *discovery* parameter is set to *true*, the first time a status message is seen from each zone or RF zone a corresponding thing will appear in the inbox.\n          \n          \n            \n            If the bridge `discovery` parameter is set to `true`, the first time a status message is seen from each zone or RF zone a corresponding thing will appear in the inbox.\n          \n      \n    \n    \n  \n\nThere are much more occurences.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r415026062", "createdAt": "2020-04-25T09:43:19Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/README.md", "diffHunk": "@@ -0,0 +1,267 @@\n+# Alarm Decoder Binding\n+\n+The [Alarm Decoder](http://www.alarmdecoder.com) from Nu Tech Software Solutions is a hardware adapter that interfaces with Ademco/Honeywell and DSC alarm panels.\n+It acts essentially like a keypad, reading and writing messages on the serial bus that connects keypads with the main panel.\n+\n+There are several versions of the adapter available: \n+\n+* *AD2PI* or *AD2PHAT* - A board that plugs into a Raspberry Pi and offers network-based TCP connectivity\n+* *AD2SERIAL* - Attaches to a host via a serial port\n+* *AD2USB* - Attaches to a host via USB\n+\n+This binding allows openHAB to access the state of wired or wireless contacts and motion detectors connected to supported alarm panels, as well as the state of attached keypads and the messages send to attached LRR devices.\n+Support is also available for sending keypad commands, including special/programmable keys supported by your panel.\n+\n+For those upgrading from the OH1 version of the binding, the [original OH1 README](doc/README_OH1.md) file is available for reference.\n+\n+## Supported Things\n+\n+The binding supports the following thing types:\n+\n+* `ipbridge` - Supports TCP connection to the AD.\n+* `serialbridge` - Supports serial/USB connection to the AD.\n+* `keypad` - Reports keypad status and optionally sends keypad messages.\n+* `zone` - Reports status from zone expanders and relay expanders, and also from built-in zones via emulation.\n+* `rfzone` - Reports status from RF zones.\n+* `lrr` - Reports messages sent from the panel to a Long Range Radio (LRR) or emulated LRR device.\n+\n+## Discovery\n+\n+Background discovery is currently supported for **zone** and **rfzone** things.\n+If the bridge *discovery* parameter is set to *true*, the first time a status message is seen from each zone or RF zone a corresponding thing will appear in the inbox.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09de463dbcb35337177de90b967e8f4727c840ca"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyNjI3Mw==", "bodyText": "But why is this needed at all?", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r415026273", "createdAt": "2020-04-25T09:44:51Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.alarmdecoder/doc/README_OH1.md", "diffHunk": "@@ -0,0 +1,264 @@\n+# Alarm Decoder Binding", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc1NTE0MA=="}, "originalCommit": {"oid": "09dcd28ca6a4f6bae03b7ffc888f607a2084fccd"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f30d0ba54af3e2013d2e179035187e840e5be72", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/1f30d0ba54af3e2013d2e179035187e840e5be72", "committedDate": "2020-04-26T00:09:51Z", "message": "[alarmecoder] Address more comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "448031fecb6a720084a72c9f375ecac0fa1d615e", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/448031fecb6a720084a72c9f375ecac0fa1d615e", "committedDate": "2020-04-27T17:19:02Z", "message": "[alarmecoder] Address two comments I had missed\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMTI4NjUz", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-402128653", "createdAt": "2020-04-28T19:04:25Z", "commit": {"oid": "448031fecb6a720084a72c9f375ecac0fa1d615e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOTowNDoyNVrOGNiuBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOTowNDoyNVrOGNiuBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1MzUwOQ==", "bodyText": "Did @berndpfrommer recently work on this binding? Since the CODEOWNERS is used to request reviewers, we should stick to those people that recenetly did major work on that code.", "url": "https://github.com/openhab/openhab-addons/pull/7189#discussion_r416853509", "createdAt": "2020-04-28T19:04:25Z", "author": {"login": "J-N-K"}, "path": "CODEOWNERS", "diffHunk": "@@ -7,6 +7,7 @@\n # Add-on maintainers:\n /bundles/org.openhab.binding.airquality/ @kubawolanin\n /bundles/org.openhab.binding.airvisualnode/ @3cky\n+/bundles/org.openhab.binding.alarmdecoder/ @bobadair @billfor @berndpfrommer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "448031fecb6a720084a72c9f375ecac0fa1d615e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "490f62138745e3d9411b2f34a18d90ed64ecae47", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/490f62138745e3d9411b2f34a18d90ed64ecae47", "committedDate": "2020-04-29T01:56:59Z", "message": "[alarmecoder] README file updates\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODI3ODg0", "url": "https://github.com/openhab/openhab-addons/pull/7189#pullrequestreview-402827884", "createdAt": "2020-04-29T16:17:38Z", "commit": {"oid": "490f62138745e3d9411b2f34a18d90ed64ecae47"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1209, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}