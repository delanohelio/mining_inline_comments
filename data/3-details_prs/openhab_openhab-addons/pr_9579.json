{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NDg2MTk3", "number": 9579, "title": "[WlanThermo] Add support for new Nano V3, Mini V3, Link V1, Mini V1/V2(ESP32) devices [V3.x]", "bodyText": "This PR adds support for the new Nano V3, Mini V2 (with ESP32-Upgrade), and Link V1 devices.\n\n\nThe API of these hardware versions has changed compared to the previous devices, but is the same for the whole new platform (thus named \"esp32\").  This commit follows the same approach as the initial contribution and contains auto-generated classes for parsing the new JSON output.\nThe thing description xml has been spit up to different files to ease the future development.\nNo further changes to existing things, thus backwards compatible.\nConfiguration of different thing types has been merged to avoid duplicate code.\nBackport of changes to 2.5.x branch via PR #9580 (same changes)", "createdAt": "2020-12-29T13:29:51Z", "url": "https://github.com/openhab/openhab-addons/pull/9579", "merged": true, "mergeCommit": {"oid": "d8e5a57de9d55521ab32abc5e69626d1518d9213"}, "closed": true, "closedAt": "2021-01-18T23:58:21Z", "author": {"login": "CSchlipp"}, "timelineItems": {"totalCount": 50, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdrh1aNgFqTU2MDMxNDU2MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdxdkIPAH2gAyNTQ2NDg2MTk3OjdiMTVmZjkwMTc2NjY2OWM0NTViYzY5YTJjOWU1NWJkZjMzZGE4ZGI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMzE0NTYx", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-560314561", "createdAt": "2020-12-31T10:10:08Z", "commit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxMDowOFrOIM8rZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDo1NjoxMFrOIM9PKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0Nzk3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import java.awt.*;\n          \n          \n            \n            import java.awt.Color;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550447975", "createdAt": "2020-12-31T10:10:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTYzNQ==", "bodyText": "You can avoid the compiler warning by specifying the wildcard. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType) command).doubleValue());\n          \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550449635", "createdAt": "2020-12-31T10:18:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+        if (data == null || settings == null) {\n+            return null;\n+        }\n+        System system = data.getSystem();\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(channelUID.getGroupId()) && system != null) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new DecimalType(system.getRssi());\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new DecimalType(channel.get(channelId).getTemp());\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new DecimalType(channel.get(channelId).getMin());\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new DecimalType(channel.get(channelId).getMax());\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new DecimalType(pm.getSet());\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType) command).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1Mjk0OA==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550452948", "createdAt": "2020-12-31T10:34:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzA2MA==", "bodyText": "The log message could be removed, as the status update is already logged by the framework. The state change originated by updateStatus() is logged to events.log. Including the status detail message. Please check all.\nYou could mention, that the URL is incorrect in the message.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453060", "createdAt": "2020-12-31T10:35:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzQ1NA==", "bodyText": "You could append the exception's message. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress());\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453454", "createdAt": "2020-12-31T10:37:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDEyNg==", "bodyText": "You could initialize the config parameters in the config class to be able to remove the Nullable declaration. Or store config.getUsername() to a local variable here and do the null check on that.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454126", "createdAt": "2020-12-31T10:40:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDE5MQ==", "bodyText": "Please add curly brackets.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454191", "createdAt": "2020-12-31T10:41:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA==", "bodyText": "Is there a reason why these are Nullable?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454414", "createdAt": "2020-12-31T10:42:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454725", "createdAt": "2020-12-31T10:44:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ==", "bodyText": "BaseThingHandler provides a scheduler. Is there any reason not using that?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455289", "createdAt": "2020-12-31T10:46:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTM5Ng==", "bodyText": "You could move this into a package called dto or append DTO to the class name to get rid of the checkstyle warning about missing NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455396", "createdAt": "2020-12-31T10:47:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/data/Channel.java", "diffHunk": "@@ -0,0 +1,125 @@\n+\n+package org.openhab.binding.wlanthermo.internal.api.esp32.data;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTg2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Openhab Alarm Trigger</label>\n          \n          \n            \n            \t\t<label>OpenHAB Alarm Trigger</label>", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455860", "createdAt": "2020-12-31T10:49:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTk5NA==", "bodyText": "Do you mean pink?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455994", "createdAt": "2020-12-31T10:50:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjA4MA==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions\nPlease check all.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456080", "createdAt": "2020-12-31T10:50:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjIzMQ==", "bodyText": "Can this be either removed or checked if it's supported?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456231", "createdAt": "2020-12-31T10:51:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Pitmaster State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<!--<option value=\"autotune\">Autotune</option> Not clear if still supported -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NjgzOA==", "bodyText": "You could make this Number:Power and use Units.DECIBEL_MILLIWATTS.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550456838", "createdAt": "2020-12-31T10:54:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,261 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>Openhab Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Probe Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Probe Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Pitmaster Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Pitmaster State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<!--<option value=\"autotune\">Autotune</option> Not clear if still supported -->\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pid_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>PID Profile ID</label>\n+\t\t<state pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Pitmaster Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Pitmaster Channel ID</label>\n+\t\t<state min=\"1\" max=\"8\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NzEzMQ==", "bodyText": "Labels are expected to be as short as possible. Guideline is 2-3 words with max 20-25 chars. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550457131", "createdAt": "2020-12-31T10:56:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/thing-types-mini.xml", "diffHunk": "@@ -0,0 +1,79 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\n+\t<thing-type id=\"mini\">\n+\t\t<label>WlanThermo Mini V1/V2 (Raspberry Pi)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd"}, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d8198157422913730de85f90ef717e523e063bd", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1d8198157422913730de85f90ef717e523e063bd", "committedDate": "2020-12-29T12:45:35Z", "message": "Fix Compiler warnings in V3 branch\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}, "afterCommit": {"oid": "b164d7b9377bcc6175b9fd74436ce847a5e7035e", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b164d7b9377bcc6175b9fd74436ce847a5e7035e", "committedDate": "2020-12-31T13:56:28Z", "message": "moved auto-generated classed to dto package\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a18317f9b5e08b780468921a61707f3d62636e4", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8a18317f9b5e08b780468921a61707f3d62636e4", "committedDate": "2021-01-03T14:54:41Z", "message": "Add support for ESP32 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31a5d04ddc3a6b5c5530363b73518b70b46303e5", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/31a5d04ddc3a6b5c5530363b73518b70b46303e5", "committedDate": "2021-01-03T14:54:41Z", "message": "Fix Compiler warnings in V3 branch\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24680ba232d62a1bb28892e9632f216121a82d56", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/24680ba232d62a1bb28892e9632f216121a82d56", "committedDate": "2021-01-03T14:56:27Z", "message": "moved auto-generated classed to dto package\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f85970721a73f875c0e7f888444f4bd599b88be", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7f85970721a73f875c0e7f888444f4bd599b88be", "committedDate": "2021-01-03T14:56:27Z", "message": "fix typo\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56623060fc6c0346948b5ecc97627300ef287e35", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/56623060fc6c0346948b5ecc97627300ef287e35", "committedDate": "2021-01-03T14:56:27Z", "message": "fix imports\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd494b93fa407635a654b993dd849c6a03a02db2", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/dd494b93fa407635a654b993dd849c6a03a02db2", "committedDate": "2021-01-03T14:56:27Z", "message": "reduce logs\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3021e06e7f6c899842f084c0c2cc5c8eea463b6b", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3021e06e7f6c899842f084c0c2cc5c8eea463b6b", "committedDate": "2021-01-03T14:56:27Z", "message": "fix formatting\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6356ac26707482ce6a377110fd5e793d92ba2f2d", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6356ac26707482ce6a377110fd5e793d92ba2f2d", "committedDate": "2021-01-03T14:56:27Z", "message": "removed nullable config\nfurther improved logging\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5855a565f6fb3de2edff5ba030b60a3fbb7ce64c", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5855a565f6fb3de2edff5ba030b60a3fbb7ce64c", "committedDate": "2021-01-03T14:56:28Z", "message": "Only log payload if response code != 200\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c76ecfa4f6bcf829e1f5ab85934b3b899e5f19d5", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c76ecfa4f6bcf829e1f5ab85934b3b899e5f19d5", "committedDate": "2021-01-03T14:56:28Z", "message": "fix compiler warnings\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db1da51cd9206457e0698940eb1a011df6b810b7", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/db1da51cd9206457e0698940eb1a011df6b810b7", "committedDate": "2021-01-03T14:56:28Z", "message": "fix channel naming\nSpecify Quantity Type for Temperature and Power Channels\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebe40119d018ca06ae6ae62abd3bd4ceb904b10f", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ebe40119d018ca06ae6ae62abd3bd4ceb904b10f", "committedDate": "2021-01-03T14:56:28Z", "message": "fixed checkstyle error\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c675da78571adef398e029f3b19d71bd371539e5", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c675da78571adef398e029f3b19d71bd371539e5", "committedDate": "2021-01-03T14:56:28Z", "message": "Add license headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65628c952508831cf4eedea0f2250001f60b2c24", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/65628c952508831cf4eedea0f2250001f60b2c24", "committedDate": "2021-01-03T15:00:21Z", "message": "Rebase & Update License Headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae80ec0cde8455971921f5ca4cba519a447b0558", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ae80ec0cde8455971921f5ca4cba519a447b0558", "committedDate": "2021-01-01T17:14:23Z", "message": "Add license headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}, "afterCommit": {"oid": "65628c952508831cf4eedea0f2250001f60b2c24", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/65628c952508831cf4eedea0f2250001f60b2c24", "committedDate": "2021-01-03T15:00:21Z", "message": "Rebase & Update License Headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d365c2394c4bdbb05a5b2df3823137f1b15a6ab4", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d365c2394c4bdbb05a5b2df3823137f1b15a6ab4", "committedDate": "2021-01-03T15:39:05Z", "message": "Fix scheduled task not cancelled on dispose\nRevert to default scheduler\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/aff5cb5d1d4586abbf71161d45993b63d09ab438", "committedDate": "2021-01-04T21:22:08Z", "message": "Retrigger Jenkins build\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDAxNjQx", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-563001641", "createdAt": "2021-01-06T19:58:46Z", "commit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTkzMTA0", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-562993104", "createdAt": "2021-01-06T19:44:55Z", "commit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxOTo0NDo1NVrOIPT9yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDo0NDozNFrOIPVigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNjY2Nw==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552926667", "createdAt": "2021-01-06T19:44:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/UtilEsp32.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilEsp32} class provides conversion functions for the WlanThermo Nano V3\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilEsp32 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzE2OQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927169", "createdAt": "2021-01-06T19:45:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzQ2OA==", "bodyText": "You should make this DecimalType instances static final fields so you can reuse them.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927468", "createdAt": "2021-01-06T19:46:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODY0MQ==", "bodyText": "Please cache channel.get(channelId) to a local variable.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928641", "createdAt": "2021-01-06T19:49:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODkwOA==", "bodyText": "Typo?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n          \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getType()).getName());", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928908", "createdAt": "2021-01-06T19:49:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyOTc2MA==", "bodyText": "Instead of assigning the return variable and then breaking, it would simplify the code in this method to just return the state immediately where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        state = UnDefType.UNDEF;\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    break;\n          \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        return UnDefType.UNDEF;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    return new QuantityType<>(channel.get(channelId).getTemp(), unit);", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552929760", "createdAt": "2021-01-06T19:51:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzMjQ3Nw==", "bodyText": "Always try to call .equals on the constant so you can avoid accidental NPEs.\nAlso this seems like a good place to use the ternary operator as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Unit<Temperature> unit;\n          \n          \n            \n                    if (system.getUnit().equals(\"F\")) {\n          \n          \n            \n                        unit = ImperialUnits.FAHRENHEIT;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        // Default to Celsius\n          \n          \n            \n                        unit = SIUnits.CELSIUS;\n          \n          \n            \n                    }\n          \n          \n            \n                    Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552932477", "createdAt": "2021-01-06T19:56:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDMwMw==", "bodyText": "You should make sure that the unit of the incoming quantity type is what you expect. Use QuantityType.toUnit to get a QuantityType instance with your expected unit.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934303", "createdAt": "2021-01-06T19:59:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA==", "bodyText": "Using the && operator would reduce the amount of nested indentation going on here.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934848", "createdAt": "2021-01-06T20:01:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).doubleValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            success = true;\n+                        }\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    public String getTrigger(ChannelUID channelUID, Data data) {\n+        String trigger = null;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return null;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.get(channelId).getTemp() != 999) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTE5Mg==", "bodyText": "These channel ids should be constants specified in your WlanThermoBindingConstants file.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935192", "createdAt": "2021-01-06T20:02:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTcyOQ==", "bodyText": "Any reason this couldn't be static final?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935729", "createdAt": "2021-01-06T20:03:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjIzNA==", "bodyText": "This class is stateless, so I see no reason you couldn't make all of it's method static.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public State getState(ChannelUID channelUID, Data data, Settings settings) {\n          \n          \n            \n                public static State getState(ChannelUID channelUID, Data data, Settings settings) {", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936234", "createdAt": "2021-01-06T20:04:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjQzNA==", "bodyText": "This declaration can go away once you make all the methods static.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936434", "createdAt": "2021-01-06T20:05:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzOTMzNA==", "bodyText": "Can you merge the checkConnection and update methods into a single method so that you only require a single period task to be set during initialize? Things can go wrong if you are assigning the pollingScheduler field in other threads outside of the initialize and dispose methods.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552939334", "createdAt": "2021-01-06T20:12:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDMxNQ==", "bodyText": "A communication error should be an offline status.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n      \n    \n    \n  \n\nAlso if there is a credential problem here, why would you continue to send post requests for the other channels? That would just spam the logs with a bunch of failed auth attempts.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940315", "createdAt": "2021-01-06T20:14:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDUxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940513", "createdAt": "2021-01-06T20:15:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDU5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940591", "createdAt": "2021-01-06T20:15:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjA3MA==", "bodyText": "So the mini uses \"fahrenheit\" instead of \"F\"?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552942070", "createdAt": "2021-01-06T20:18:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -33,7 +36,21 @@\n \n     public State getState(ChannelUID channelUID, App app) {\n         State state = null;\n-        if (\"system\".equals(channelUID.getGroupId())) {\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || app == null) {\n+            return null;\n+        }\n+\n+        Unit<Temperature> unit;\n+        if (app.getTempUnit().equals(\"fahrenheit\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzczOA==", "bodyText": "Why is this category Text?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552943738", "createdAt": "2021-01-06T20:23:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<channel-type id=\"cpu_load\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>CPU Load</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Name</label>\n+\t\t<category>Text</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"name_ro\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"typ\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Type</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Current Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"false\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_min_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_max_ro\" advanced=\"true\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" step=\"0.1\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_device_ro\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Alarm Buzzer</label>\n+\t\t<category>Switch</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_push\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Push-Alarm</label>\n+\t\t<category>Switch</category>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab\" advanced=\"true\">\n+\t\t<kind>trigger</kind>\n+\t\t<label>OpenHAB Alarm Trigger</label>\n+\t\t<event>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"MIN\">Low Temperature Alarm</option>\n+\t\t\t\t<option value=\"MAX\">High Temperature Alarm</option>\n+\t\t\t</options>\n+\t\t</event>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_low\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Low Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"alarm_openhab_high\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>High Temperature Alarm</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_nano\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"niagara\">Niagara</option>\n+\t\t\t\t<option value=\"rosa\">Rosa</option>\n+\t\t\t\t<option value=\"lapis blue\">Lapis Blue</option>\n+\t\t\t\t<option value=\"orange\">Orange</option>\n+\t\t\t\t<option value=\"lila\">Lila</option>\n+\t\t\t\t<option value=\"red\">Red</option>\n+\t\t\t\t<option value=\"green\">Green</option>\n+\t\t\t\t<option value=\"gold\">Gold</option>\n+\t\t\t\t<option value=\"kale\">Kale</option>\n+\t\t\t\t<option value=\"brown\">Brown</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_esp32\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"#FFFF00\">yellow</option>\n+\t\t\t\t<option value=\"#FFC002\">dark yellow</option>\n+\t\t\t\t<option value=\"#00FF00\">green</option>\n+\t\t\t\t<option value=\"#FFFFFF\">white</option>\n+\t\t\t\t<option value=\"#FF1DC4\">pink</option>\n+\t\t\t\t<option value=\"#E46C0A\">orange</option>\n+\t\t\t\t<option value=\"#C3D69B\">olive</option>\n+\t\t\t\t<option value=\"#0FE6F1\">light blue</option>\n+\t\t\t\t<option value=\"#0000FF\">blue</option>\n+\t\t\t\t<option value=\"#03A923\">dark green</option>\n+\t\t\t\t<option value=\"#C84B32\">brown</option>\n+\t\t\t\t<option value=\"#FF9B69\">light brown</option>\n+\t\t\t\t<option value=\"#5082BE\">dark blue</option>\n+\t\t\t\t<option value=\"#FFB1D0\">light pink</option>\n+\t\t\t\t<option value=\"#A6EF03\">light green</option>\n+\t\t\t\t<option value=\"#D42A6B\">dark pink</option>\n+\t\t\t\t<option value=\"#FFDA8F\">beige</option>\n+\t\t\t\t<option value=\"#00B0F0\">azure</option>\n+\t\t\t\t<option value=\"#948A54\">dark olive</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_ro\" advanced=\"true\">\n+\t\t<item-type>Color</item-type>\n+\t\t<label>Color</label>\n+\t\t<category>Colorpicker</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"color_name_mini_ro\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Color Name</label>\n+\t\t<category>Text</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"enabled\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Enabled</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint_ro\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"lid_open\" advanced=\"false\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Lid Open</label>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id_ro\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Channel ID</label>\n+\t\t<state min=\"0\" max=\"9\" pattern=\"%d\" readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pitmaster_type\" advanced=\"false\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>State</label>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"off\">Off</option>\n+\t\t\t\t<option value=\"manual\">Manual</option>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"duty_cycle\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Duty Cycle / Control Out</label>\n+\t\t<state min=\"0\" max=\"100\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pid_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>PID Profile ID</label>\n+\t\t<state pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temperature_setpoint\" advanced=\"false\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Setpoint Temperature</label>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"0\" pattern=\"%.1f %unit%\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"channel_id\" advanced=\"false\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature Channel ID</label>\n+\t\t<state min=\"1\" pattern=\"%d\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"charging\" advanced=\"true\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Charging</label>\n+\t\t<category>Energy</category>\n+\t\t<state readOnly=\"true\"/>\n+\t</channel-type>\n+\n+\t<channel-type id=\"rssi\" advanced=\"true\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>RSSI in dBm</label>\n+\t\t<category>Text</category>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0OTM2OQ==", "bodyText": "Since the group types are each meant for a specific thing type, why not define the group types in the thing type files instead?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552949369", "createdAt": "2021-01-06T20:36:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/resources/OH-INF/thing/channel-group-types-esp32.xml", "diffHunk": "@@ -0,0 +1,51 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"wlanthermo\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- System Group ESP32 -->\n+\t<channel-group-type id=\"cg_system_esp32\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTAwNA==", "bodyText": "Since handleCommand is called from UI threads you shouldn't make them execute potentially long running tasks like http requests. I suggest calling push asynchronously to prevent the UI from becoming unresponsive.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552951004", "createdAt": "2021-01-06T20:40:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjA1NQ==", "bodyText": "An you exit the push method as soon as possible if you catch an InterruptedException since that means that openhab is trying to shutdown. You should not delay shutdown if at all possible.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952055", "createdAt": "2021-01-06T20:43:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjQ0OQ==", "bodyText": "To exit early you will need to change this to regular for-each loop.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952449", "createdAt": "2021-01-06T20:44:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "609d21312e7597805de74b705a7ffd9d94615c2b", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/609d21312e7597805de74b705a7ffd9d94615c2b", "committedDate": "2021-01-09T11:26:46Z", "message": "fix constants\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f1f5e95b09eb675b431d87e333149fcf9a0a72f", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6f1f5e95b09eb675b431d87e333149fcf9a0a72f", "committedDate": "2021-01-09T11:50:39Z", "message": "make Util classes NonNullByDefault\nMake CommandHandlers static\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81fc86a2883a8d99f91c6534ce57b680692bfb24", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/81fc86a2883a8d99f91c6534ce57b680692bfb24", "committedDate": "2021-01-09T16:46:16Z", "message": "Rework CommandHandler Returns\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "182345803d527b479c19f1b80125cc15ca25ad6a", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/182345803d527b479c19f1b80125cc15ca25ad6a", "committedDate": "2021-01-09T16:50:06Z", "message": "Set Thing status to OFFLINE on Communication Error\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00908e75982933f14f4783c274490db04a32c59d", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/00908e75982933f14f4783c274490db04a32c59d", "committedDate": "2021-01-09T16:55:26Z", "message": "Don't try to update other channels if one fails due to wrong credentials\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1089575be5b391b0194bfaf615a0dfca9d6c012", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d1089575be5b391b0194bfaf615a0dfca9d6c012", "committedDate": "2021-01-09T17:05:34Z", "message": "Exit immediately if interrupted\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a32b382d5e39365e3a1cdc89f26bae61546ef58", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7a32b382d5e39365e3a1cdc89f26bae61546ef58", "committedDate": "2021-01-09T17:23:00Z", "message": "merge checkConnection and update method\nexecute push method with scheduler\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2f971b82b6db4f4accb916f8eb8bc86fd7c31c5", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b2f971b82b6db4f4accb916f8eb8bc86fd7c31c5", "committedDate": "2021-01-09T17:25:23Z", "message": "change rssi channel to category Number\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7de6f611d3430ed1fc232d321e98cfe9be1ccef", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a7de6f611d3430ed1fc232d321e98cfe9be1ccef", "committedDate": "2021-01-10T21:30:51Z", "message": "Improve Exception handling\nFix Triggers not working anymore after code modifications\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3dab0e24208697fa824c7ae766fded8d19c00bc", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c3dab0e24208697fa824c7ae766fded8d19c00bc", "committedDate": "2021-01-12T23:47:09Z", "message": "Make Pitmaster values writeable for ESP32 and NanoV1\nImmediately update values if connected\nSupport setting HEX Colors for ESP32\nSupport Additional Pitmaster channels for ESP32\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c1c9ac7f28764809641c2454e814ea14e9f54724", "committedDate": "2021-01-13T17:36:46Z", "message": "Only push changes if thing is ONLINE\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3Njc1ODQx", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-567675841", "createdAt": "2021-01-13T21:37:29Z", "commit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTozNzozMFrOITDtgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QyMTo1ODowNFrOITFGng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NDY1Nw==", "bodyText": "I'd think that you would return something here just to avoid throwing a WlanThermoUnknownChannelException since it is clear at this point in the code that the channel is actually known.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556854657", "createdAt": "2021-01-13T21:37:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        List<Channel> channelList = data.getChannel();\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        return new DecimalType(system.getSoc());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        return OnOffType.from(system.getCharge());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList != null && channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.getSensors().get(channel.getTyp()).getName());\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilEsp32.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        if (command instanceof HSBType) {\n+                            channel.setColor(UtilEsp32.toHex((HSBType) command));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PITMASTER_PREFIX.length())) - 1;\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > channelId) {\n+                Pm pm = data.getPitmaster().getPm().get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            return true;\n+                        }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable Data data)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.getTemp() != 999) {\n+                        if (channel.getTemp() > channel.getMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (channel.getTemp() < channel.getMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NTk1Mw==", "bodyText": "You should return at this point to that you don't continue to query the other channels.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556855953", "createdAt": "2021-01-13T21:38:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1ODc0NA==", "bodyText": "see earlier comment.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556858744", "createdAt": "2021-01-13T21:41:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.mini.dto.builtin.*;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoMiniCommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniCommandHandler {\n+\n+    public static final String ERROR = \"er\";\n+\n+    public static State getState(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        Unit<Temperature> unit = \"fahrenheit\".equals(app.getTempUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.SYSTEM_CPU_TEMP:\n+                    if (app.getCpuTemp() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuTemp());\n+                    }\n+                case WlanThermoBindingConstants.SYSTEM_CPU_LOAD:\n+                    if (app.getCpuLoad() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuLoad());\n+                    }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length()));\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    return UnDefType.UNDEF;\n+                }\n+                Data data = channel.getData(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case WlanThermoBindingConstants.CHANNEL_NAME:\n+                        return new StringType(data.getName());\n+                    case WlanThermoBindingConstants.CHANNEL_TEMP:\n+                        if (data.getState().equals(ERROR)) {\n+                            return UnDefType.UNDEF;\n+                        } else {\n+                            return new QuantityType<>(data.getTemp(), unit);\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_MIN:\n+                        return new QuantityType<>(data.getTempMin(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_MAX:\n+                        return new QuantityType<>(data.getTempMax(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(data.getAlert());\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() > data.getTempMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() < data.getTempMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR:\n+                        Color c = Color.decode(UtilMini.toHex(data.getColor()));\n+                        return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR_NAME:\n+                        return new StringType(data.getColor());\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            Pit pit;\n+            if (groupId.equals(CHANNEL_PITMASTER_1)) {\n+                pit = app.getPit();\n+            } else if (groupId.equals(CHANNEL_PITMASTER_2)) {\n+                pit = app.getPit2();\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+            if (pit == null || !pit.getEnabled()) {\n+                return UnDefType.UNDEF;\n+            }\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED:\n+                    return OnOffType.from(pit.getEnabled());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT:\n+                    return new DecimalType(pit.getCurrent());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT:\n+                    return new QuantityType<>(pit.getSetpoint(), unit);\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE:\n+                    return new DecimalType(pit.getControlOut());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN:\n+                    return OnOffType.from(pit.getOpenLid().equals(\"True\"));\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID:\n+                    return new DecimalType(pit.getCh());\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    throw new WlanThermoInputException();\n+                }\n+                Data data = channel.getData(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (!data.getState().equals(ERROR)) {\n+                        if (data.getTemp() > data.getTempMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (data.getTemp() < data.getTempMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDg2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556864869", "createdAt": "2021-01-13T21:46:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg==", "bodyText": "Where did you get these numbers from? To my knowledge a dbm of -95 is pretty much the noise floor for most wireless applications.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556870526", "createdAt": "2021-01-13T21:51:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg==", "bodyText": "You should make sure that the units are converted to what you expect them to be. Use QuantityType.toUnit to handle the conversion.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556871842", "createdAt": "2021-01-13T21:53:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n          \n          \n            \n                    } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556873488", "createdAt": "2021-01-13T21:54:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA==", "bodyText": "Why are you changing the properties every time? Thing properties should generally be considered immutable characteristics of the device so you should only need to update it when something changes.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556877470", "createdAt": "2021-01-13T21:58:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf34d9c6431cd097e900c307a6f31a2e36a54b97", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/cf34d9c6431cd097e900c307a6f31a2e36a54b97", "committedDate": "2021-01-14T07:02:30Z", "message": "Improve Triggers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb1c960f6b0a76946a505ad85f39f46f5c344a96", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/eb1c960f6b0a76946a505ad85f39f46f5c344a96", "committedDate": "2021-01-14T07:03:18Z", "message": "reduce updates to properties\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0aaff6395abedf04f6d586a4729d8f0782e98239", "committedDate": "2021-01-14T07:03:36Z", "message": "return early on InterruptedException\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e34237471e1a1396febb22f8fca0bc0f5feca604", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/e34237471e1a1396febb22f8fca0bc0f5feca604", "committedDate": "2021-01-14T21:39:22Z", "message": "fix pitmaster getState\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b7f277653a110317a13579a5541085a4c0c4fe8", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2b7f277653a110317a13579a5541085a4c0c4fe8", "committedDate": "2021-01-14T21:43:43Z", "message": "Changed QuantityType to DecimalType for channels without unit\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NjQ2MTAy", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-568646102", "createdAt": "2021-01-14T21:37:35Z", "commit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTozNzozNVrOIT4MgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQyMTo0NDowMFrOIT4ZIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDU2MA==", "bodyText": "This code is nearly identical to the code right above it. Please consider refactoring this into a separate method.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557714560", "createdAt": "2021-01-14T21:37:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzc5NQ==", "bodyText": "Same suggestion here.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557717795", "createdAt": "2021-01-14T21:44:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89a24245aa707305935fce86cec41b3ed986dfb6", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/89a24245aa707305935fce86cec41b3ed986dfb6", "committedDate": "2021-01-14T22:04:53Z", "message": "extract POST request to new method\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4OTEwMzYx", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-568910361", "createdAt": "2021-01-15T07:02:20Z", "commit": {"oid": "89a24245aa707305935fce86cec41b3ed986dfb6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26aef3fccc1c5dd2add505b9d2f1ea6b632e034f", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/26aef3fccc1c5dd2add505b9d2f1ea6b632e034f", "committedDate": "2021-01-15T07:36:42Z", "message": "spotless:apply\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a273604b8cba86e0b5d410e6feb5875592ab79e5", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a273604b8cba86e0b5d410e6feb5875592ab79e5", "committedDate": "2021-01-17T16:43:58Z", "message": "Add Unit Tests\nEnsure Gson objects are NonNull\nGenerify Handlers\nGenerify Utils\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7c3d69678bd102e37d16a689eb28c222cfacc59", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d7c3d69678bd102e37d16a689eb28c222cfacc59", "committedDate": "2021-01-17T17:05:16Z", "message": "Check if pitmaster is enabled for ESP32 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/483da477f329def4b5438d2ef1e3839552c901a0", "committedDate": "2021-01-17T17:12:50Z", "message": "Revert RSSI conversion for NanoV1 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMDk1NzQy", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-570095742", "createdAt": "2021-01-17T21:24:34Z", "commit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMToyNDozNVrOIVVVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QyMTo0MTowN1rOIVVc9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MDQ2Ng==", "bodyText": "Always pass the cause exceptions into new exceptions you throw.\nPlease add such a constructor is one doesn't already exist.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new WlanThermoInputException();\n          \n          \n            \n                        throw new WlanThermoInputException(e);\n          \n      \n    \n    \n  \n\nAlso, I don't think that a WlanThermoInputException is the correct thing to throw here if you get a TimeoutException. The WlanThermoInputException message implies incorrect data but a Timeout is not related to that at all, so the exception message would be misleading. Consider having the doGet method throw WlanThermoException instead so you can throw broader types of exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559240466", "createdAt": "2021-01-17T21:24:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;\n+\n+    public WlanThermoHandler(Thing thing, HttpClient httpClient, boolean extendedConfig) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.extendedConfig = extendedConfig;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (extendedConfig) {\n+                config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+                WlanThermoExtendedConfiguration extendedConfig = (WlanThermoExtendedConfiguration) config;\n+                if (extendedConfig.getUsername().isEmpty() && !extendedConfig.getPassword().isEmpty()) {\n+                    AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                    authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                            extendedConfig.getUsername(), extendedConfig.getPassword()));\n+                }\n+            } else {\n+                config = getConfigAs(WlanThermoConfiguration.class);\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> oldScheduler = pollingScheduler;\n+        if (oldScheduler != null) {\n+            boolean stopped = oldScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        pollingScheduler = null;\n+    }\n+\n+    protected void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            pull();\n+        }\n+    }\n+\n+    protected boolean doPost(String endpoint, String json) throws InterruptedException {\n+        try {\n+            URI uri = config.getUri(endpoint);\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                return false;\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+                // Still continue to try next channel\n+                return true;\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update channel on device: \" + e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    protected <T> T doGet(String endpoint, Class<T> object) throws InterruptedException, WlanThermoInputException {\n+        try {\n+            String json = httpClient.GET(config.getUri(endpoint)).getContentAsString();\n+            logger.debug(\"Received at {}: {}\", endpoint, json);\n+            return requireNonNull(gson.fromJson(json, object));\n+        } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            throw new WlanThermoInputException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTU2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected ScheduledFuture<?> pollingScheduler;\n          \n          \n            \n                protected @Nullable ScheduledFuture<?> pollingScheduler;", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241569", "createdAt": "2021-01-17T21:33:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTkyNQ==", "bodyText": "Please put test data in their own files and then load them in runtime. You can do this by loading the resources from the ClassLoader.", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241925", "createdAt": "2021-01-17T21:36:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/test/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandlerTest.java", "diffHunk": "@@ -0,0 +1,601 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.awt.*;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUtil;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandlerTest} class tests the {@link WlanThermoEsp32CommandHandler}\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+class WlanThermoEsp32CommandHandlerTest {\n+\n+    private static final ThingUID THING_UID = new ThingUID(\"wlanthermo\", \"esp32\", \"test\");\n+\n+    //@formatter:off\n+    private static final String DATA_INPUT_JSON = \"{\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MjQ4Nw==", "bodyText": "Is this fall through intentional?", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559242487", "createdAt": "2021-01-17T21:41:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, Data data, Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        String groupId = requireNonNull(channelUID.getGroupId());\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(WlanThermoNanoV1Util.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        String groupId;\n+        try {\n+            groupId = requireNonNull(channelUID.getGroupId());\n+        } catch (WlanThermoInputException e) {\n+            return false;\n+        }\n+\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "483da477f329def4b5438d2ef1e3839552c901a0"}, "originalPosition": 172}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1270e69000d427c6eefe94a1462b8c1f20c6a77e", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1270e69000d427c6eefe94a1462b8c1f20c6a77e", "committedDate": "2021-01-18T06:48:57Z", "message": "fix Fallthrough bug introduced by change of return handling\nmove test json to resources\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00c450f4e2f81ed1cf6d0b02a3dc41c6434b098f", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/00c450f4e2f81ed1cf6d0b02a3dc41c6434b098f", "committedDate": "2021-01-18T06:53:55Z", "message": "remove unused throws\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwNzQzMjMy", "url": "https://github.com/openhab/openhab-addons/pull/9579#pullrequestreview-570743232", "createdAt": "2021-01-18T19:40:23Z", "commit": {"oid": "00c450f4e2f81ed1cf6d0b02a3dc41c6434b098f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b15ff901766669c455bc69a2c9e55bdf33da8db", "author": {"user": {"login": "CSchlipp", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7b15ff901766669c455bc69a2c9e55bdf33da8db", "committedDate": "2021-01-18T21:26:14Z", "message": "remove unused import\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3650, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}