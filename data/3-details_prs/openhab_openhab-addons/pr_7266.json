{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Njc0MDIy", "number": 7266, "title": "[radiothermostat] RadioThermostat Binding - initial contribution", "bodyText": "This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module using its HTTP/JSON interface.", "createdAt": "2020-03-31T23:41:59Z", "url": "https://github.com/openhab/openhab-addons/pull/7266", "merged": true, "mergeCommit": {"oid": "ef0d11cf186bd7c3fa8044e8dd721650cc29d36e"}, "closed": true, "closedAt": "2020-06-24T20:02:11Z", "author": {"login": "mlobstein"}, "timelineItems": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTL5tbAH2gAyMzk2Njc0MDIyOmExNDM0MDg0ZWU4YzJmYTI1NWQ2YTMwNDkxZTBkNjk0YmE1OTY3NDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcufsD_gFqTQzNjk2NDY1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a1434084ee8c2fa255d6a30491e0d694ba596748", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a1434084ee8c2fa255d6a30491e0d694ba596748", "committedDate": "2020-03-31T23:42:38Z", "message": "RadioThermostat Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f656bfee2007b1bdcd4bb144dc2c07b775d9d343", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f656bfee2007b1bdcd4bb144dc2c07b775d9d343", "committedDate": "2020-03-31T23:37:18Z", "message": "RadioThermostat Binding - initial contribution"}, "afterCommit": {"oid": "a1434084ee8c2fa255d6a30491e0d694ba596748", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a1434084ee8c2fa255d6a30491e0d694ba596748", "committedDate": "2020-03-31T23:42:38Z", "message": "RadioThermostat Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2082b2dcd6c05f2279fd1a1f24864683e1ec89c9", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2082b2dcd6c05f2279fd1a1f24864683e1ec89c9", "committedDate": "2020-04-01T01:09:18Z", "message": "remove HTTPException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af112f4e3ace230ed6d4f4a711f42691d29f8c50", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/af112f4e3ace230ed6d4f4a711f42691d29f8c50", "committedDate": "2020-04-01T20:10:51Z", "message": "update ui before sending command; slow response time caused the ui values to bounce\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00343edcb5171c11b2a045d5b92a4cefb9809d0b", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/00343edcb5171c11b2a045d5b92a4cefb9809d0b", "committedDate": "2020-04-08T04:42:34Z", "message": "Add discovery service from billfor\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c1ed9b00a0592d461de528284f4c9e2aa649688", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2c1ed9b00a0592d461de528284f4c9e2aa649688", "committedDate": "2020-04-13T19:48:11Z", "message": "make hold function a switch and improve examples in readme\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "committedDate": "2020-04-13T19:56:53Z", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caae6836f8d203aa307aef064abd25b96e40b888", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/caae6836f8d203aa307aef064abd25b96e40b888", "committedDate": "2020-04-13T19:58:46Z", "message": "Merge branch '2.5.x' into RadioThermostat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "committedDate": "2020-04-19T18:41:08Z", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f43c452a8771ae1b8511ad663f436320d57dee55", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f43c452a8771ae1b8511ad663f436320d57dee55", "committedDate": "2020-04-19T20:19:13Z", "message": "Merge branch '2.5.x' into RadioThermostat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f1529b28df74f821ce282bb979ebe2cb439f669", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/7f1529b28df74f821ce282bb979ebe2cb439f669", "committedDate": "2020-04-19T21:02:13Z", "message": "a couple more tweaks and increment pom version to 2.5.5\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5affb52dbd3e6f04fda75a460f8eb56e9990f799", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5affb52dbd3e6f04fda75a460f8eb56e9990f799", "committedDate": "2020-04-20T22:16:58Z", "message": "some changes per review comments\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e3b1043c659f2a34ccf6c4b1ee209745e2c77d9", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8e3b1043c659f2a34ccf6c4b1ee209745e2c77d9", "committedDate": "2020-04-21T02:36:07Z", "message": "format runtime output\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2a7a732b9d9fb769b631ae8a46787f66c7292727", "committedDate": "2020-05-04T16:00:55Z", "message": "Cleanup 'advanced' tag attribute usage on channel-types in thing-types.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzA2OTYz", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-416306963", "createdAt": "2020-05-21T16:34:39Z", "commit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjozODo1NVrOGY6QdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo0MzoxMVrOGY-d-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3MzQ5Mg==", "bodyText": "Suggestion: Make it a Switch item-type to indicate the user overrode the setpoint.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428773492", "createdAt": "2020-05-21T16:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,211 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is 0.                       |\n+| disableHumidity | Disable retrieval of humidity information from the thermostat. Optional, the default is 0.                |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| name                   | String               | The name of the thermostat                                                |\n+| model                  | String               | The model number and firmware version of the thermostat                   |\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n+| mode                   | Number               | The current operating mode of the HVAC system                             |\n+| fan_mode               | Number               | The current operating mode of the fan                                     |\n+| program_mode           | Number               | The program schedule that the thermostat is running (CT80 Rev B only)     |\n+| set_point              | Number:Temperature   | The current temperature set point of the thermostat                       |\n+| status                 | Number               | Indicates the current running status of the HVAC system                   |\n+| fan_status             | Number               | Indicates the current fan status of the HVAC system                       |\n+| override               | Number               | Indicates if the normal program set-point has been manually overridden    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3NzgzOQ==", "bodyText": "typo AND it's bad practice to throw unchecked (RuntimeException) Exceptions, because the compiler doesn't force you to catch the Exception. Better extend from Exception.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428777839", "createdAt": "2020-05-21T16:46:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThemostatHttpException.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+/**\n+ * The {@link RadioThemostatHttpException} extends RuntimeException\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThemostatHttpException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNTAyNA==", "bodyText": "Better use scheduleWithFixedDelay", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428805024", "createdAt": "2020-05-21T17:34:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwNjA2OA==", "bodyText": "This will only work for Unix systems, better use isLoopback().", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428806068", "createdAt": "2020-05-21T17:36:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODkxNA==", "bodyText": "Are you sure you need this fine grained trace logging or can you use a debugger instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428808914", "createdAt": "2020-05-21T17:41:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public RadioThermostatDiscoveryService() {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.getName().matches(\"lo\")) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.trace(\"Sending discovery broadcast\");\n+        // logger.trace(\"Considering {}\", ni.getName());\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.trace(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.trace(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.trace(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.trace(\"Match: {} \", response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxMzkwOQ==", "bodyText": "Are you sure you need this fine grained logging or can you use a debugger instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428813909", "createdAt": "2020-05-21T17:50:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODY0Mw==", "bodyText": "The initialize() method should return fast. No network interaction is allowed here. Schedule a task with scheduleWithFixedDelay or even better, use async HTTP client: https://www.eclipse.org/jetty/documentation/current/http-client-api.html#http-client-async", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818643", "createdAt": "2020-05-21T17:58:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxODgzNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428818837", "createdAt": "2020-05-21T17:58:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgxOTQ4Ng==", "bodyText": "Bindings should only log to error, when they hit a bug. The correct log level would be warn. You also don't need to log the stacktrace when the connection fails, so remove the last parameter.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428819486", "createdAt": "2020-05-21T18:00:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMTA0OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428821048", "createdAt": "2020-05-21T18:02:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzc4OQ==", "bodyText": "This will block one of openHAB's scheduler Threads. You should schedule another one-shot task with a 2 sec delay.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823789", "createdAt": "2020-05-21T18:07:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyMzk1OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428823958", "createdAt": "2020-05-21T18:08:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzE3NQ==", "bodyText": "Consider doing this asynchronously (see Jetty link above), to not block a openHAB's scheduler Thread.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827175", "createdAt": "2020-05-21T18:14:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzk0Mg==", "bodyText": "Should be warn, see above.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428827942", "createdAt": "2020-05-21T18:15:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMDMyNA==", "bodyText": "You don't need to trim, if you specify network-address in the context tag of the hostname parameter in the XML files. This ensures your parameter is always a valid network address.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428830324", "createdAt": "2020-05-21T18:20:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNjYwMw==", "bodyText": "Jetty is the preferred library to perform HTTP requests: https://www.openhab.org/docs/developer/guidelines.html#default-libraries", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428836603", "createdAt": "2020-05-21T18:31:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 424}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzU0MQ==", "bodyText": "See Jetty hint above.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837541", "createdAt": "2020-05-21T18:33:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 503}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzNzg4Mg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428837882", "createdAt": "2020-05-21T18:34:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }\n+\n+        //test the thermostat connection by getting the thermostat name and model\n+        if (errorMsg == null) {\n+            try {\n+                Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+                if (nameResult instanceof RadioThermostatJsonName) {\n+                    rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat name\";\n+                }\n+                \n+                Thread.sleep(2000);\n+                \n+                Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+                if (modelResult instanceof RadioThermostatJsonModel) {\n+                    rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+                } else {\n+                    errorMsg = \"Unable to get thermostat model\";\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred attempting to connect with thermostat: {}\", e.getMessage(), e);\n+            }\n+        }\n+        \n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+            startAutomaticRefresh();\n+            if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+                startAutomaticLogRefresh();\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+    \n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {   \n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                        Thread.sleep(2000);\n+                    }\n+                    \n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            // remove all non-numeric characters except negative '-'\n+            String cmdStr = command.toString().replaceAll(\"[^\\\\d-]\", \"\");\n+            if (!StringUtils.isEmpty(cmdStr) && StringUtils.isNumeric(cmdStr)) {\n+                cmdInt = Integer.parseInt(cmdStr);\n+            }\n+            \n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    //only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+                        \n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(null);\n+                        rthermData.getThermostatData().setCoolTarget(null);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+                        \n+                        //now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(channelUID.getId(), rthermData);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        //don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    updateChannel(channelUID.getId(), rthermData);\n+                    sendCommand(cmdKey, cmdStr);\n+                    break;\n+                default:\n+                    logger.error(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = StringUtils.trimToEmpty(config.hostName);\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            URL url = new URL(urlStr);\n+            URLConnection connection = url.openConnection();\n+\n+            try {\n+                String response = IOUtils.toString(connection.getInputStream());\n+                logger.debug(\"thermostatResponse = {}\", response);\n+\n+                // Map the JSON response to the correct object\n+                if (DEFAULT_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+                } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+                } else if (MODEL_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+                } else if (NAME_RESOURCE.equals(resource)) {\n+                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n+                }\n+                \n+            } finally {\n+                IOUtils.closeQuietly(connection.getInputStream());\n+            }\n+\n+            if (result != null ) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            errorMsg = e.getMessage();\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+    \n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, String cmdVal, String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\"+ cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        byte[] out = postJson.getBytes(StandardCharsets.US_ASCII);\n+        String output = null;\n+        String errorMsg = null;\n+        \n+        try {\n+            URL url = new URL(urlStr);\n+            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n+            conn.setRequestProperty(\"Content-Type\", \"text/plain\");\n+            conn.setFixedLengthStreamingMode(out.length);\n+            conn.setRequestMethod(\"POST\");\n+            conn.setDoOutput(true);\n+            conn.connect();\n+            \n+            OutputStream os = conn.getOutputStream();\n+            os.write(postJson.getBytes(StandardCharsets.US_ASCII));\n+            \n+            BufferedReader br = new BufferedReader(new InputStreamReader(\n+                    (conn.getInputStream())));\n+            try {\n+                if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {\n+                    throw new RadioThemostatHttpException(\"HTTP response code: \" + conn.getResponseCode());\n+                }\n+                output = br.readLine();\n+                \n+            } catch (IOException | RadioThemostatHttpException e) {\n+                logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);\n+            } finally {\n+                br.close();\n+                os.close();\n+                conn.disconnect();\n+            }\n+\n+        } catch (MalformedURLException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Constructed url is not valid: {}\", errorMsg);\n+        } catch (JsonSyntaxException e) {\n+            errorMsg = \"Configuration is incorrect\";\n+            logger.warn(\"Error running thermostat command: {}\", errorMsg);\n+        } catch (IOException | IllegalStateException e) {\n+            logger.error(\"Exception occurred during execution: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 536}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MDk2Ng==", "bodyText": "Add the context tag with network-address to validate the parameter automatically.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428840966", "createdAt": "2020-05-21T18:40:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,236 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to control the house's HVAC system\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\"/>\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\t\t\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MjQ5MA==", "bodyText": "You don't need these checks, since you already specified min/max in the XML file.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r428842490", "createdAt": "2020-05-21T18:43:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,656 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThemostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+    \n+    private static final String DEFAULT_RESOURCE    = \"tstat\";\n+    private static final String RUNTIME_RESOURCE    = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE   = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE      = \"tstat/model\";\n+    private static final String NAME_RESOURCE       = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private ScheduledFuture<?> refreshJob;\n+    private ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+    \n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing, RadioThermostatStateDescriptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        logger.debug(\"config hostName = {}\", config.hostName); \n+        logger.debug(\"config refresh = {}\", config.refresh);\n+        logger.debug(\"config logRefresh = {}\", config.logRefresh);\n+        logger.debug(\"config disableLogs = {}\", config.disableLogs);\n+        logger.debug(\"config disableHumidity = {}\", config.disableHumidity);\n+\n+        String errorMsg = null;\n+\n+        if (StringUtils.trimToNull(config.hostName) == null) {\n+            errorMsg = \"Parameter 'hostName' is mandatory and must be configured\";\n+        }\n+        if (config.refresh != null && config.refresh < 1) {\n+            errorMsg = \"Parameter 'refresh' must be at least 1 minute\";\n+        }\n+        if (config.logRefresh != null && config.logRefresh < 5) {\n+            errorMsg = \"Parameter 'logRefresh' must be at least 5 minutes\";\n+        }\n+        if (config.disableLogs != null && (config.disableLogs != 0 && config.disableLogs != 1)) {\n+            errorMsg = \"Parameter 'disableLogs' must be either 0 or 1\";\n+        }\n+        if (config.disableHumidity != null && (config.disableHumidity != 0 && config.disableHumidity != 1)) {\n+            errorMsg = \"Parameter 'disableHumidity' must be either 0 or 1\";\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7a732b9d9fb769b631ae8a46787f66c7292727"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ae6d1b33204282462651a57d6f39944e646f582", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2ae6d1b33204282462651a57d6f39944e646f582", "committedDate": "2020-05-22T14:35:49Z", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1f7e3d5a9300b060cf749a562e3096d2f2990c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5c1f7e3d5a9300b060cf749a562e3096d2f2990c", "committedDate": "2020-05-22T15:03:02Z", "message": "Remove Thread.sleep\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64f506f87220d02125ef1a4b39492d59b962de55", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/64f506f87220d02125ef1a4b39492d59b962de55", "committedDate": "2020-05-23T04:54:44Z", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f068374354480a0b4706a4d32cd057dee105946f", "committedDate": "2020-05-26T04:04:25Z", "message": "Remove org.apache.commons.lang dependency\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzEwNjY3", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-418710667", "createdAt": "2020-05-26T22:03:05Z", "commit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjowMzowNVrOGax19Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMjoxNzo1MVrOGayL2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczMjc4OQ==", "bodyText": "You updated the binding version but did not rebase the current 2.5.x branch. I think this is the reason why the build fails.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430732789", "createdAt": "2020-05-26T22:03:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczNzExMg==", "bodyText": "There are some formatting errors. You can view them with mvn install -Dspotless.check.skip=false and fix them by running mvn spotless:apply.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430737112", "createdAt": "2020-05-26T22:14:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -417,30 +399,24 @@ private Object getRadioThermostatData(String resource) {\n \n         try {\n             // Run the HTTP request and get the JSON response from the thermostat\n-            URL url = new URL(urlStr);\n-            URLConnection connection = url.openConnection();\n-\n-            try {\n-                String response = IOUtils.toString(connection.getInputStream());\n-                logger.debug(\"thermostatResponse = {}\", response);\n-\n-                // Map the JSON response to the correct object\n-                if (DEFAULT_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n-                } else if (HUMIDITY_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n-                } else if (RUNTIME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n-                } else if (MODEL_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonModel.class);\n-                } else if (NAME_RESOURCE.equals(resource)) {\n-                    result = gson.fromJson(response, RadioThermostatJsonName.class);\n-                }\n-                \n-            } finally {\n-                IOUtils.closeQuietly(connection.getInputStream());\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n             }\n-\n+                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczODM5Mg==", "bodyText": "The words in labels should be capitalized: https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r430738392", "createdAt": "2020-05-26T22:17:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,237 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to control the house's HVAC system\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\"/>\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\t\t\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host name or IP address of the thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the refresh interval in minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the run-time log and humidity refresh interval in minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable retrieval of run-time data</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f068374354480a0b4706a4d32cd057dee105946f"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07232c4278f02a3944dd6dcf6ada367ba86b0794", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/07232c4278f02a3944dd6dcf6ada367ba86b0794", "committedDate": "2020-05-27T03:48:12Z", "message": "Add @NonNullByDefault annotations\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "committedDate": "2020-05-27T03:57:29Z", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c32d4166f1233e2ef35be55b0b0e0b397fbe3450", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c32d4166f1233e2ef35be55b0b0e0b397fbe3450", "committedDate": "2020-05-27T04:23:14Z", "message": "apply spotless and label name fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54603bd39d4550947734bb4e532bfa4ebabbebb6", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/54603bd39d4550947734bb4e532bfa4ebabbebb6", "committedDate": "2020-05-27T04:24:19Z", "message": "Merge branch '2.5.x' into RadioThermostat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b6ca717f669ea1a92de4a7db5ce73e595cc71b2e", "committedDate": "2020-05-27T19:09:17Z", "message": "Temp value needs to have decimal places\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTcxMDY1", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-419571065", "createdAt": "2020-05-27T20:09:27Z", "commit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjY1Njc4", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-419665678", "createdAt": "2020-05-27T22:56:19Z", "commit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjo1NjoxOVrOGbf9vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMzozMTozNFrOGbgrVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODQ0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private ScheduledFuture<?> scheduledFuture = null;\n          \n          \n            \n                private @Nullable ScheduledFuture<?> scheduledFuture = null;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488447", "createdAt": "2020-05-27T22:56:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4ODY3Mw==", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431488673", "createdAt": "2020-05-27T22:56:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4OTExOA==", "bodyText": "use it or lose it", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431489118", "createdAt": "2020-05-27T22:58:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n+                // .withProperty(RadioThermostatBindingConstants.PROPERTY_UUID, uuid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDE2Nw==", "bodyText": "just use an if statement here instead.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490167", "createdAt": "2020-05-27T23:01:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MDg4MA==", "bodyText": "Don't forget to catch JsonSyntaxException", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431490880", "createdAt": "2020-05-27T23:03:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTAwNA==", "bodyText": "Please catch specific exceptions", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491004", "createdAt": "2020-05-27T23:03:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ4Mw==", "bodyText": "so you only care about the last url and ip that your find and discard the rest?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491483", "createdAt": "2020-05-27T23:05:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTk3NA==", "bodyText": "I assume it is supposed to be this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n          \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label)\n          \n          \n            \n                                  .withRepresentationProperty(RadioThermostatBindingConstants.PROPERTY_IP)", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431491974", "createdAt": "2020-05-27T23:06:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    try {\n+                        url = value;\n+                        ip = new URL(value).getHost();\n+                    } catch (MalformedURLException e) {\n+                        logger.debug(\"Malfored URL {}\", e.getMessage());\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(sysinfo).getAsJsonObject();\n+            uuid = content.get(\"uuid\").getAsString();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.debug(\"Cannot get system info from thermostat {} {}\", ip, e.getMessage());\n+            sysinfo = null;\n+        }\n+\n+        try {\n+            ContentResponse contentResponse = httpClient.newRequest(url + \"name\").method(GET)\n+                    .timeout(20, TimeUnit.SECONDS).send();\n+            String nameinfo = contentResponse.getContentAsString();\n+            content = new JsonParser().parse(nameinfo).getAsJsonObject();\n+            name = content.get(\"name\").getAsString();\n+        } catch (Exception e) {\n+            logger.debug(\"Cannot get name from thermostat {} {}\", ip, e.getMessage());\n+        }\n+\n+        logger.debug(\"Discovery returned: {} uuid {} name {}\", sysinfo, uuid, name);\n+\n+        ThingUID thingUid = new ThingUID(RadioThermostatBindingConstants.THING_TYPE_RTHERM, uuid);\n+\n+        logger.debug(\"Got discovered device.\");\n+\n+        String label = String.format(\"RadioThermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MzMyNA==", "bodyText": "might be useful to include what each of the status numbers mean.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431493324", "createdAt": "2020-05-27T23:10:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTA4MQ==", "bodyText": "should this be a switch instead?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495081", "createdAt": "2020-05-27T23:15:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTQ1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Dimensionless</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495455", "createdAt": "2020-05-27T23:16:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTU2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Temperature</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495565", "createdAt": "2020-05-27T23:17:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTcwNA==", "bodyText": "This should be a thing property instead of a channel.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495704", "createdAt": "2020-05-27T23:17:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTgyOA==", "bodyText": "This should also be a property", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431495828", "createdAt": "2020-05-27T23:17:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NjI5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Double temperature = new Double(0);\n          \n          \n            \n                private Double temperature = 0d;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431496297", "createdAt": "2020-05-27T23:19:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/json/RadioThermostatJsonResponse.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.json;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link RadioThermostatJsonResponse} is responsible for storing\n+ * the data from the thermostat 'tstat' JSON response\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatJsonResponse {\n+\n+    @SerializedName(\"temp\")\n+    private Double temperature = new Double(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw==", "bodyText": "It doesn't appear as if the discovery service is in any way tied to the ThingHandler instance. I also don't think there should be multiple discovery services either, so you should just make your RadioThermostatDiscoveryService a osgi service instead of initialize it here.\nPlease add this above your RadioThermostatDiscoveryService class:\n@Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n\nthen remove all RadioThermostatDiscoveryService and ServiceRegistration logic from the RadioThrmostatHandlerFactory.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431498807", "createdAt": "2020-05-27T23:27:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5OTI3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n            \n          \n          \n            \n                public RadioThermostatDiscoveryService(HttpClient httpClient) {\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431499270", "createdAt": "2020-05-27T23:28:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMDExNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Override\n          \n          \n            \n                public void deactivate() {\n          \n          \n            \n                @Override\n          \n          \n            \n                @Deactivate\n          \n          \n            \n                public void deactivate() {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r431500116", "createdAt": "2020-05-27T23:31:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    public RadioThermostatDiscoveryService(HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    public void deactivate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 87}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "639e0b921f1b116b1fd06f3cc8b2aae0ca5bb66c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/639e0b921f1b116b1fd06f3cc8b2aae0ca5bb66c", "committedDate": "2020-05-28T02:37:25Z", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}, "afterCommit": {"oid": "92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "committedDate": "2020-05-28T02:41:50Z", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/92f5f2d7e684e6fa36204cd38ead286a4deb2e62", "committedDate": "2020-05-28T02:41:50Z", "message": "Code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}, "afterCommit": {"oid": "96b0dabe297a6e5ee762f06574285bd14174ac8e", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/96b0dabe297a6e5ee762f06574285bd14174ac8e", "committedDate": "2020-05-28T02:46:35Z", "message": "Update bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96b0dabe297a6e5ee762f06574285bd14174ac8e", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/96b0dabe297a6e5ee762f06574285bd14174ac8e", "committedDate": "2020-05-28T02:46:35Z", "message": "Update bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java\n\nCo-authored-by: cpmeister <mistercpp2000@gmail.com>\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}, "afterCommit": {"oid": "75eef230ad5bfeb104bcc7b0eab421805be4a99c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/75eef230ad5bfeb104bcc7b0eab421805be4a99c", "committedDate": "2020-05-28T03:22:55Z", "message": "Merge branch 'RadioThermostat' of https://github.com/mlobstein/openhab-addons into RadioThermostat\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05043d3fc07fe88f8a6a46096b567176efc18775", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/05043d3fc07fe88f8a6a46096b567176efc18775", "committedDate": "2020-05-28T04:27:53Z", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75eef230ad5bfeb104bcc7b0eab421805be4a99c", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/75eef230ad5bfeb104bcc7b0eab421805be4a99c", "committedDate": "2020-05-28T03:22:55Z", "message": "Merge branch 'RadioThermostat' of https://github.com/mlobstein/openhab-addons into RadioThermostat\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}, "afterCommit": {"oid": "05043d3fc07fe88f8a6a46096b567176efc18775", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/05043d3fc07fe88f8a6a46096b567176efc18775", "committedDate": "2020-05-28T04:27:53Z", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f", "committedDate": "2020-05-28T15:57:09Z", "message": "fix hold switch bug\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzc4MDMw", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-420378030", "createdAt": "2020-05-28T18:25:47Z", "commit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODoyNTo0OFrOGcBXGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODozNzoxN1rOGcBvNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTYwOQ==", "bodyText": "My comments below will show exactly how to get an HttpClient into your DiscoveryService. It is the same way that you inject an HttpClient into this class.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035609", "createdAt": "2020-05-28T18:25:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.discovery.RadioThermostatDiscoveryService;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new HashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (thingTypeUID.equals(THING_TYPE_RTHERM)) {\n+            RadioThermostatHandler handler = new RadioThermostatHandler(thing, stateDescriptionProvider, httpClient);\n+\n+            RadioThermostatDiscoveryService discoveryService = new RadioThermostatDiscoveryService(httpClient);\n+            discoveryServiceRegs.put(handler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODgwNw=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzNTk1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n          \n          \n            \n            @NonNullByDefault\n          \n          \n            \n            @Component(immediate=true, service = DiscoveryService.class, configurationPid = \"discovery.radiothermostat\")\n          \n          \n            \n            public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432035951", "createdAt": "2020-05-28T18:26:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTE5NA==", "bodyText": "I forgot that you can't inject a HttpClient, only a HttpClientFactory. So my apologies.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClient;\n          \n          \n            \n                @Activate\n          \n          \n            \n                public RadioThermostatDiscoveryService(@Reference HttpClientFactory httpClientFactory) {\n          \n          \n            \n                    super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n          \n          \n            \n                    this.httpClient = httpClientFactory.getCommonHttpClient();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432039194", "createdAt": "2020-05-28T18:32:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTc4Mw==", "bodyText": "remove this loop", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432041783", "createdAt": "2020-05-28T18:37:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 121}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzkyMjg3", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-420392287", "createdAt": "2020-05-28T18:45:48Z", "commit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NTo0OFrOGcCBrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxODo0NTo0OFrOGcCBrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NjUxMQ==", "bodyText": "Actually now that I look at it, you don't need an httpClient at all if this is all you are using it for.\nYou can replace this with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n          \n          \n            \n                                .send();\n          \n          \n            \n                        sysinfo = contentResponse.getContentAsString();\n          \n          \n            \n                        sysinfo = HttpUtil.executeUrl(\"GET\", url, 20000);\n          \n      \n    \n    \n  \n\nYou can do the same for the code below as well.\nYeah, I think the best course of action would be to remove the httpClient field entirely from this class.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432046511", "createdAt": "2020-05-28T18:45:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/discovery/RadioThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.discovery;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.MalformedURLException;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link RadioThermostatDiscoveryService} is responsible for discovery of\n+ * RadioThermostats on the local network\n+ * \n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Bill Forsyth - Modified for the RadioThermostat's peculiar discovery mode\n+ * @author Michael Lobstein - Cleanup for RadioThermostat\n+ * \n+ */\n+\n+@NonNullByDefault\n+public class RadioThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatDiscoveryService.class);\n+    private static final String RADIOTHERMOSTAT_DISCOVERY_MESSAGE = \"TYPE: WM-DISCOVER\\r\\nVERSION: 1.0\\r\\n\\r\\nservices:com.marvell.wm.system*\\r\\n\\r\\n\";\n+\n+    private static final String SSDP_MATCH = \"WM-NOTIFY\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture = null;\n+\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public RadioThermostatDiscoveryService(@Reference HttpClient httpClient) {\n+        super(RadioThermostatBindingConstants.SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClient;\n+        activate(null);\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Deactivate\n+    public void deactivate() {\n+        stopBackgroundDiscovery();\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.debug(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 1; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    if (ni.isUp() && ni.supportsMulticast() && !ni.isLoopback()) {\n+                        sendDiscoveryBroacast(ni);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private void sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+        logger.debug(\"Sending discovery broadcast\");\n+        try {\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"no ipv4 address on {}\", ni.getName());\n+                return;\n+            }\n+\n+            // for whatever reason, the radio thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(null);\n+            socket.setSoTimeout(5000);\n+            socket.setReuseAddress(true);\n+            // socket.setBroadcast(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+            logger.debug(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = RADIOTHERMOSTAT_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            try {\n+                // Try to ensure that joinGroup has taken effect. Without this delay, the query\n+                // packet ends up going out before the group join.\n+                Thread.sleep(1000);\n+\n+                socket.send(datagramPacket);\n+\n+                byte[] buf = new byte[4096];\n+                DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+\n+                try {\n+                    while (!Thread.interrupted()) {\n+                        socket.receive(packet);\n+                        String response = new String(packet.getData());\n+                        logger.debug(\"Response: {} \", response);\n+                        if (response.contains(SSDP_MATCH)) {\n+                            logger.debug(\"Match: {} \", response);\n+                            parseResponse(response);\n+                        }\n+                    }\n+                    logger.debug(\"Bridge device scan interrupted\");\n+                } catch (SocketTimeoutException e) {\n+                    logger.debug(\n+                            \"Timed out waiting for multicast response. Presumably all devices have already responded.\");\n+                }\n+            } finally {\n+                socket.leaveGroup(m);\n+                socket.close();\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.debug(\"got exception: {}\", e.getMessage());\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = \"unknownName\";\n+        String uuid = \"unknownThermostat\";\n+        String ip = null;\n+        String url = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            if (\"location\".equals(key)) {\n+                try {\n+                    url = value;\n+                    ip = new URL(value).getHost();\n+                } catch (MalformedURLException e) {\n+                    logger.debug(\"Malfored URL {}\", e.getMessage());\n+                }\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.debug(\"Found thermostat, ip: {} \", ip);\n+\n+        if (ip == null) {\n+            logger.debug(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        JsonObject content;\n+        String sysinfo;\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(url).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+            sysinfo = contentResponse.getContentAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 271}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDI4ODA5", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-420428809", "createdAt": "2020-05-28T19:38:00Z", "commit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozODowMVrOGcDt-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTozODowMVrOGcDt-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NDIzNA==", "bodyText": "@cpmeister is it ok to use a blocking HTTP request on a scheduler thread?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432074234", "createdAt": "2020-05-28T19:38:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57f11434fd5e1c0e7ebb7b3910f7c0e6873c885f"}, "originalPosition": 402}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6", "committedDate": "2020-05-28T19:56:06Z", "message": "remove httpClient from discovery service\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjY4NjEx", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-420668611", "createdAt": "2020-05-29T05:50:59Z", "commit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNTo1MDo1OVrOGcPmRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNjoyMDo0MVrOGcQIXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2ODg3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n          \n          \n            \n            \t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432268871", "createdAt": "2020-05-29T05:50:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTAwOA==", "bodyText": "please change type to boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269008", "createdAt": "2020-05-29T05:51:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTE3NA==", "bodyText": "please change type to boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269174", "createdAt": "2020-05-29T05:52:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2OTc5Ng==", "bodyText": "I think this should be changed to a switch if there are only two possible values.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432269796", "createdAt": "2020-05-29T05:54:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,238 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"name\" typeId=\"name\" />\n+\t\t\t<channel id=\"model\" typeId=\"model\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"name\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Name</label>\n+\t\t<description>The Name of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"model\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Model</label>\n+\t\t<description>The Model Number and Firmware Version of the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5NTA4MQ=="}, "originalCommit": {"oid": "b6ca717f669ea1a92de4a7db5ce73e595cc71b2e"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDEzMQ==", "bodyText": "maybe it would be better to make a ThingAction for this?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432270131", "createdAt": "2020-05-29T05:55:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Refresh Interval in Minutes</description>\n+\t\t\t\t<default>2</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"logRefresh\" type=\"integer\" min=\"5\" required=\"false\">\n+\t\t\t\t<label>Run-time Log Refresh Interval</label>\n+\t\t\t\t<description>Specifies the Run-time Log and Humidity Refresh Interval in Minutes</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableLogs\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Run-time Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Run-time Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"disableHumidity\" type=\"integer\" min=\"0\" max=\"1\" required=\"false\">\n+\t\t\t\t<label>Disable Retrieval of Humidity Data</label>\n+\t\t\t\t<description>Optional Flag to Disable the Retrieval of Humidity Data from the Thermostat</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\n+\t<channel-type id=\"temp-temperature\">\n+\t\t<item-type>Number:Temperature</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>The Current Temperature Reading of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"humidity\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>Humidity</label>\n+\t\t<description>The Current Humidity Reading of the Thermostat</description>\n+\t\t<category>Humidity</category>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>The Current Operating Mode of the HVAC System</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Off</option>\n+\t\t\t\t<option value=\"1\">Heat</option>\n+\t\t\t\t<option value=\"2\">Cool</option>\n+\t\t\t\t<option value=\"3\">Auto</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_mode\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Mode</label>\n+\t\t<description>The Current Operating Mode of the Fan</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"program_mode\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Program Mode</label>\n+\t\t<description>The Program Schedule That the Thermostat Is Running</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"-1\">None</option>\n+\t\t\t\t<option value=\"0\">Program A</option>\n+\t\t\t\t<option value=\"1\">Program B</option>\n+\t\t\t\t<option value=\"2\">Vacation</option>\n+\t\t\t\t<option value=\"3\">Holiday</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"temp-sp\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Setpoint</label>\n+\t\t<description>The Current Temperature Set Point of the Thermostat</description>\n+\t\t<category>Temperature</category>\n+\t\t<state min=\"35\" max=\"95\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"override\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Override</label>\n+\t\t<description>Indicates If the Normal Program Setpoint Has Been Manually Overriden</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"hold\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Hold</label>\n+\t\t<description>Indicates If the Current Set Point Temperature Is to Be Held Indefinitely</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Status</label>\n+\t\t<description>Indicates the Current Running Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"fan_status\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Fan Status</label>\n+\t\t<description>Indicates the Current Fan Status of the HVAC System</description>\n+\t\t<state min=\"0\" max=\"2\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_day\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Day</label>\n+\t\t<description>The Current Day of the Week Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_hour\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Hour</label>\n+\t\t<description>The Current Hour of the Day Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"t_minute\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Minute</label>\n+\t\t<description>The Current Minute Past the Hour Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"dt_stamp\" advanced=\"true\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Thermostat Date</label>\n+\t\t<description>The Current Day of the Week and Time Reported by the Thermostat</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"last_update\" advanced=\"true\">\n+\t\t<item-type>DateTime</item-type>\n+\t\t<label>Last Updated</label>\n+\t\t<description>Last Successful Contact With Thermostat</description>\n+\t\t<category>Date</category>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"today_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Today's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Today</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_heat_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Heating Runtime</label>\n+\t\t<description>The Number of Minutes of Heating Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"yesterday_cool_runtime\">\n+\t\t<item-type>Number:Time</item-type>\n+\t\t<label>Yesterday's Cooling Runtime</label>\n+\t\t<description>The Number of Minutes of Cooling Run-time Yesterday</description>\n+\t\t<state readOnly=\"true\" pattern=\"%d %unit%\" />\n+\t</channel-type>\n+\n+\t<channel-type id=\"json_cmd\" advanced=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDU3Mw==", "bodyText": "You could populate in the RadioThermostatHandlerFactory constructor the same way you do with the HttpClientFactory. It would allow you to make this field non-null and final as well as get rid of the set/unset methods.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432270573", "createdAt": "2020-05-29T05:56:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/RadioThermostatHandlerFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.THING_TYPE_RTHERM;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.radiothermostat.internal.handler.RadioThermostatHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link RadioThermostatHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.radiothermostat\")\n+public class RadioThermostatHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RTHERM);\n+    private @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTA1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432271052", "createdAt": "2020-05-29T05:58:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,222 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"radiothermostat\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- RadioThemostat Thing -->\n+\t<thing-type id=\"rtherm\">\n+\t\t<label>Thermostat</label>\n+\t\t<description>\n+\t\t\tA Thermostat to Control the House's HVAC System\n+\t\t</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"temperature\" typeId=\"temp-temperature\" />\n+\t\t\t<channel id=\"humidity\" typeId=\"humidity\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"fan_mode\" typeId=\"fan_mode\" />\n+\t\t\t<channel id=\"program_mode\" typeId=\"program_mode\" />\n+\t\t\t<channel id=\"set_point\" typeId=\"temp-sp\" />\n+\t\t\t<channel id=\"override\" typeId=\"override\" />\n+\t\t\t<channel id=\"hold\" typeId=\"hold\" />\n+\t\t\t<channel id=\"status\" typeId=\"status\" />\n+\t\t\t<channel id=\"fan_status\" typeId=\"fan_status\" />\n+\t\t\t<channel id=\"day\" typeId=\"t_day\" />\n+\t\t\t<channel id=\"hour\" typeId=\"t_hour\" />\n+\t\t\t<channel id=\"minute\" typeId=\"t_minute\" />\n+\t\t\t<channel id=\"dt_stamp\" typeId=\"dt_stamp\" />\n+\t\t\t<channel id=\"last_update\" typeId=\"last_update\" />\n+\t\t\t<channel id=\"today_heat_runtime\" typeId=\"today_heat_runtime\" />\n+\t\t\t<channel id=\"today_cool_runtime\" typeId=\"today_cool_runtime\" />\n+\t\t\t<channel id=\"yesterday_heat_runtime\" typeId=\"yesterday_heat_runtime\" />\n+\t\t\t<channel id=\"yesterday_cool_runtime\" typeId=\"yesterday_cool_runtime\" />\n+\t\t\t<channel id=\"json_cmd\" typeId=\"json_cmd\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"hostName\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t\t<label>Thermostat Host Name/IP Address</label>\n+\t\t\t\t<description>Host Name or IP Address of the Thermostat</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" required=\"false\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MTU0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                private Gson gson;\n          \n          \n            \n            \n          \n          \n            \n                private final Gson gson;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432271543", "createdAt": "2020-05-29T06:00:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzA1MQ==", "bodyText": "change this to a boolean", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273051", "createdAt": "2020-05-29T06:05:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzEyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273129", "createdAt": "2020-05-29T06:05:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzMxOA==", "bodyText": "If you make the change I suggested in the ThingHandlerFactory you can make this non-null", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273318", "createdAt": "2020-05-29T06:06:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MzY3OA==", "bodyText": "calling getConfigAs is a costly operation, so you should try to cache the parsed config in a field so that other parts of the code can use it.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432273678", "createdAt": "2020-05-29T06:07:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NDU4Ng==", "bodyText": "What do you expect to throw an IllegalStateException?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432274586", "createdAt": "2020-05-29T06:10:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NTg1OA==", "bodyText": "Right now you are trying to figure out the expected json return type based on the value of the resource parameter. Instead you should supply the expected return type class as a parameter so you can take advantage of generics.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Object getRadioThermostatData(String resource) {\n          \n          \n            \n                private <T> @Nullable T getRadioThermostatData(String resource, Class<T> returnType) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432275858", "createdAt": "2020-05-29T06:15:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 392}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjA2NQ==", "bodyText": "What throws an Exception here?", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276065", "createdAt": "2020-05-29T06:15:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 501}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NjE2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n          \n          \n            \n                            if (data.getThermostatData().getTemperature() != 0) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432276164", "createdAt": "2020-05-29T06:16:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 504}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3NzU5OA==", "bodyText": "Why are you always returning the current time? You shouldn't do this since a channel might be trying to refresh this value from a cached RadioThermostatData.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432277598", "createdAt": "2020-05-29T06:20:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonModel;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonName;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private static final String DEFAULT_RESOURCE = \"tstat\";\n+    private static final String RUNTIME_RESOURCE = \"tstat/datalog\";\n+    private static final String HUMIDITY_RESOURCE = \"tstat/humidity\";\n+    private static final String MODEL_RESOURCE = \"tstat/model\";\n+    private static final String NAME_RESOURCE = \"sys/name\";\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private Gson gson;\n+\n+    private int initialized = 0;\n+    private int retryCounter = 0;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        startAutomaticRefresh();\n+        if (!(config.disableLogs == 1 && config.disableHumidity == 1)) {\n+            startAutomaticLogRefresh();\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                if (initialized == 0) {\n+                    setupConnection();\n+                }\n+\n+                try {\n+                    // Request new data from the thermostat\n+                    retryCounter = 0;\n+                    Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                    if (result instanceof RadioThermostatJsonResponse) {\n+                        rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+\n+                        // Update all channels with the new data\n+                        updateAllChannels();\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+            Runnable runnable = () -> {\n+                try {\n+                    // Request humidity data from the thermostat if we are a CT80\n+                    if (isCT80() && config.disableHumidity != 1) {\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(HUMIDITY_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonHumidity) {\n+                            rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                        }\n+                    }\n+\n+                    if (config.disableLogs != 1) {\n+                        // Request runtime data from the thermostat\n+                        retryCounter = 0;\n+                        Object result = getRadioThermostatData(RUNTIME_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonRuntime) {\n+                            rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                        }\n+                    }\n+                } catch (Exception e) {\n+                    logger.debug(\"Exception occurred during execution: {}\", e.getMessage());\n+                }\n+            };\n+\n+            int delay = (config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 1, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    private void setupConnection() {\n+        String errorMsg = null;\n+\n+        // test the thermostat connection by getting the thermostat name and model\n+        Object nameResult = getRadioThermostatData(NAME_RESOURCE);\n+        if (nameResult instanceof RadioThermostatJsonName) {\n+            rthermData.setName(((RadioThermostatJsonName) nameResult).getName());\n+        } else {\n+            errorMsg = \"Unable to get thermostat name\";\n+        }\n+\n+        Object modelResult = getRadioThermostatData(MODEL_RESOURCE);\n+        if (modelResult instanceof RadioThermostatJsonModel) {\n+            rthermData.setModel(((RadioThermostatJsonModel) modelResult).getModel());\n+        } else {\n+            errorMsg = \"Unable to get thermostat model\";\n+        }\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions();\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!isCT80()) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (errorMsg == null) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                    rthermData.getName() + \" \" + rthermData.getModel());\n+            initialized = 1;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, errorMsg);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case JSON_CMD:\n+                    sendCommand(null, null, command.toString());\n+                    break;\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        rthermData.getThermostatData().setHold(0);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateAllChannels();\n+\n+                        // now just go ahead and refresh tstat data to update with the new active setpoint\n+                        // this takes a while for the JSON request to complete.\n+                        Object result = getRadioThermostatData(DEFAULT_RESOURCE);\n+                        if (result instanceof RadioThermostatJsonResponse) {\n+                            rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                            updateAllChannels();\n+                        }\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        RadioThermostatConfiguration config = getConfigAs(RadioThermostatConfiguration.class);\n+\n+        String hostName = config.hostName;\n+\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Request new data from the thermostat\n+     *\n+     * @param the resource URL constant for a particular thermostat JSON resource\n+     * @return an object mapping to one of the various thermostat JSON responses or null in case of error\n+     */\n+    private @Nullable Object getRadioThermostatData(String resource) {\n+        Object result = null;\n+        String errorMsg = null;\n+\n+        String urlStr = buildRequestURL(resource);\n+        logger.debug(\"URL = {}\", urlStr);\n+\n+        try {\n+            // Run the HTTP request and get the JSON response from the thermostat\n+            ContentResponse contentResponse = httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS)\n+                    .send();\n+\n+            String response = contentResponse.getContentAsString();\n+            logger.debug(\"thermostatResponse = {}\", response);\n+\n+            // Map the JSON response to the correct object\n+            if (DEFAULT_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonResponse.class);\n+            } else if (HUMIDITY_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonHumidity.class);\n+            } else if (RUNTIME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonRuntime.class);\n+            } else if (MODEL_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonModel.class);\n+            } else if (NAME_RESOURCE.equals(resource)) {\n+                result = gson.fromJson(response, RadioThermostatJsonName.class);\n+            }\n+\n+            if (result != null) {\n+                if (initialized == 1) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE,\n+                            rthermData.getName() + \" \" + rthermData.getModel());\n+                }\n+                return result;\n+            } else {\n+                retryCounter++;\n+                if (retryCounter == 1) {\n+                    logger.warn(\"Error in contacting the thermostat, retrying once\");\n+                    return getRadioThermostatData(resource);\n+                }\n+                errorMsg = \"missing data object\";\n+                logger.warn(\"Error in thermostat response: {}\", errorMsg);\n+            }\n+\n+        } catch (IllegalStateException | InterruptedException | TimeoutException | ExecutionException e) {\n+            errorMsg = e.getMessage();\n+            logger.warn(\"Error running thermostat request: {}\", errorMsg);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, errorMsg);\n+        return null;\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    private String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException\n+                | IllegalStateException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data\n+     * @return\n+     * @throws Exception\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) throws Exception {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(new Double(0))) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case STATUS:\n+                return data.getThermostatData().getStatus();\n+            case FAN_STATUS:\n+                return data.getThermostatData().getFanStatus();\n+            case DAY:\n+                return data.getThermostatData().getTime().getDayOfWeek();\n+            case HOUR:\n+                return data.getThermostatData().getTime().getHour();\n+            case MINUTE:\n+                return data.getThermostatData().getTime().getMinute();\n+            case DATE_STAMP:\n+                return data.getThermostatData().getTime().getThemostatDateTime();\n+            case LAST_UPDATE:\n+                return ZonedDateTime.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae2ac1a2bd0fb65f61e6b4cc39502a2f0d2b7f6"}, "originalPosition": 549}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9", "committedDate": "2020-05-29T19:52:42Z", "message": "refactor to async http and other review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMjg2MDg1", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-421286085", "createdAt": "2020-05-29T21:03:44Z", "commit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTowMzo0NFrOGcsABQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMTozMTo0MFrOGcspVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNDIxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    for (RadioThermostatEventListener listener : listeners) {\n          \n          \n            \n                        listener.onNewMessageEvent(event);\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432734213", "createdAt": "2020-05-29T21:03:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n+\n+    public RadioThermostatConnector(HttpClient httpClient, @Nullable String hostName) {\n+        this.httpClient = httpClient;\n+        this.hostName = hostName;\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(RadioThermostatEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(RadioThermostatEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Send an asynchronous http call to the thermostat, the response will be send to the\n+     * event listeners as a RadioThermostat event when it is finally received\n+     *\n+     * @param resouce the url of the json resource on the thermostat\n+     */\n+    public void getAsyncThermostatData(String resource) {\n+        String urlStr = buildRequestURL(resource);\n+\n+        httpClient.newRequest(urlStr).method(GET).timeout(20, TimeUnit.SECONDS).send(new BufferingResponseListener() {\n+            @Override\n+            public void onComplete(@Nullable Result result) {\n+                if (!result.isFailed()) {\n+                    String response = getContentAsString();\n+                    logger.debug(\"thermostatResponse = {}\", response);\n+                    dispatchKeyValue(resource, response);\n+                } else {\n+                    dispatchKeyValue(KEY_ERROR, \"\");\n+                }\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(String cmdKey, @Nullable String cmdVal) {\n+        return sendCommand(cmdKey, cmdVal, null);\n+    }\n+\n+    /**\n+     * Sends a command to the thermostat\n+     *\n+     * @param the JSON attribute key for the value to be updated\n+     * @param the value to be updated in the thermostat\n+     * @param JSON string to send directly to the thermostat instead of a key/value pair\n+     * @return the JSON response string from the thermostat\n+     */\n+    public String sendCommand(@Nullable String cmdKey, @Nullable String cmdVal, @Nullable String cmdJson) {\n+        // if we got a cmdJson string send that, otherwise build the json from the key and val params\n+        String postJson = cmdJson != null ? cmdJson : \"{\\\"\" + cmdKey + \"\\\":\" + cmdVal + \"}\";\n+        String urlStr = buildRequestURL(DEFAULT_RESOURCE);\n+\n+        String output = null;\n+\n+        try {\n+            Request request = httpClient.POST(urlStr);\n+            request.header(HttpHeader.ACCEPT, \"text/plain\");\n+            request.header(HttpHeader.CONTENT_TYPE, \"text/plain\");\n+            request.content(new StringContentProvider(postJson), \"application/json\");\n+\n+            ContentResponse contentResponse = request.send();\n+            int httpStatus = contentResponse.getStatus();\n+\n+            if (httpStatus != OK_200) {\n+                throw new RadioThermostatHttpException(\"Thermostat HTTP response code was: \" + httpStatus);\n+            }\n+            output = contentResponse.getContentAsString();\n+        } catch (RadioThermostatHttpException | InterruptedException | TimeoutException | ExecutionException e) {\n+            logger.warn(\"Error executing thermostat command: {}, {}\", postJson, e.getMessage());\n+        }\n+\n+        return output;\n+    }\n+\n+    /**\n+     * Build request URL from configuration data\n+     *\n+     * @return a valid URL for the thermostat's JSON interface\n+     */\n+    private String buildRequestURL(String resource) {\n+        String urlStr = URL.replace(\"%hostName%\", hostName);\n+        urlStr = urlStr.replace(\"%resource%\", resource);\n+\n+        return urlStr;\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        RadioThermostatEvent event = new RadioThermostatEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HttpClient httpClient;\n          \n          \n            \n                private @Nullable String hostName;\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                private final @Nullable String hostName;", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736254", "createdAt": "2020-05-29T21:08:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczNjUzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<RadioThermostatEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<RadioThermostatEventListener> listeners = new CopyOnWriteArrayList<>();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432736533", "createdAt": "2020-05-29T21:09:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatConnector.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import static org.eclipse.jetty.http.HttpMethod.GET;\n+import static org.eclipse.jetty.http.HttpStatus.OK_200;\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatHttpException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the RadioThermostat web interface\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatConnector {\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatConnector.class);\n+\n+    private static final String URL = \"http://%hostName%/%resource%\";\n+\n+    private HttpClient httpClient;\n+    private @Nullable String hostName;\n+\n+    private List<RadioThermostatEventListener> listeners = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDI5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent event);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740294", "createdAt": "2020-05-29T21:19:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/communication/RadioThermostatEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * RadtioThermostat Event Listener interface. Handles incoming RadioThermostat message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface RadioThermostatEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming RadioThermostat message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MDU5Mg==", "bodyText": "Please move final fields above the non-final fields", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432740592", "createdAt": "2020-05-29T21:19:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTAwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event) {\n          \n          \n            \n                    RadioThermostatEvent evt = (RadioThermostatEvent) event;\n          \n          \n            \n                public void onNewMessageEvent(RadioThermostatEvent evt) {", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741004", "createdAt": "2020-05-29T21:20:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTI0Nw==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741247", "createdAt": "2020-05-29T21:21:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 297}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTM4NA==", "bodyText": "this can be removed", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741384", "createdAt": "2020-05-29T21:22:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTU3Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n          \n          \n            \n                                rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n          \n          \n            \n                                rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741577", "createdAt": "2020-05-29T21:22:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MTg5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n          \n          \n            \n                                rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n          \n          \n            \n                                rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432741896", "createdAt": "2020-05-29T21:23:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MjAxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n          \n          \n            \n                                rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n          \n          \n            \n                                rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742012", "createdAt": "2020-05-29T21:23:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0Mjk3MA==", "bodyText": "Things might get wonky if the user supplies a value with a decimal point.", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432742970", "createdAt": "2020-05-29T21:26:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0MzgxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (data.getThermostatData().getHold() == 1) {\n          \n          \n            \n                                return OnOffType.ON;\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return OnOffType.OFF;\n          \n          \n            \n                            }\n          \n          \n            \n                            return OnOffType.from(data.getThermostatData().getHold() == 1);", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432743814", "createdAt": "2020-05-29T21:28:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable RadioThermostatConnector connector;\n+\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    private final Gson gson;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        RadioThermostatEvent evt = (RadioThermostatEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String evtKey = evt.getKey();\n+        String evtVal = evt.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+            Object result = null;\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonResponse.class);\n+                    rthermData.setThermostatData((RadioThermostatJsonResponse) result);\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonHumidity.class);\n+                    rthermData.setHumidity(((RadioThermostatJsonHumidity) result).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    result = gson.fromJson(evtVal, RadioThermostatJsonRuntime.class);\n+                    rthermData.setRuntime((RadioThermostatJsonRuntime) result);\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                if (data.getThermostatData().getHold() == 1) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc0NDc4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private RadioThermostatData rthermData = new RadioThermostatData();\n          \n          \n            \n                private final RadioThermostatData rthermData = new RadioThermostatData();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432744788", "createdAt": "2020-05-29T21:31:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,451 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private RadioThermostatData rthermData = new RadioThermostatData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a7d0c7b9a54b4319fc0cbf3510b4a5c41dc9cc9"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74d92c01f6c9f586b656087420157351699fd693", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/74d92c01f6c9f586b656087420157351699fd693", "committedDate": "2020-05-29T22:21:09Z", "message": "additional review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzM2ODYy", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-421336862", "createdAt": "2020-05-29T22:48:13Z", "commit": {"oid": "74d92c01f6c9f586b656087420157351699fd693"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjo0ODoxM1rOGcuUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMjo0ODoxM1rOGcuUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3MjIzMw==", "bodyText": "oops forgot to return! fixing...", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432772233", "createdAt": "2020-05-29T22:48:13Z", "author": {"login": "mlobstein"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.radiothermostat.internal.handler;\n+\n+import static org.openhab.binding.radiothermostat.internal.RadioThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PointType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatConfiguration;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatStateDescriptionProvider;\n+import org.openhab.binding.radiothermostat.internal.RadioThermostatThingActions;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatConnector;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEvent;\n+import org.openhab.binding.radiothermostat.internal.communication.RadioThermostatEventListener;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatData;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonHumidity;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonResponse;\n+import org.openhab.binding.radiothermostat.internal.json.RadioThermostatJsonRuntime;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link RadioThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * Based on the 'airquality' binding by Kuba Wolanin\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RadioThermostatHandler extends BaseThingHandler implements RadioThermostatEventListener {\n+    private static final int DEFAULT_REFRESH_PERIOD = 2;\n+    private static final int DEFAULT_LOG_REFRESH_PERIOD = 10;\n+\n+    private @Nullable final RadioThermostatStateDescriptionProvider stateDescriptionProvider;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RadioThermostatHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+    private final RadioThermostatData rthermData = new RadioThermostatData();\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> logRefreshJob;\n+\n+    private @Nullable RadioThermostatConnector connector;\n+    private @Nullable RadioThermostatConfiguration config;\n+\n+    public RadioThermostatHandler(Thing thing,\n+            @Nullable RadioThermostatStateDescriptionProvider stateDescriptionProvider, HttpClient httpClient) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.httpClient = httpClient;\n+        gson = new Gson();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing RadioThermostat handler.\");\n+        this.config = getConfigAs(RadioThermostatConfiguration.class);\n+        connector = new RadioThermostatConnector(httpClient, config.hostName);\n+        connector.addEventListener(this);\n+\n+        // populate fan mode options based on thermostat model\n+        List<StateOption> fanModeOptions = getFanModeOptions(config.isCT80);\n+        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), FAN_MODE), fanModeOptions);\n+\n+        // if we are not a CT-80, remove the humidity & program mode channel\n+        if (!config.isCT80) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+            channels.removeIf(c -> (c.getUID().getId().equals(HUMIDITY)));\n+            channels.removeIf(c -> (c.getUID().getId().equals(PROGRAM_MODE)));\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+        startAutomaticRefresh();\n+        if (!config.disableLogs || config.isCT80) {\n+            startAutomaticLogRefresh();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(RadioThermostatThingActions.class);\n+    }\n+\n+    /**\n+     * Start the job to periodically update data from the thermostat\n+     */\n+    private void startAutomaticRefresh() {\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // send an async call to the thermostat to get the 'tstat' data\n+                connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+            };\n+\n+            int delay = (config.refresh != null) ? config.refresh.intValue() : DEFAULT_REFRESH_PERIOD;\n+            refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, delay, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update humidity and runtime date from the thermostat\n+     */\n+    private void startAutomaticLogRefresh() {\n+        if (logRefreshJob == null || logRefreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                // Request humidity data from the thermostat if we are a CT80\n+                if (config.isCT80) {\n+                    // send an async call to the thermostat to get the humidity data\n+                    connector.getAsyncThermostatData(HUMIDITY_RESOURCE);\n+                }\n+\n+                if (!config.disableLogs) {\n+                    // send an async call to the thermostat to get the runtime data\n+                    connector.getAsyncThermostatData(RUNTIME_RESOURCE);\n+                }\n+            };\n+\n+            int delay = ((config.logRefresh != null) ? config.logRefresh.intValue() : DEFAULT_LOG_REFRESH_PERIOD) * 60;\n+            logRefreshJob = scheduler.scheduleWithFixedDelay(runnable, 30, delay, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing the RadioThermostat handler.\");\n+        connector.removeEventListener(this);\n+\n+        if (refreshJob != null && !refreshJob.isCancelled()) {\n+            refreshJob.cancel(true);\n+            refreshJob = null;\n+        }\n+        if (logRefreshJob != null && !logRefreshJob.isCancelled()) {\n+            logRefreshJob.cancel(true);\n+            logRefreshJob = null;\n+        }\n+    }\n+\n+    public void handleRawCommand(@Nullable String rawCommand) {\n+        connector.sendCommand(null, null, rawCommand);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannel(channelUID.getId(), rthermData);\n+        } else {\n+            Integer cmdInt = -1;\n+            String cmdStr = command.toString();\n+            if (cmdStr != null) {\n+                try {\n+                    // remove all non-numeric characters except negative '-' and parse int\n+                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n+                } catch (NumberFormatException e) {\n+                    logger.debug(\"Command: {} -> Not an integer\", cmdStr);\n+                }\n+            }\n+\n+            switch (channelUID.getId()) {\n+                case MODE:\n+                    // only do if commanded mode is different than current mode\n+                    if (!cmdInt.equals(rthermData.getThermostatData().getMode())) {\n+                        connector.sendCommand(\"tmode\", cmdStr);\n+\n+                        // set the new operating mode, reset everything else,\n+                        // because refreshing the tstat data below is really slow.\n+                        rthermData.getThermostatData().setMode(cmdInt);\n+                        rthermData.getThermostatData().setHeatTarget(0);\n+                        rthermData.getThermostatData().setCoolTarget(0);\n+                        updateChannel(SET_POINT, rthermData);\n+                        rthermData.getThermostatData().setHold(0);\n+                        updateChannel(HOLD, rthermData);\n+                        rthermData.getThermostatData().setProgramMode(-1);\n+                        updateChannel(PROGRAM_MODE, rthermData);\n+\n+                        // now just trigger a refresh of the thermost to get the new active setpoint\n+                        // this takes a while for the JSON request to complete (async).\n+                        connector.getAsyncThermostatData(DEFAULT_RESOURCE);\n+                    }\n+                    break;\n+                case FAN_MODE:\n+                    rthermData.getThermostatData().setFanMode(cmdInt);\n+                    connector.sendCommand(\"fmode\", cmdStr);\n+                    break;\n+                case PROGRAM_MODE:\n+                    rthermData.getThermostatData().setProgramMode(cmdInt);\n+                    connector.sendCommand(\"program_mode\", cmdStr);\n+                    break;\n+                case HOLD:\n+                    if (command instanceof OnOffType && command == OnOffType.ON) {\n+                        rthermData.getThermostatData().setHold(1);\n+                        connector.sendCommand(\"hold\", \"1\");\n+                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                        rthermData.getThermostatData().setHold(0);\n+                        connector.sendCommand(\"hold\", \"0\");\n+                    }\n+                    break;\n+                case SET_POINT:\n+                    String cmdKey = null;\n+                    if (rthermData.getThermostatData().getMode() == 1) {\n+                        cmdKey = \"t_heat\";\n+                        rthermData.getThermostatData().setHeatTarget(cmdInt);\n+                    } else if (rthermData.getThermostatData().getMode() == 2) {\n+                        cmdKey = \"t_cool\";\n+                        rthermData.getThermostatData().setCoolTarget(cmdInt);\n+                    } else {\n+                        // don't do anything if we are not in heat or cool mode\n+                        break;\n+                    }\n+                    connector.sendCommand(cmdKey, cmdInt.toString());\n+                    break;\n+                default:\n+                    logger.warn(\"Unsupported command: {}\", command.toString());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a RadioThermostat event received from the listeners\n+     *\n+     * @param event the event received from the listeners\n+     */\n+    @Override\n+    public void onNewMessageEvent(RadioThermostatEvent event) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", event.getKey(), event.getValue());\n+\n+        String evtKey = event.getKey();\n+        String evtVal = event.getValue();\n+\n+        if (KEY_ERROR.equals(evtKey)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Error retrieving data from Thermostat \");\n+        } else {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE);\n+\n+            // Map the JSON response to the correct object and update appropriate channels\n+            switch (evtKey) {\n+                case DEFAULT_RESOURCE:\n+                    rthermData.setThermostatData(gson.fromJson(evtVal, RadioThermostatJsonResponse.class));\n+                    updateAllChannels();\n+                    break;\n+                case HUMIDITY_RESOURCE:\n+                    rthermData.setHumidity(gson.fromJson(evtVal, RadioThermostatJsonHumidity.class).getHumidity());\n+                    updateChannel(HUMIDITY, rthermData);\n+                    break;\n+                case RUNTIME_RESOURCE:\n+                    rthermData.setRuntime(gson.fromJson(evtVal, RadioThermostatJsonRuntime.class));\n+                    updateChannel(TODAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(TODAY_COOL_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_HEAT_RUNTIME, rthermData);\n+                    updateChannel(YESTERDAY_COOL_RUNTIME, rthermData);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update the channel from the last Thermostat data retrieved\n+     *\n+     * @param channelId the id identifying the channel to be updated\n+     */\n+    private void updateChannel(String channelId, RadioThermostatData rthermData) {\n+        if (isLinked(channelId)) {\n+            Object value;\n+            try {\n+                value = getValue(channelId, rthermData);\n+            } catch (Exception e) {\n+                logger.debug(\"Error setting {} value\", channelId.toUpperCase());\n+                return;\n+            }\n+\n+            State state = null;\n+            if (value == null) {\n+                state = UnDefType.UNDEF;\n+            } else if (value instanceof PointType) {\n+                state = (PointType) value;\n+            } else if (value instanceof ZonedDateTime) {\n+                state = new DateTimeType((ZonedDateTime) value);\n+            } else if (value instanceof QuantityType<?>) {\n+                state = (QuantityType<?>) value;\n+            } else if (value instanceof BigDecimal) {\n+                state = new DecimalType((BigDecimal) value);\n+            } else if (value instanceof Integer) {\n+                state = new DecimalType(BigDecimal.valueOf(((Integer) value).longValue()));\n+            } else if (value instanceof String) {\n+                state = new StringType(value.toString());\n+            } else if (value instanceof OnOffType) {\n+                state = (OnOffType) value;\n+            } else {\n+                logger.warn(\"Update channel {}: Unsupported value type {}\", channelId,\n+                        value.getClass().getSimpleName());\n+            }\n+            logger.debug(\"Update channel {} with state {} ({})\", channelId, (state == null) ? \"null\" : state.toString(),\n+                    (value == null) ? \"null\" : value.getClass().getSimpleName());\n+\n+            // Update the channel\n+            if (state != null) {\n+                updateState(channelId, state);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update a given channelId from the thermostat data\n+     * \n+     * @param the channel id to be updated\n+     * @param data the RadioThermostat dto\n+     * @return the value to be set in the state\n+     */\n+    public static @Nullable Object getValue(String channelId, RadioThermostatData data) {\n+        switch (channelId) {\n+            case TEMPERATURE:\n+                if (!data.getThermostatData().getTemperature().equals(0d)) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getTemperature(),\n+                            API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case HUMIDITY:\n+                if (data.getHumidity() != 0) {\n+                    return new QuantityType<>(data.getHumidity(), API_HUMIDITY_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case MODE:\n+                return data.getThermostatData().getMode();\n+            case FAN_MODE:\n+                return data.getThermostatData().getFanMode();\n+            case PROGRAM_MODE:\n+                return data.getThermostatData().getProgramMode();\n+            case SET_POINT:\n+                if (data.getThermostatData().getSetpoint() != 0) {\n+                    return new QuantityType<Temperature>(data.getThermostatData().getSetpoint(), API_TEMPERATURE_UNIT);\n+                } else {\n+                    return null;\n+                }\n+            case OVERRIDE:\n+                return data.getThermostatData().getOverride();\n+            case HOLD:\n+                OnOffType.from(data.getThermostatData().getHold() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74d92c01f6c9f586b656087420157351699fd693"}, "originalPosition": 384}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c758c9437755c4476b83a746efd20954002f7a42", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c758c9437755c4476b83a746efd20954002f7a42", "committedDate": "2020-05-29T22:54:06Z", "message": "add missing return\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328", "committedDate": "2020-05-30T00:45:20Z", "message": "improve number parsing\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzY4Mzg5", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-421368389", "createdAt": "2020-05-30T01:58:57Z", "commit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMTo1ODo1N1rOGcwBFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwMjowNDowNFrOGcwCng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDAyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();\n          \n          \n            \n                                cmdInt = NumberFormat.getInstance().parse(cmdStr).intValue();", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800022", "createdAt": "2020-05-30T01:58:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/src/main/java/org/openhab/binding/radiothermostat/internal/handler/RadioThermostatHandler.java", "diffHunk": "@@ -193,9 +195,10 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             String cmdStr = command.toString();\n             if (cmdStr != null) {\n                 try {\n-                    // remove all non-numeric characters except negative '-' and parse int\n-                    cmdInt = Integer.parseInt(cmdStr.replaceAll(\"[^\\\\d-]\", \"\"));\n-                } catch (NumberFormatException e) {\n+                    // parse out an Integer from the string\n+                    // ie '70.5 F' becomes 70, also handles negative numbers \n+                    cmdInt = ((Number)NumberFormat.getInstance().parse(cmdStr)).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDM4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | today_heat_runtime     | Number               | The total number of minutes of heating run-time today                     |\n          \n          \n            \n            | today_cool_runtime     | Number               | The total number of minutes of cooling run-time today                     |\n          \n          \n            \n            | yesterday_heat_runtime | Number               | The total number of minutes of heating run-time yesterday                 |\n          \n          \n            \n            | yesterday_cool_runtime | Number               | The total number of minutes of cooling run-time yesterday                 |\n          \n          \n            \n            | today_heat_runtime     | Number:Time      | The total number of minutes of heating run-time today                     |\n          \n          \n            \n            | today_cool_runtime     | Number:Time      | The total number of minutes of cooling run-time today                     |\n          \n          \n            \n            | yesterday_heat_runtime | Number:Time   | The total number of minutes of heating run-time yesterday                 |\n          \n          \n            \n            | yesterday_cool_runtime | Number:Time   | The total number of minutes of cooling run-time yesterday                 |", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800383", "createdAt": "2020-05-30T02:03:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| isCT80          | Flag to enable additional features only available on the CT80 thermostat. Optional, the default is false. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is false.                   |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n+| mode                   | Number               | The current operating mode of the HVAC system                             |\n+| fan_mode               | Number               | The current operating mode of the fan                                     |\n+| program_mode           | Number               | The program schedule that the thermostat is running (CT80 Rev B only)     |\n+| set_point              | Number:Temperature   | The current temperature set point of the thermostat                       |\n+| status                 | Number               | Indicates the current running status of the HVAC system                   |\n+| fan_status             | Number               | Indicates the current fan status of the HVAC system                       |\n+| override               | Number               | Indicates if the normal program set-point has been manually overridden    |\n+| hold                   | Switch               | Indicates if the current set point temperature is to be held indefinitely |\n+| day                    | Number               | The current day of the week reported by the thermostat (0 = Monday)       |\n+| hour                   | Number               | The current hour of the day reported by the thermostat  (24 hr)           |\n+| minute                 | Number               | The current minute past the hour reported by the thermostat               |\n+| dt_stamp               | String               | The current day of the week and time reported by the thermostat (E HH:mm) |\n+| today_heat_runtime     | Number               | The total number of minutes of heating run-time today                     |\n+| today_cool_runtime     | Number               | The total number of minutes of cooling run-time today                     |\n+| yesterday_heat_runtime | Number               | The total number of minutes of heating run-time yesterday                 |\n+| yesterday_cool_runtime | Number               | The total number of minutes of cooling run-time yesterday                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMDQxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |\n          \n          \n            \n            | humidity               | Number:Dimensionless | The current humidity reading of the thermostat (CT80 only)                |", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r432800414", "createdAt": "2020-05-30T02:04:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such \n+as thermostat mode, fan mode, temperature set point and hold mode can be controlled. System run-time information and humidity readings \n+are polled less frequently and can be disabled completely if not desired. Humidity information is available only when using a CT80 \n+thermostat and I have noticed that the humidity reported is very inaccurate.\n+\n+The main caveat for using this binding is to keep in mind that the web server in the thermostat is very slow. Do not over load it \n+with excessive amounts of simultaneous commands. When changing the thermostat mode, the current temperature set point is cleared and \n+a refresh of the thermostat data is done to get the new mode's set point. Since retrieving the thermostat's data is the slowest \n+operation, it will take several seconds after changing the mode before the new set point is displayed. The 'Program Mode' command \n+is untested and according to the published API is only available on a CT80 Rev B.\n+\n+## Supported Things\n+\n+There is exactly one supported thing type, which represents the thermostat.\n+It has the `rtherm` id.\n+Multiple Things can be added if more than one thermostat is to be controlled.\n+\n+## Discovery\n+\n+Auto-discovery is supported if the thermostat can be located on the local network using SSDP. Otherwise the thing must be manually added.\n+\n+## Binding Configuration\n+\n+The binding has no configuration options, all configuration is done at Thing level.\n+\n+## Thing Configuration\n+\n+The thing has a few configuration parameters:\n+\n+|    Parameter    | Description                                                                                               |\n+|-----------------|-----------------------------------------------------------------------------------------------------------|\n+| hostName        | The host name or IP address of the thermostat. Mandatory.                                                 |\n+| refresh         | Overrides the refresh interval of the thermostat data. Optional, the default is 2 minutes.                |\n+| logRefresh      | Overrides the refresh interval of the run-time logs & humidity data. Optional, the default is 10 minutes. |\n+| isCT80          | Flag to enable additional features only available on the CT80 thermostat. Optional, the default is false. |\n+| disableLogs     | Disable retrieval of run-time logs from the thermostat. Optional, the default is false.                   |\n+\n+## Channels\n+\n+The thermostat information that is retrieved is available as these channels:\n+\n+| Channel ID             | Item Type            | Description                                                               |\n+|------------------------|----------------------|---------------------------------------------------------------------------|\n+| temperature            | Number:Temperature   | The current temperature reading of the thermostat                         |\n+| humidity               | Number               | The current humidity reading of the thermostat (CT80 only)                |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2c0aa1a5a2be279fdcac05fc68c83e2c1b15328"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c570596b307e24b4fa9a46494854112c44e5d4", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/87c570596b307e24b4fa9a46494854112c44e5d4", "committedDate": "2020-05-30T03:05:16Z", "message": "couple more changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMzc0MTg4", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-421374188", "createdAt": "2020-05-30T03:34:18Z", "commit": {"oid": "87c570596b307e24b4fa9a46494854112c44e5d4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "542afbb620dc55c0463e28e98aeb0a7e5505dfa6", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/542afbb620dc55c0463e28e98aeb0a7e5505dfa6", "committedDate": "2020-06-01T01:09:59Z", "message": "fix some warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "committedDate": "2020-06-04T21:19:29Z", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a748961fec70fa4731076e2670287a1cb0fa57f5", "committedDate": "2020-06-09T04:21:20Z", "message": "fix compilier warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzU2ODQy", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-436356842", "createdAt": "2020-06-24T06:26:19Z", "commit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyNjoxOVrOGoEksQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwNjoyNzoxN1rOGoEmOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTE1Mw==", "bodyText": "Please add a line break after every sentence throughout the README, thanks!", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444671153", "createdAt": "2020-06-24T06:26:19Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.radiothermostat/README.md", "diffHunk": "@@ -0,0 +1,201 @@\n+# RadioThermostat Binding\n+\n+This binding connects RadioThermostat/3M Filtrete models CT30, CT50/3M50, CT80, etc. with built-in Wi-Fi module to openHAB.\n+\n+The binding retrieves and periodically updates all basic system information from the thermostat. The main thermostat functions such ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY3MTU0Ng==", "bodyText": "As 2.5.6 has just been release, we have to ask you to change this version for a very last time, promised ;-)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>2.5.6-SNAPSHOT</version>\n          \n          \n            \n                <version>2.5.7-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/7266#discussion_r444671546", "createdAt": "2020-06-24T06:27:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.radiothermostat/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a748961fec70fa4731076e2670287a1cb0fa57f5"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "committedDate": "2020-06-24T13:47:17Z", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d290815e064605dcb42e8be261f725b6626fbbb8", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d290815e064605dcb42e8be261f725b6626fbbb8", "committedDate": "2020-06-24T13:49:09Z", "message": "Merge branch '2.5.x' into RadioThermostat"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76e8f563cf08eca6de40286b4f0ae8daeaf59906", "author": {"user": {"login": "mlobstein", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/76e8f563cf08eca6de40286b4f0ae8daeaf59906", "committedDate": "2020-06-24T14:09:31Z", "message": "Update pom version and format README\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2OTY0NjUz", "url": "https://github.com/openhab/openhab-addons/pull/7266#pullrequestreview-436964653", "createdAt": "2020-06-24T20:01:47Z", "commit": {"oid": "76e8f563cf08eca6de40286b4f0ae8daeaf59906"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 993, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}